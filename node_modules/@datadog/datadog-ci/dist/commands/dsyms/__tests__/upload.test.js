"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable: no-string-literal
const advanced_1 = require("clipanion/lib/advanced");
const fs_1 = require("fs");
const glob_1 = __importDefault(require("glob"));
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../../helpers/utils");
const upload_1 = require("../upload");
const utils_2 = require("../utils");
/**
 * `dwarfdump` and `lipo` are only available in macOS, so we mock their behaviour when running tests on other platforms.
 */
const mockDwarfdumpAndLipoIfNotMacOS = () => {
    if (os_1.platform() !== 'darwin') {
        // For `dwarfdump --uuid` mock, return the same output as the command would give on macOS:
        require('../utils').executeDwarfdump = jest.fn().mockImplementation((dsymPath) => {
            let fixture = dsymPath.includes('multiple-archs') ? fatDSYMFixture : undefined;
            fixture = fixture !== null && fixture !== void 0 ? fixture : (dsymPath.includes('single-arch') ? slimDSYMFixture : undefined);
            if (fixture !== undefined) {
                const outputLines = fixture.slices.map((slice) => {
                    const objectPathInDsym = path_1.default.relative(fixture.bundlePath, slice.objectPath);
                    const objectPathInMockedDSYM = utils_1.buildPath(dsymPath, objectPathInDsym);
                    return `UUID: ${slice.uuid} (${slice.arch}) ${objectPathInMockedDSYM}`;
                });
                return { stderr: '', stdout: outputLines.join('\n') };
            }
            else {
                throw new Error(`Cannot find mock dSYM fixture for dsymPath: ${dsymPath}`);
            }
        });
        // For `lipo -thin` mock, just copy the object to new location (without extracting the slice as macOS would do):
        require('../utils').executeLipo = jest
            .fn()
            .mockImplementation((objectPath, arch, newObjectPath) => __awaiter(void 0, void 0, void 0, function* () {
            yield fs_1.promises.copyFile(objectPath, newObjectPath);
            return { stderr: '', stdout: '' };
        }));
    }
};
/**
 * Fixture for dSYM containing two arch slices. This is the same dSYM information as can be
 * read with `dwarfdump --uuid ./src/commands/dsyms/__tests__/fixtures/multiple-archs/DDTest.framework.dSYM` on macOS.
 */
const fatDSYMFixture = {
    bundlePath: 'src/commands/dsyms/__tests__/fixtures/multiple-archs/DDTest.framework.dSYM',
    slices: [
        {
            arch: 'armv7',
            objectPath: 'src/commands/dsyms/__tests__/fixtures/multiple-archs/DDTest.framework.dSYM/Contents/Resources/DWARF/DDTest',
            uuid: 'C8469F85-B060-3085-B69D-E46C645560EA',
        },
        {
            arch: 'arm64',
            objectPath: 'src/commands/dsyms/__tests__/fixtures/multiple-archs/DDTest.framework.dSYM/Contents/Resources/DWARF/DDTest',
            uuid: '06EE3D68-D605-3E92-B92D-2F48C02A505E',
        },
    ],
};
/**
 * Fixture for dSYM containing single arch slice. This is the same dSYM information as can be
 * read with `dwarfdump --uuid ./src/commands/dsyms/__tests__/fixtures/single-archs/DDTest.framework.dSYM` on macOS.
 */
const slimDSYMFixture = {
    bundlePath: 'src/commands/dsyms/__tests__/fixtures/single-arch/DDTest.framework.dSYM',
    slices: [
        {
            arch: 'arm64',
            objectPath: 'src/commands/dsyms/__tests__/fixtures/single-arch/DDTest.framework.dSYM/Contents/Resources/DWARF/DDTest',
            uuid: '3BC12422-63CC-30E8-B916-E5006CE3286C',
        },
    ],
};
describe('upload', () => {
    beforeAll(() => {
        mockDwarfdumpAndLipoIfNotMacOS();
    });
    describe('findDSYMsInDirectory', () => {
        const command = new upload_1.UploadCommand();
        test('Should find dSYMs recursively', () => __awaiter(void 0, void 0, void 0, function* () {
            const expectedDSYMs = [fatDSYMFixture, slimDSYMFixture];
            const actualDSYMs = yield command['findDSYMsInDirectory']('src/commands/dsyms/__tests__/fixtures');
            expect(actualDSYMs.length).toEqual(2);
            expect(actualDSYMs).toContainEqual(expectedDSYMs[0]);
            expect(actualDSYMs).toContainEqual(expectedDSYMs[1]);
        }));
    });
    describe('parseDwarfdumpOutput', () => {
        const command = new upload_1.UploadCommand();
        test('Should read arch slice from single-line output', () => {
            const output = 'UUID: 00000000-1111-2222-3333-444444444444 (arm64) /folder/Foo.dSYM/Contents/Resources/DWARF/Foo';
            const slices = command['parseDwarfdumpOutput'](output);
            expect(slices).toEqual([
                {
                    arch: 'arm64',
                    objectPath: '/folder/Foo.dSYM/Contents/Resources/DWARF/Foo',
                    uuid: '00000000-1111-2222-3333-444444444444',
                },
            ]);
        });
        test('Should read arch slices from multi-line output', () => {
            const output = 'UUID: 00000000-1111-2222-3333-444444444444 (arm64) /folder/Foo.dSYM/Contents/Resources/DWARF/Foo\n' +
                'UUID: AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE (x86_64) /folder/Foo.dSYM/Contents/Resources/DWARF/Foo\n' +
                'UUID: FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF (armv7) /folder/Foo.dSYM/Contents/Resources/DWARF/Foo\n';
            const slices = command['parseDwarfdumpOutput'](output);
            expect(slices).toEqual([
                {
                    arch: 'arm64',
                    objectPath: '/folder/Foo.dSYM/Contents/Resources/DWARF/Foo',
                    uuid: '00000000-1111-2222-3333-444444444444',
                },
                {
                    arch: 'x86_64',
                    objectPath: '/folder/Foo.dSYM/Contents/Resources/DWARF/Foo',
                    uuid: 'AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE',
                },
                {
                    arch: 'armv7',
                    objectPath: '/folder/Foo.dSYM/Contents/Resources/DWARF/Foo',
                    uuid: 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF',
                },
            ]);
        });
        test('Should read arch slice if object path contains whitespaces', () => {
            const output = 'UUID: 00000000-1111-2222-3333-444444444444 (arm64) /folder with whitespaces/Foo Bar.dSYM/Contents/Resources/DWARF/Foo Bar';
            const slices = command['parseDwarfdumpOutput'](output);
            expect(slices).toEqual([
                {
                    arch: 'arm64',
                    objectPath: '/folder with whitespaces/Foo Bar.dSYM/Contents/Resources/DWARF/Foo Bar',
                    uuid: '00000000-1111-2222-3333-444444444444',
                },
            ]);
        });
        test('Should read no arch slices from invalid output', () => {
            const slices = command['parseDwarfdumpOutput']('');
            expect(slices).toEqual([]);
        });
    });
    describe('thinDSYMs', () => {
        const command = new upload_1.UploadCommand();
        test('Given fat dSYM, it should extract each arch slice to separate dSYM in target folder', () => __awaiter(void 0, void 0, void 0, function* () {
            const tmpDirectory = yield utils_2.createUniqueTmpDirectory();
            // Given
            const inputDSYM = fatDSYMFixture;
            expect(inputDSYM.slices.length).toBeGreaterThan(1);
            // When
            const extractedDSYMs = yield command['thinDSYMs']([inputDSYM], tmpDirectory);
            // Then
            expect(extractedDSYMs.length).toEqual(inputDSYM.slices.length);
            inputDSYM.slices.forEach((slice) => {
                expect(extractedDSYMs).toContainEqual({
                    bundlePath: `${utils_1.buildPath(tmpDirectory, slice.uuid)}.dSYM`,
                    slices: [
                        {
                            arch: slice.arch,
                            objectPath: `${utils_1.buildPath(tmpDirectory, slice.uuid)}.dSYM/Contents/Resources/DWARF/DDTest`,
                            uuid: slice.uuid,
                        },
                    ],
                });
            });
            const objectFilesInTargetFolder = glob_1.default.sync(utils_1.buildPath(tmpDirectory, '**/Contents/Resources/DWARF/DDTest'));
            expect(objectFilesInTargetFolder.length).toEqual(inputDSYM.slices.length);
            yield utils_2.deleteDirectory(tmpDirectory);
        }));
        test('Given slim dSYM, it should leave it untouched and not extract anything into target folder', () => __awaiter(void 0, void 0, void 0, function* () {
            const tmpDirectory = yield utils_2.createUniqueTmpDirectory();
            // Given
            const inputDSYM = slimDSYMFixture;
            expect(inputDSYM.slices.length).toEqual(1);
            // When
            const extractedDSYMs = yield command['thinDSYMs']([inputDSYM], tmpDirectory);
            // Then
            expect(extractedDSYMs).toEqual([inputDSYM]);
            const filesInTargetFolder = glob_1.default.sync(utils_1.buildPath(tmpDirectory, '*'));
            expect(filesInTargetFolder.length).toEqual(0);
            yield utils_2.deleteDirectory(tmpDirectory);
        }));
    });
    describe('compressDSYMsToDirectory', () => {
        const command = new upload_1.UploadCommand();
        test('Should archive dSYMs to target directory and name archives by their UUIDs', () => __awaiter(void 0, void 0, void 0, function* () {
            const tmpDirectory = yield utils_2.createUniqueTmpDirectory();
            const dsymFixtures = [fatDSYMFixture, slimDSYMFixture];
            // When
            const compressedDSYMs = yield command['compressDSYMsToDirectory'](dsymFixtures, tmpDirectory);
            // Then
            expect(compressedDSYMs[0].dsym).toEqual(dsymFixtures[0]);
            expect(compressedDSYMs[0].archivePath).toEqual(utils_1.buildPath(tmpDirectory, `${dsymFixtures[0].slices[0].uuid}.zip`));
            expect(fs_1.existsSync(compressedDSYMs[0].archivePath)).toBeTruthy();
            expect(compressedDSYMs[1].dsym).toEqual(dsymFixtures[1]);
            expect(compressedDSYMs[1].archivePath).toEqual(utils_1.buildPath(tmpDirectory, `${dsymFixtures[1].slices[0].uuid}.zip`));
            expect(fs_1.existsSync(compressedDSYMs[1].archivePath)).toBeTruthy();
            yield utils_2.deleteDirectory(tmpDirectory);
        }));
    });
});
describe('execute', () => {
    const makeCli = () => {
        const cli = new advanced_1.Cli();
        cli.register(upload_1.UploadCommand);
        return cli;
    };
    const createMockContext = () => {
        let data = '';
        return {
            stdout: {
                toString: () => data,
                write: (input) => {
                    data += input;
                },
            },
        };
    };
    const runCLI = (dsymPath) => __awaiter(void 0, void 0, void 0, function* () {
        const cli = makeCli();
        const context = createMockContext();
        process.env = { DATADOG_API_KEY: 'PLACEHOLDER' };
        const code = yield cli.run(['dsyms', 'upload', dsymPath, '--dry-run'], context);
        return { context, code };
    });
    beforeAll(() => {
        mockDwarfdumpAndLipoIfNotMacOS();
    });
    test('Should succeed with folder input', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('src/commands/dsyms/__tests__/fixtures/');
        const outputString = context.stdout.toString();
        const output = outputString.split(os_1.EOL);
        expect(outputString).not.toContain('Error');
        expect(code).toBe(0);
        expect(output[1]).toContain('Starting upload with concurrency 20. ');
        expect(output[2]).toContain('Will look for dSYMs in src/commands/dsyms/__tests__/fixtures/');
        expect(output[3]).toContain('Will use temporary intermediate directory: ');
        expect(output[4]).toContain('Will use temporary upload directory: ');
        expect(output[5]).toContain('Uploading C8469F85-B060-3085-B69D-E46C645560EA.zip (DDTest, arch: armv7, UUID: C8469F85-B060-3085-B69D-E46C645560EA)');
        expect(output[6]).toContain('Uploading 06EE3D68-D605-3E92-B92D-2F48C02A505E.zip (DDTest, arch: arm64, UUID: 06EE3D68-D605-3E92-B92D-2F48C02A505E)');
        expect(output[7]).toContain('Uploading 3BC12422-63CC-30E8-B916-E5006CE3286C.zip (DDTest, arch: arm64, UUID: 3BC12422-63CC-30E8-B916-E5006CE3286C)');
        expect(output[10]).toContain('Handled 3 dSYMs with success');
    }));
    test('Should succeed with zip file input', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('src/commands/dsyms/__tests__/fixtures/all.zip');
        const outputString = context.stdout.toString();
        const output = outputString.split(os_1.EOL);
        expect(outputString).not.toContain('Error');
        expect(code).toBe(0);
        expect(output[1]).toContain('Starting upload with concurrency 20. ');
        expect(output[2]).toContain('Will look for dSYMs in src/commands/dsyms/__tests__/fixtures/all.zip');
        expect(output[3]).toContain('Will use temporary intermediate directory: ');
        expect(output[4]).toContain('Will use temporary upload directory: ');
        expect(output[5]).toContain('Uploading C8469F85-B060-3085-B69D-E46C645560EA.zip (DDTest, arch: armv7, UUID: C8469F85-B060-3085-B69D-E46C645560EA)');
        expect(output[6]).toContain('Uploading 06EE3D68-D605-3E92-B92D-2F48C02A505E.zip (DDTest, arch: arm64, UUID: 06EE3D68-D605-3E92-B92D-2F48C02A505E)');
        expect(output[7]).toContain('Uploading 3BC12422-63CC-30E8-B916-E5006CE3286C.zip (DDTest, arch: arm64, UUID: 3BC12422-63CC-30E8-B916-E5006CE3286C)');
        expect(output[10]).toContain('Handled 3 dSYMs with success');
    }));
});
//# sourceMappingURL=upload.test.js.map