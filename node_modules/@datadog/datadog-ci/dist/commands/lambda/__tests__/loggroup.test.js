"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const loggroup_1 = require("../loggroup");
const fixtures_1 = require("./fixtures");
describe('loggroup', () => {
    describe('calculateLogGroupUpdateRequest', () => {
        test("creates a new log group when one doesn't exist", () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({});
            const result = yield loggroup_1.calculateLogGroupUpdateRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result).toMatchInlineSnapshot(`
                        Object {
                          "createLogGroupRequest": Object {
                            "logGroupName": "/aws/lambda/my-func",
                          },
                          "logGroupName": "/aws/lambda/my-func",
                          "subscriptionFilterRequest": Object {
                            "destinationArn": "my-forwarder",
                            "filterName": "datadog-ci-filter",
                            "filterPattern": "",
                            "logGroupName": "/aws/lambda/my-func",
                          },
                        }
                  `);
        }));
        test("adds a subscription filter when one doesn't exist", () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {},
                },
            });
            const result = yield loggroup_1.calculateLogGroupUpdateRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result).toMatchInlineSnapshot(`
                Object {
                  "logGroupName": "/aws/lambda/my-func",
                  "subscriptionFilterRequest": Object {
                    "destinationArn": "my-forwarder",
                    "filterName": "datadog-ci-filter",
                    "filterPattern": "",
                    "logGroupName": "/aws/lambda/my-func",
                  },
                }
            `);
        }));
        test('updates a subscription filter when an owned one already exists', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'wrong-destination',
                                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const result = yield loggroup_1.calculateLogGroupUpdateRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result).toMatchInlineSnapshot(`
                Object {
                  "logGroupName": "/aws/lambda/my-func",
                  "subscriptionFilterRequest": Object {
                    "destinationArn": "my-forwarder",
                    "filterName": "datadog-ci-filter",
                    "filterPattern": "",
                    "logGroupName": "/aws/lambda/my-func",
                  },
                }
            `);
        }));
        test('throws an exception when an unowned subscription filter exists', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'wrong-destination',
                                filterName: 'wrong-filter-name',
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const promise = loggroup_1.calculateLogGroupUpdateRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            yield expect(promise).rejects.toEqual(Error('Unknown subscription filter already on log group /aws/lambda/my-func. Only one subscription is allowed.'));
        }));
        test("doesn't update a subscription when filter is already correct", () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'my-forwarder',
                                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const result = yield loggroup_1.calculateLogGroupUpdateRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result).toMatchInlineSnapshot('undefined');
        }));
    });
    describe('calculateLogGroupRemoveRequest', () => {
        test('deletes the subscription filter that matches the forwarder', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'my-forwarder',
                                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const result = yield loggroup_1.calculateLogGroupRemoveRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result.deleteSubscriptionFilterRequest).toMatchInlineSnapshot(`
        Object {
          "filterName": "datadog-ci-filter",
          "logGroupName": "/aws/lambda/my-func",
        }
      `);
        }));
        test('deletes the subscription filter that matches the datadog subscription filter constant name', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'wrong-destination',
                                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const result = yield loggroup_1.calculateLogGroupRemoveRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result.deleteSubscriptionFilterRequest).toMatchInlineSnapshot(`
        Object {
          "filterName": "datadog-ci-filter",
          "logGroupName": "/aws/lambda/my-func",
        }
      `);
        }));
        test('returns log group configuration without delete request when forwarder and filter name does not match', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({
                '/aws/lambda/my-func': {
                    config: {
                        logGroups: [{ logGroupName: '/aws/lambda/my-func' }],
                    },
                    filters: {
                        subscriptionFilters: [
                            {
                                destinationArn: 'some-destination',
                                filterName: 'not-datadog',
                                logGroupName: '/aws/lambda/my-func',
                            },
                            {
                                destinationArn: 'some-other-destination',
                                filterName: 'not-datadog-either',
                                logGroupName: '/aws/lambda/my-func',
                            },
                        ],
                    },
                },
            });
            const result = yield loggroup_1.calculateLogGroupRemoveRequest(logs, '/aws/lambda/my-func', 'my-forwarder');
            expect(result).toMatchInlineSnapshot(`
        Object {
          "logGroupName": "/aws/lambda/my-func",
        }
      `);
        }));
    });
    describe('applyLogGroupConfiguration', () => {
        test('applies specified changes', () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({});
            const config = {
                createLogGroupRequest: {
                    logGroupName: '/aws/lambda/my-func',
                },
                deleteSubscriptionFilterRequest: {
                    filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                    logGroupName: '/aws/lambda/my-func',
                },
                logGroupName: '/aws/lambda/my-func',
                subscriptionFilterRequest: {
                    destinationArn: 'my-forwarder',
                    filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                    filterPattern: '',
                    logGroupName: '/aws/lambda/my-func',
                },
            };
            yield loggroup_1.applyLogGroupConfig(logs, config);
            expect(logs.createLogGroup).toHaveBeenCalledWith({
                logGroupName: '/aws/lambda/my-func',
            });
            expect(logs.deleteSubscriptionFilter).toHaveBeenCalledWith({
                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                logGroupName: '/aws/lambda/my-func',
            });
            expect(logs.putSubscriptionFilter).toHaveBeenCalledWith({
                destinationArn: 'my-forwarder',
                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                filterPattern: '',
                logGroupName: '/aws/lambda/my-func',
            });
        }));
        test("doesn't apply unspecified changes", () => __awaiter(void 0, void 0, void 0, function* () {
            const logs = fixtures_1.makeMockCloudWatchLogs({});
            const config = {
                logGroupName: '/aws/lambda/my-func',
                subscriptionFilterRequest: {
                    destinationArn: 'my-forwarder',
                    filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                    filterPattern: '',
                    logGroupName: '/aws/lambda/my-func',
                },
            };
            yield loggroup_1.applyLogGroupConfig(logs, config);
            expect(logs.createLogGroup).not.toHaveBeenCalled();
            expect(logs.deleteSubscriptionFilter).not.toHaveBeenCalled();
            expect(logs.putSubscriptionFilter).toHaveBeenCalledWith({
                destinationArn: 'my-forwarder',
                filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
                filterPattern: '',
                logGroupName: '/aws/lambda/my-func',
            });
        }));
    });
});
//# sourceMappingURL=loggroup.test.js.map