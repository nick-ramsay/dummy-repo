"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('inquirer');
const chalk_1 = require("chalk");
const inquirer_1 = require("inquirer");
const constants_1 = require("../constants");
const prompt_1 = require("../prompt");
const fixtures_1 = require("./fixtures");
describe('prompt', () => {
    describe('confirmationQuestion', () => {
        test('returns question with provided message', () => {
            const message = 'Do you want to continue?';
            const question = prompt_1.confirmationQuestion(message);
            expect(question.message).toBe(message);
        });
    });
    describe('datadogApiKeyTypeQuestion', () => {
        test('returns question with message pointing to the correct given site', () => {
            const site = 'datadoghq.com';
            const question = prompt_1.datadogApiKeyTypeQuestion(site);
            expect(question.message).toBe(`Which type of Datadog API Key you want to set? \nLearn more at ${chalk_1.blueBright(`https://app.${site}/organization-settings/api-keys`)}`);
        });
    });
    describe('datadogEnvVarsQuestions', () => {
        test('returns correct message when user selects DATADOG_API_KEY', () => {
            const datadogApiKeyType = {
                envVar: constants_1.CI_API_KEY_ENV_VAR,
                message: 'API Key:',
            };
            const question = prompt_1.datadogEnvVarsQuestions(datadogApiKeyType);
            expect(question.message).toBe('API Key:');
            expect(question.name).toBe(constants_1.CI_API_KEY_ENV_VAR);
        });
        test('returns correct message when user selects DATADOG_KMS_API_KEY', () => {
            const datadogApiKeyType = {
                envVar: constants_1.CI_KMS_API_KEY_ENV_VAR,
                message: 'KMS API Key:',
            };
            const question = prompt_1.datadogEnvVarsQuestions(datadogApiKeyType);
            expect(question.message).toBe('KMS API Key:');
            expect(question.name).toBe(constants_1.CI_KMS_API_KEY_ENV_VAR);
        });
        test('returns correct message when user selects DATADOG_API_KEY_SECRET_ARN', () => {
            const datadogApiKeyType = {
                envVar: constants_1.CI_API_KEY_SECRET_ARN_ENV_VAR,
                message: 'API Key Secret ARN:',
            };
            const question = prompt_1.datadogEnvVarsQuestions(datadogApiKeyType);
            expect(question.message).toBe('API Key Secret ARN:');
            expect(question.name).toBe(constants_1.CI_API_KEY_SECRET_ARN_ENV_VAR);
        });
    });
    describe('functionSelectionQuestion', () => {
        test('returns question with the provided function names being its choices', () => {
            const functionNames = ['my-func', 'my-func-2', 'my-third-func'];
            const question = prompt_1.functionSelectionQuestion(functionNames);
            expect(question.choices).toBe(functionNames);
        });
    });
    describe('requestAWSCrendentials', () => {
        const OLD_ENV = process.env;
        beforeEach(() => {
            jest.resetModules();
            process.env = {};
        });
        afterAll(() => {
            process.env = OLD_ENV;
        });
        test('sets the AWS credentials as environment variables', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.resolve({
                [constants_1.AWS_ACCESS_KEY_ID_ENV_VAR]: fixtures_1.mockAwsAccessKeyId,
                [constants_1.AWS_SECRET_ACCESS_KEY_ENV_VAR]: fixtures_1.mockAwsSecretAccessKey,
            }));
            yield prompt_1.requestAWSCredentials();
            expect(process.env[constants_1.AWS_ACCESS_KEY_ID_ENV_VAR]).toBe(fixtures_1.mockAwsAccessKeyId);
            expect(process.env[constants_1.AWS_SECRET_ACCESS_KEY_ENV_VAR]).toBe(fixtures_1.mockAwsSecretAccessKey);
        }));
        test('sets the AWS credentials with session token as environment variables', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.resolve({
                [constants_1.AWS_ACCESS_KEY_ID_ENV_VAR]: fixtures_1.mockAwsAccessKeyId,
                [constants_1.AWS_SECRET_ACCESS_KEY_ENV_VAR]: fixtures_1.mockAwsSecretAccessKey,
                [constants_1.AWS_SESSION_TOKEN_ENV_VAR]: 'some-session-token',
            }));
            yield prompt_1.requestAWSCredentials();
            expect(process.env[constants_1.AWS_ACCESS_KEY_ID_ENV_VAR]).toBe(fixtures_1.mockAwsAccessKeyId);
            expect(process.env[constants_1.AWS_SECRET_ACCESS_KEY_ENV_VAR]).toBe(fixtures_1.mockAwsSecretAccessKey);
            expect(process.env[constants_1.AWS_SESSION_TOKEN_ENV_VAR]).toBe('some-session-token');
        }));
        test('throws error when something unexpected happens while prompting', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.reject(new Error('Unexpected error')));
            let error;
            try {
                yield prompt_1.requestAWSCredentials();
            }
            catch (e) {
                if (e instanceof Error) {
                    error = e;
                }
            }
            expect(error === null || error === void 0 ? void 0 : error.message).toBe("Couldn't set AWS Credentials. Unexpected error");
        }));
    });
    describe('requestChangesConfirmation', () => {
        test('returns boolean when users responds to confirmation question', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.resolve({
                confirmation: true,
            }));
            const confirmation = yield prompt_1.requestChangesConfirmation('Do you want to continue?');
            expect(confirmation).toBe(true);
        }));
        test('throws error when something unexpected happens while prompting', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.reject(new Error('Unexpected error')));
            let error;
            try {
                yield prompt_1.requestChangesConfirmation('Do you wanna continue?');
            }
            catch (e) {
                if (e instanceof Error) {
                    error = e;
                }
            }
            expect(error === null || error === void 0 ? void 0 : error.message).toBe("Couldn't receive confirmation. Unexpected error");
        }));
    });
    describe('requestDatadogEnvVars', () => {
        const OLD_ENV = process.env;
        beforeEach(() => {
            jest.resetModules();
            process.env = {};
        });
        afterAll(() => {
            process.env = OLD_ENV;
        });
        test('sets the Datadog Environment Variables as provided/selected by user', () => __awaiter(void 0, void 0, void 0, function* () {
            const site = 'datadoghq.com';
            inquirer_1.prompt.mockImplementation((question) => {
                switch (question.name) {
                    case constants_1.CI_API_KEY_ENV_VAR:
                        return Promise.resolve({
                            [constants_1.CI_API_KEY_ENV_VAR]: fixtures_1.mockDatadogApiKey,
                        });
                    case constants_1.CI_SITE_ENV_VAR:
                        return Promise.resolve({
                            [constants_1.CI_SITE_ENV_VAR]: 'datadoghq.com',
                        });
                    case 'type':
                        return Promise.resolve({
                            type: {
                                envVar: constants_1.CI_API_KEY_ENV_VAR,
                                message: 'API Key:',
                            },
                        });
                    default:
                }
            });
            yield prompt_1.requestDatadogEnvVars();
            expect(process.env[constants_1.CI_SITE_ENV_VAR]).toBe(site);
            expect(process.env[constants_1.CI_API_KEY_ENV_VAR]).toBe(fixtures_1.mockDatadogApiKey);
        }));
        test('throws error when something unexpected happens while prompting', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.reject(new Error('Unexpected error')));
            let error;
            try {
                yield prompt_1.requestDatadogEnvVars();
            }
            catch (e) {
                if (e instanceof Error) {
                    error = e;
                }
            }
            expect(error === null || error === void 0 ? void 0 : error.message).toBe("Couldn't set Datadog Environment Variables. Unexpected error");
        }));
    });
    describe('requestFunctionSelection', () => {
        const selectedFunctions = ['my-func', 'my-func-2', 'my-third-func'];
        test('returns the selected functions', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.resolve({ functions: selectedFunctions }));
            const functions = yield prompt_1.requestFunctionSelection(selectedFunctions);
            expect(functions).toBe(selectedFunctions);
        }));
        test('throws error when something unexpected happens while prompting', () => __awaiter(void 0, void 0, void 0, function* () {
            ;
            inquirer_1.prompt.mockImplementation(() => Promise.reject(new Error('Unexpected error')));
            let error;
            try {
                yield prompt_1.requestFunctionSelection(selectedFunctions);
            }
            catch (e) {
                if (e instanceof Error) {
                    error = e;
                }
            }
            expect(error === null || error === void 0 ? void 0 : error.message).toBe("Couldn't receive selected functions. Unexpected error");
        }));
    });
});
//# sourceMappingURL=prompt.test.js.map