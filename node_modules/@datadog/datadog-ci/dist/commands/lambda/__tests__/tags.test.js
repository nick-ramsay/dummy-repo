"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('../loggroup');
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const tags_1 = require("../tags");
// tslint:disable-next-line
const { version } = require(path_1.default.join(__dirname, '../../../../package.json'));
const makeMockLambda = (functions) => ({
    listTags: jest.fn().mockImplementation(({ Resource }) => {
        var _a, _b;
        const tags = (_b = (_a = functions[Resource]) === null || _a === void 0 ? void 0 : _a.tagsResponse) !== null && _b !== void 0 ? _b : { Tags: {} };
        return {
            promise: () => Promise.resolve(tags),
        };
    }),
    tagResource: jest.fn().mockImplementation(() => ({ promise: () => Promise.resolve() })),
});
const VERSION_REGEX = /^v(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/;
describe('tags', () => {
    describe('applyTagConfig', () => {
        test('Calls tagResource with config data', () => __awaiter(void 0, void 0, void 0, function* () {
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument',
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            const config = {
                tagResourceRequest: {
                    Resource: 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument',
                    Tags: {
                        dd_sls_ci: 'v0.0.0',
                    },
                },
            };
            const result = yield tags_1.applyTagConfig(lambda, config);
            expect(result).toEqual(undefined);
            expect(lambda.tagResource).toHaveBeenCalledWith(config.tagResourceRequest);
        }));
        test('Handles undefined config', () => __awaiter(void 0, void 0, void 0, function* () {
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument',
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            const config = {
                tagResourceRequest: undefined,
            };
            const result = yield tags_1.applyTagConfig(lambda, config);
            expect(result).toEqual(undefined);
            expect(lambda.tagResource).not.toHaveBeenCalled();
        }));
    });
    describe('calculateTagUpdateRequest', () => {
        test('Handles no existing tags', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            const result = yield tags_1.calculateTagUpdateRequest(lambda, functionARN);
            expect(result).toEqual({
                tagResourceRequest: {
                    Resource: functionARN,
                    Tags: {
                        dd_sls_ci: expect.stringMatching(VERSION_REGEX),
                    },
                },
            });
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('Handles different version tag', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            lambda.listTags.mockImplementation(() => ({ promise: () => Promise.resolve({ Tags: { dd_sls_ci: 'v0.0.0' } }) }));
            const result = yield tags_1.calculateTagUpdateRequest(lambda, functionARN);
            expect(result).toEqual({
                tagResourceRequest: {
                    Resource: functionARN,
                    Tags: {
                        dd_sls_ci: expect.stringMatching(VERSION_REGEX),
                    },
                },
            });
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('Handles sam version tag', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            lambda.listTags.mockImplementation(() => ({ promise: () => Promise.resolve({ Tags: { dd_sls_ci: `v${version}` } }) }));
            const result = yield tags_1.calculateTagUpdateRequest(lambda, functionARN);
            expect(result).toBe(undefined);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
    });
    describe('calculateTagRemoveRequest', () => {
        test('returns untag resource configuration with the keys to delete', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                    tagsResponse: {
                        Tags: { dd_sls_ci: `v${version}` },
                    },
                },
            });
            const result = yield tags_1.calculateTagRemoveRequest(lambda, functionARN);
            expect(result).toMatchInlineSnapshot(`
        Object {
          "untagResourceRequest": Object {
            "Resource": "${functionARN}",
            "TagKeys": Array [
              "${constants_1.TAG_VERSION_NAME}",
            ],
          },
        }
      `);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('returns undefined when no tags need to be removed', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                    tagsResponse: {
                        Tags: { not_datadog: 'some-tag' },
                    },
                },
            });
            const result = yield tags_1.calculateTagRemoveRequest(lambda, functionARN);
            expect(result).toBeUndefined();
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
    });
    describe('hasVersionTag', () => {
        test('handles no tags', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            const result = yield tags_1.hasVersionTag(lambda, functionARN);
            expect(result).toBe(false);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('handles no version tag', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                },
            });
            lambda.listTags.mockImplementation(() => ({ promise: () => Promise.resolve({ Tags: { foo: 'bar' } }) }));
            const result = yield tags_1.hasVersionTag(lambda, functionARN);
            expect(result).toBe(false);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('handles different version tag', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                    tagsResponse: {
                        Tags: { dd_sls_ci: 'v0.0.0' },
                    },
                },
            });
            const result = yield tags_1.hasVersionTag(lambda, functionARN);
            expect(result).toBe(false);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
        test('handles same version tag', () => __awaiter(void 0, void 0, void 0, function* () {
            const functionARN = 'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument';
            const lambda = makeMockLambda({
                'arn:aws:lambda:us-east-1:000000000000:function:autoinstrument': {
                    config: {
                        FunctionArn: functionARN,
                        Handler: 'index.handler',
                        Runtime: 'nodejs12.x',
                    },
                    tagsResponse: {
                        Tags: { dd_sls_ci: `v${version}` },
                    },
                },
            });
            const result = yield tags_1.hasVersionTag(lambda, functionARN);
            expect(result).toBe(true);
            expect(lambda.listTags).toHaveBeenCalledWith({ Resource: functionARN });
        }));
    });
});
//# sourceMappingURL=tags.test.js.map