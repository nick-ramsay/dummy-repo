"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.willUpdateFunctionConfigs = exports.updateLambdaFunctionConfigs = exports.sentenceMatchesRegEx = exports.isLayerRuntime = exports.isSupportedRuntime = exports.isLambdaActive = exports.getRegion = exports.getLambdaFunctionConfig = exports.getLayers = exports.getLayerNameWithVersion = exports.getLayerArn = exports.getLambdaFunctionConfigs = exports.getLambdaFunctionConfigsFromRegex = exports.checkRuntimeTypesAreUniform = exports.getAllLambdaFunctionConfigs = exports.isMissingDatadogEnvVars = exports.isMissingAnyDatadogApiKeyEnvVar = exports.isMissingDatadogSiteEnvVar = exports.isMissingAWSCredentials = exports.findLatestLayerVersion = exports.collectFunctionsByRegion = exports.coerceBoolean = exports.addLayerArn = void 0;
const aws_sdk_1 = require("aws-sdk");
const constants_1 = require("../constants");
const loggroup_1 = require("../loggroup");
const tags_1 = require("../tags");
/**
 * Returns an array of merged layer ARNs if given a Full Layer ARN,
 * if not, it justs returns the layer ARNs provided.
 *
 * @param fullLayerARN a complete layer ARN.
 * @param partialLayerARN a partial layer ARN.
 * @param layerARNs an array of layer ARNs.
 * @returns an array of layer ARNs.
 */
const addLayerArn = (fullLayerArn, previousLayerName, layerARNs) => {
    if (fullLayerArn) {
        if (!layerARNs.includes(fullLayerArn)) {
            // Remove any other versions of the layer
            layerARNs = [...layerARNs.filter((layer) => !layer.includes(previousLayerName)), fullLayerArn];
        }
    }
    return layerARNs;
};
exports.addLayerArn = addLayerArn;
/**
 * Returns a coerced boolean given string booleans or booleans in
 * an spread array. Every other value will be ignored.
 *
 * @param fallback default value if none of the provided `values` comply.
 * @param values an spread array of string booleans or booleans.
 * @returns a coerced boolean.
 */
const coerceBoolean = (fallback, ...values) => {
    for (const value of values) {
        switch (typeof value) {
            case 'boolean':
                return value;
            case 'string':
                if (value.toString().toLowerCase() === 'true') {
                    return true;
                }
                else if (value.toString().toLowerCase() === 'false') {
                    return false;
                }
                break;
            default:
                continue;
        }
    }
    return fallback;
};
exports.coerceBoolean = coerceBoolean;
/**
 * Returns an array of functions grouped by its region, it
 * throws an error if there are functions without a region.
 *
 * @param functions an array of strings comprised by
 * Functions ARNs, Partial ARNs, or Function Names.
 * @param defaultRegion a fallback region
 * @returns an array of functions grouped by region
 */
const collectFunctionsByRegion = (functions, defaultRegion) => {
    var _a;
    const groups = {};
    const regionless = [];
    for (const func of functions) {
        const region = (_a = exports.getRegion(func)) !== null && _a !== void 0 ? _a : defaultRegion;
        if (region === undefined) {
            regionless.push(func);
            continue;
        }
        if (groups[region] === undefined) {
            groups[region] = [];
        }
        const group = groups[region];
        group.push(func);
    }
    if (regionless.length > 0) {
        throw Error(`No default region specified for ${JSON.stringify(regionless)}. Use -r, --region, or use a full functionARN\n`);
    }
    return groups;
};
exports.collectFunctionsByRegion = collectFunctionsByRegion;
/**
 * Given a layer runtime, return its latest version.
 *
 * @param runtime the runtime of the layer.
 * @param region the region where the layer is stored.
 * @returns the latest version of the layer to find.
 */
const findLatestLayerVersion = (layer, region) => __awaiter(void 0, void 0, void 0, function* () {
    let latestVersion = 0;
    let searchStep = latestVersion > 0 ? 1 : 100;
    let layerVersion = latestVersion + searchStep;
    const account = region.startsWith('us-gov') ? constants_1.GOVCLOUD_LAYER_AWS_ACCOUNT : constants_1.DEFAULT_LAYER_AWS_ACCOUNT;
    const layerName = constants_1.LAYER_LOOKUP[layer];
    let foundLatestVersion = false;
    const lambda = new aws_sdk_1.Lambda({ region });
    while (!foundLatestVersion) {
        try {
            // Search next version
            yield lambda
                .getLayerVersion({
                LayerName: `arn:aws:lambda:${region}:${account}:layer:${layerName}`,
                VersionNumber: layerVersion,
            })
                .promise();
            latestVersion = layerVersion;
            // Increase layer version
            layerVersion += searchStep;
        }
        catch (e) {
            // Search step is too big, reset target to previous version
            // with a smaller search step
            if (searchStep > 1) {
                layerVersion -= searchStep;
                searchStep /= 10;
                layerVersion += searchStep;
            }
            else {
                // Search step is 1, current version was not found.
                // It is likely that the last checked is the latest.
                // Check the next version to be certain, since
                // current version could've been deleted by accident.
                try {
                    layerVersion += searchStep;
                    yield lambda
                        .getLayerVersion({
                        LayerName: `arn:aws:lambda:${region}:${account}:layer:${layerName}`,
                        VersionNumber: layerVersion,
                    })
                        .promise();
                    latestVersion = layerVersion;
                    // Continue the search if the next version does exist (unlikely event)
                    layerVersion += searchStep;
                }
                catch (e) {
                    // The next version doesn't exist either, so the previous version is indeed the latest
                    foundLatestVersion = true;
                }
            }
        }
    }
    return latestVersion;
});
exports.findLatestLayerVersion = findLatestLayerVersion;
const isMissingAWSCredentials = () => 
// If env vars and aws_sdk_config.credentials are not set return true otherwise return false
(process.env[constants_1.AWS_ACCESS_KEY_ID_ENV_VAR] === undefined || process.env[constants_1.AWS_SECRET_ACCESS_KEY_ENV_VAR] === undefined) &&
    !aws_sdk_1.config.credentials;
exports.isMissingAWSCredentials = isMissingAWSCredentials;
const isMissingDatadogSiteEnvVar = () => {
    const site = process.env[constants_1.CI_SITE_ENV_VAR];
    if (site !== undefined) {
        return !constants_1.SITES.includes(site);
    }
    return true;
};
exports.isMissingDatadogSiteEnvVar = isMissingDatadogSiteEnvVar;
const isMissingAnyDatadogApiKeyEnvVar = () => !(process.env[constants_1.CI_API_KEY_ENV_VAR] ||
    process.env[constants_1.CI_KMS_API_KEY_ENV_VAR] ||
    process.env[constants_1.CI_API_KEY_SECRET_ARN_ENV_VAR]);
exports.isMissingAnyDatadogApiKeyEnvVar = isMissingAnyDatadogApiKeyEnvVar;
const isMissingDatadogEnvVars = () => exports.isMissingDatadogSiteEnvVar() || exports.isMissingAnyDatadogApiKeyEnvVar();
exports.isMissingDatadogEnvVars = isMissingDatadogEnvVars;
const getAllLambdaFunctionConfigs = (lambda) => __awaiter(void 0, void 0, void 0, function* () { return exports.getLambdaFunctionConfigsFromRegex(lambda, '.'); });
exports.getAllLambdaFunctionConfigs = getAllLambdaFunctionConfigs;
// Returns false if not all runtimes are of the same RuntimeType across multiple functions
const checkRuntimeTypesAreUniform = (configList) => configList
    .map((item) => item.lambdaConfig.Runtime)
    .every((runtime) => constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RUNTIME_LOOKUP[configList[0].lambdaConfig.Runtime]);
exports.checkRuntimeTypesAreUniform = checkRuntimeTypesAreUniform;
/**
 * Given a Lambda instance and a regular expression,
 * returns all the Function Configurations that match.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param pattern a regular expression
 * @returns an array of Lambda FunctionConfiguration's that match the pattern above.
 */
const getLambdaFunctionConfigsFromRegex = (lambda, pattern) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const regEx = new RegExp(pattern);
    const matchedFunctions = [];
    let retryCount = 0;
    let listFunctionsResponse;
    let nextMarker;
    while (true) {
        try {
            listFunctionsResponse = yield lambda.listFunctions({ Marker: nextMarker }).promise();
            (_a = listFunctionsResponse.Functions) === null || _a === void 0 ? void 0 : _a.map((fn) => { var _a; return ((_a = fn.FunctionName) === null || _a === void 0 ? void 0 : _a.match(regEx)) && matchedFunctions.push(fn); });
            nextMarker = listFunctionsResponse.NextMarker;
            if (!nextMarker) {
                break;
            }
            retryCount = 0;
        }
        catch (e) {
            retryCount++;
            if (retryCount > constants_1.LIST_FUNCTIONS_MAX_RETRY_COUNT) {
                throw Error(`Max retry count exceeded. ${e}`);
            }
        }
    }
    return matchedFunctions;
});
exports.getLambdaFunctionConfigsFromRegex = getLambdaFunctionConfigsFromRegex;
/**
 * Given a Lambda instance and an array of Lambda names,
 * return all the Lambda Function Configurations.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param functionARNs an array of strings comprised by
 * Functions ARNs, Partial ARNs, or Function Names.
 * @returns an array of Lambda FunctionConfiguration's.
 */
const getLambdaFunctionConfigs = (lambda, functionARNs) => {
    const promises = functionARNs.map((fn) => exports.getLambdaFunctionConfig(lambda, fn));
    return Promise.all(promises);
};
exports.getLambdaFunctionConfigs = getLambdaFunctionConfigs;
/**
 * Returns the correct ARN of a **Specific Runtime Layer** given its configuration, region,
 * and settings (optional).
 *
 * @param config a Lambda FunctionConfiguration.
 * @param region a region where the layer is hosted.
 * @param settings instrumentation settings, mainly used to change the AWS account that contains the Layer.
 * @returns the ARN of a **Specific Runtime Layer** with the correct region, account, architecture, and name.
 */
const getLayerArn = (config, layer, region, settings) => {
    var _a, _b;
    let layerName = constants_1.LAYER_LOOKUP[layer];
    if (constants_1.ARM_LAYERS.includes(layer) && ((_a = config.Architectures) === null || _a === void 0 ? void 0 : _a.includes(constants_1.ARM64_ARCHITECTURE))) {
        layerName += constants_1.ARM_LAYER_SUFFIX;
    }
    const account = (_b = settings === null || settings === void 0 ? void 0 : settings.layerAWSAccount) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_LAYER_AWS_ACCOUNT;
    const isGovCloud = region.startsWith('us-gov');
    if (isGovCloud) {
        return `arn:aws-us-gov:lambda:${region}:${constants_1.GOVCLOUD_LAYER_AWS_ACCOUNT}:layer:${layerName}`;
    }
    return `arn:aws:lambda:${region}:${account}:layer:${layerName}`;
};
exports.getLayerArn = getLayerArn;
const getLayerNameWithVersion = (layerArn) => {
    const [, , , , , , name, version] = layerArn.split(':');
    return name && version ? `${name}:${version}` : undefined;
};
exports.getLayerNameWithVersion = getLayerNameWithVersion;
const getLayers = (config) => { var _a; return ((_a = config.Layers) !== null && _a !== void 0 ? _a : []).map((layer) => layer.Arn); };
exports.getLayers = getLayers;
/**
 * Call the aws-sdk Lambda api to get a Function given
 * an ARN and then return its Configuration.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param functionARN a string, can be Function ARN, Partial ARN, or a Function Name.
 * @returns the Lambda FunctionConfiguration of the given ARN.
 */
const getLambdaFunctionConfig = (lambda, functionARN) => __awaiter(void 0, void 0, void 0, function* () {
    const params = {
        FunctionName: functionARN,
    };
    const result = yield lambda.getFunction(params).promise();
    // AWS typescript API is slightly mistyped, adds undefineds where
    // there shouldn't be.
    const config = result.Configuration;
    return config;
});
exports.getLambdaFunctionConfig = getLambdaFunctionConfig;
/**
 * Given a Function ARN, return its region by splitting the string,
 * can return undefined if it is doesn't exist.
 *
 * @param functionARN a string, can be Function ARN, Partial ARN, or a Function Name.
 * @returns the region of an ARN.
 */
const getRegion = (functionARN) => {
    const [, , , region] = functionARN.split(':');
    return region === undefined || region === '*' ? undefined : region;
};
exports.getRegion = getRegion;
/**
 * Returns whether a Lambda Function is active or throws an error if
 * the FunctionConfiguration does not comply with `Successful` or `Active`.
 *
 * @param lambda an instance of Lambda from aws-sdk.
 * @param config a Lambda FunctionConfiguration.
 * @param functionArn a string, can be Function ARN, Partial ARN, or a Function Name.
 * @param attempts the number of attemps that have passed since the last retry.
 * @returns if a Lambda Function is active.
 */
const isLambdaActive = (lambda, config, functionArn, attempts = 0) => __awaiter(void 0, void 0, void 0, function* () {
    // TODO remove 1 Oct 2021 https://aws.amazon.com/blogs/compute/tracking-the-state-of-lambda-functions/
    if (!config.State || !config.LastUpdateStatus) {
        return true;
    }
    if (config.LastUpdateStatus === 'Successful' && config.State === 'Active') {
        return true;
    }
    if (config.State === 'Pending' && attempts <= constants_1.MAX_LAMBDA_STATE_CHECK_ATTEMPTS) {
        yield wait(Math.pow(2, attempts) * 1000);
        const refetchedConfig = yield exports.getLambdaFunctionConfig(lambda, functionArn);
        return exports.isLambdaActive(lambda, refetchedConfig, functionArn, (attempts += 1));
    }
    throw Error(`Can't instrument ${functionArn}, as current State is ${config.State} (must be "Active") and Last Update Status is ${config.LastUpdateStatus} (must be "Successful")`);
});
exports.isLambdaActive = isLambdaActive;
/**
 * Returns whether the runtime given is supported by the Datadog CI Lambda.
 *
 * @param runtime a string representing a Lambda FunctionConfiguration Runtime.
 * @returns if a runtime is supported.
 */
const isSupportedRuntime = (runtime) => runtime !== undefined && constants_1.RUNTIME_LOOKUP[runtime] !== undefined;
exports.isSupportedRuntime = isSupportedRuntime;
const isLayerRuntime = (runtime) => constants_1.LAYER_LOOKUP[runtime] !== undefined;
exports.isLayerRuntime = isLayerRuntime;
const sentenceMatchesRegEx = (sentence, regex) => sentence.match(regex);
exports.sentenceMatchesRegEx = sentenceMatchesRegEx;
const updateLambdaFunctionConfigs = (lambda, cloudWatch, configs) => __awaiter(void 0, void 0, void 0, function* () {
    const results = configs.map((c) => __awaiter(void 0, void 0, void 0, function* () {
        if (c.updateRequest !== undefined) {
            yield lambda.updateFunctionConfiguration(c.updateRequest).promise();
        }
        if (c.logGroupConfiguration !== undefined) {
            yield loggroup_1.applyLogGroupConfig(cloudWatch, c.logGroupConfiguration);
        }
        if (c.tagConfiguration !== undefined) {
            yield tags_1.applyTagConfig(lambda, c.tagConfiguration);
        }
    }));
    yield Promise.all(results);
});
exports.updateLambdaFunctionConfigs = updateLambdaFunctionConfigs;
const willUpdateFunctionConfigs = (configs) => {
    var _a, _b, _c;
    let willUpdate = false;
    for (const config of configs) {
        if (config.updateRequest !== undefined ||
            ((_a = config.logGroupConfiguration) === null || _a === void 0 ? void 0 : _a.createLogGroupRequest) !== undefined ||
            ((_b = config.logGroupConfiguration) === null || _b === void 0 ? void 0 : _b.deleteSubscriptionFilterRequest) !== undefined ||
            ((_c = config.logGroupConfiguration) === null || _c === void 0 ? void 0 : _c.subscriptionFilterRequest) !== undefined ||
            (config === null || config === void 0 ? void 0 : config.tagConfiguration) !== undefined) {
            willUpdate = true;
            break;
        }
    }
    return willUpdate;
};
exports.willUpdateFunctionConfigs = willUpdateFunctionConfigs;
/**
 * Waits for n ms
 *
 * @param ms
 */
const wait = (ms) => new Promise((res) => setTimeout(res, ms));
//# sourceMappingURL=commons.js.map