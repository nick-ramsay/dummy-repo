"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdateRequest = exports.getInstrumentedFunctionConfigsFromRegEx = exports.getInstrumentedFunctionConfig = exports.getInstrumentedFunctionConfigs = void 0;
const constants_1 = require("../constants");
const loggroup_1 = require("../loggroup");
const tags_1 = require("../tags");
const commons_1 = require("./commons");
const getInstrumentedFunctionConfigs = (lambda, cloudWatch, region, functionARNs, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const lambdaFunctionConfigs = yield commons_1.getLambdaFunctionConfigs(lambda, functionARNs);
    const configs = [];
    for (const config of lambdaFunctionConfigs) {
        const functionConfig = yield exports.getInstrumentedFunctionConfig(lambda, cloudWatch, config, region, settings);
        configs.push(functionConfig);
    }
    return configs;
});
exports.getInstrumentedFunctionConfigs = getInstrumentedFunctionConfigs;
const getInstrumentedFunctionConfig = (lambda, cloudWatch, config, region, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const functionARN = config.FunctionArn;
    const runtime = config.Runtime;
    if (!commons_1.isSupportedRuntime(runtime)) {
        throw Error(`Can't instrument ${functionARN}, runtime ${runtime} not supported`);
    }
    yield commons_1.isLambdaActive(lambda, config, functionARN);
    const updateRequest = yield exports.calculateUpdateRequest(config, settings, region, runtime);
    let logGroupConfiguration;
    if (settings.forwarderARN !== undefined) {
        const logGroupName = `/aws/lambda/${config.FunctionName}`;
        logGroupConfiguration = yield loggroup_1.calculateLogGroupUpdateRequest(cloudWatch, logGroupName, settings.forwarderARN);
    }
    const tagConfiguration = yield tags_1.calculateTagUpdateRequest(lambda, functionARN);
    return {
        functionARN,
        lambdaConfig: config,
        logGroupConfiguration,
        tagConfiguration,
        updateRequest,
    };
});
exports.getInstrumentedFunctionConfig = getInstrumentedFunctionConfig;
const getInstrumentedFunctionConfigsFromRegEx = (lambda, cloudWatch, region, pattern, settings) => __awaiter(void 0, void 0, void 0, function* () {
    const matchedFunctions = yield commons_1.getLambdaFunctionConfigsFromRegex(lambda, pattern);
    const functionsToUpdate = [];
    for (const config of matchedFunctions) {
        const functionConfig = yield exports.getInstrumentedFunctionConfig(lambda, cloudWatch, config, region, settings);
        functionsToUpdate.push(functionConfig);
    }
    return functionsToUpdate;
});
exports.getInstrumentedFunctionConfigsFromRegEx = getInstrumentedFunctionConfigsFromRegEx;
const calculateUpdateRequest = (config, settings, region, runtime) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const oldEnvVars = Object.assign({}, (_a = config.Environment) === null || _a === void 0 ? void 0 : _a.Variables);
    const changedEnvVars = {};
    const functionARN = config.FunctionArn;
    const apiKey = process.env[constants_1.CI_API_KEY_ENV_VAR];
    const apiKeySecretArn = process.env[constants_1.CI_API_KEY_SECRET_ARN_ENV_VAR];
    const apiKmsKey = process.env[constants_1.CI_KMS_API_KEY_ENV_VAR];
    const site = process.env[constants_1.CI_SITE_ENV_VAR];
    if (functionARN === undefined) {
        return undefined;
    }
    const updateRequest = {
        FunctionName: functionARN,
    };
    let needsUpdate = false;
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.JAVA ||
        constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.CUSTOM ||
        constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.RUBY) {
        if (settings.layerVersion !== undefined) {
            throw new Error(`Only the --extension-version argument should be set for the ${runtime} runtime. Please remove the --layer-version argument from the instrument command.`);
        }
    }
    // We don't support ARM Architecture for .NET at this time. Abort instrumentation if the combination is detected.
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.DOTNET) {
        if ((_b = config.Architectures) === null || _b === void 0 ? void 0 : _b.includes(constants_1.ARM64_ARCHITECTURE)) {
            throw new Error('Instrumenting arm64 architecture is not currently supported for .NET. Please only instrument .NET functions using x86_64 architecture.');
        }
    }
    // Update Python Handler
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.PYTHON) {
        const expectedHandler = constants_1.PYTHON_HANDLER_LOCATION;
        if (config.Handler !== expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = constants_1.PYTHON_HANDLER_LOCATION;
        }
    }
    // Update Node Handler
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.NODE) {
        const expectedHandler = constants_1.NODE_HANDLER_LOCATION;
        if (config.Handler !== expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = constants_1.NODE_HANDLER_LOCATION;
        }
    }
    // Update Env Vars
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.PYTHON || constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.NODE) {
        if (oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR] === undefined) {
            needsUpdate = true;
            changedEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR] = (_c = config.Handler) !== null && _c !== void 0 ? _c : '';
        }
    }
    // KMS > Secrets Manager > API Key
    if (apiKmsKey !== undefined && oldEnvVars[constants_1.KMS_API_KEY_ENV_VAR] !== apiKmsKey) {
        needsUpdate = true;
        changedEnvVars[constants_1.KMS_API_KEY_ENV_VAR] = apiKmsKey;
    }
    else if (apiKeySecretArn !== undefined && oldEnvVars[constants_1.API_KEY_SECRET_ARN_ENV_VAR] !== apiKeySecretArn) {
        const isNode = constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.NODE;
        const isSendingSynchronousMetrics = settings.extensionVersion === undefined && !settings.flushMetricsToLogs;
        if (isSendingSynchronousMetrics && isNode) {
            throw new Error('`apiKeySecretArn` is not supported for Node runtimes when using Synchronous Metrics. Use either `apiKey` or `apiKmsKey`.');
        }
        needsUpdate = true;
        changedEnvVars[constants_1.API_KEY_SECRET_ARN_ENV_VAR] = apiKeySecretArn;
    }
    else if (apiKey !== undefined && oldEnvVars[constants_1.API_KEY_ENV_VAR] !== apiKey) {
        needsUpdate = true;
        changedEnvVars[constants_1.API_KEY_ENV_VAR] = apiKey;
    }
    if (site !== undefined && oldEnvVars[constants_1.SITE_ENV_VAR] !== site) {
        if (constants_1.SITES.includes(site.toLowerCase())) {
            needsUpdate = true;
            changedEnvVars[constants_1.SITE_ENV_VAR] = site;
        }
        else {
            throw new Error('Warning: Invalid site URL. Must be either datadoghq.com, datadoghq.eu, us3.datadoghq.com, us5.datadoghq.com, or ddog-gov.com.');
        }
    }
    if (site === undefined && oldEnvVars[constants_1.SITE_ENV_VAR] === undefined) {
        needsUpdate = true;
        changedEnvVars[constants_1.SITE_ENV_VAR] = 'datadoghq.com';
    }
    const environmentVarsTupleArray = [
        ['captureLambdaPayload', constants_1.CAPTURE_LAMBDA_PAYLOAD_ENV_VAR],
        ['environment', constants_1.ENVIRONMENT_ENV_VAR],
        ['extraTags', constants_1.EXTRA_TAGS_ENV_VAR],
        ['mergeXrayTraces', constants_1.MERGE_XRAY_TRACES_ENV_VAR],
        ['service', constants_1.SERVICE_ENV_VAR],
        ['tracingEnabled', constants_1.TRACE_ENABLED_ENV_VAR],
        ['version', constants_1.VERSION_ENV_VAR],
    ];
    for (const [key, environmentVar] of environmentVarsTupleArray) {
        if (settings[key] !== undefined && oldEnvVars[environmentVar] !== ((_d = settings[key]) === null || _d === void 0 ? void 0 : _d.toString())) {
            needsUpdate = true;
            changedEnvVars[environmentVar] = settings[key].toString();
        }
    }
    // Skip adding DD_FLUSH_TO_LOGS when using Extension
    const isUsingExtension = settings.extensionVersion !== undefined;
    if (!isUsingExtension &&
        settings.flushMetricsToLogs !== undefined &&
        oldEnvVars[constants_1.FLUSH_TO_LOG_ENV_VAR] !== ((_e = settings.flushMetricsToLogs) === null || _e === void 0 ? void 0 : _e.toString())) {
        needsUpdate = true;
        changedEnvVars[constants_1.FLUSH_TO_LOG_ENV_VAR] = settings.flushMetricsToLogs.toString();
    }
    const newEnvVars = Object.assign(Object.assign({}, oldEnvVars), changedEnvVars);
    if (newEnvVars[constants_1.LOG_LEVEL_ENV_VAR] !== settings.logLevel) {
        needsUpdate = true;
        if (settings.logLevel) {
            newEnvVars[constants_1.LOG_LEVEL_ENV_VAR] = settings.logLevel;
        }
        else {
            delete newEnvVars[constants_1.LOG_LEVEL_ENV_VAR];
        }
    }
    if (runtime === constants_1.DOTNET_RUNTIME) {
        needsUpdate = true;
        newEnvVars[constants_1.ENABLE_PROFILING_ENV_VAR] = constants_1.CORECLR_ENABLE_PROFILING;
        newEnvVars[constants_1.PROFILER_ENV_VAR] = constants_1.CORECLR_PROFILER;
        newEnvVars[constants_1.PROFILER_PATH_ENV_VAR] = constants_1.CORECLR_PROFILER_PATH;
        newEnvVars[constants_1.DOTNET_TRACER_HOME_ENV_VAR] = constants_1.DD_DOTNET_TRACER_HOME;
    }
    updateRequest.Environment = {
        Variables: newEnvVars,
    };
    let layerARNs = commons_1.getLayers(config);
    const originalLayerARNs = layerARNs;
    let needsLayerUpdate = false;
    if (commons_1.isLayerRuntime(runtime)) {
        const lambdaLibraryLayerArn = commons_1.getLayerArn(config, config.Runtime, region, settings);
        const lambdaLibraryLayerName = constants_1.LAYER_LOOKUP[runtime];
        let fullLambdaLibraryLayerARN;
        if (settings.layerVersion !== undefined || settings.interactive) {
            let layerVersion = settings.layerVersion;
            if (settings.interactive && !settings.layerVersion) {
                layerVersion = yield commons_1.findLatestLayerVersion(config.Runtime, region);
            }
            fullLambdaLibraryLayerARN = `${lambdaLibraryLayerArn}:${layerVersion}`;
        }
        layerARNs = commons_1.addLayerArn(fullLambdaLibraryLayerARN, lambdaLibraryLayerName, layerARNs);
    }
    const lambdaExtensionLayerArn = commons_1.getLayerArn(config, constants_1.EXTENSION_LAYER_KEY, region, settings);
    let fullExtensionLayerARN;
    if (settings.extensionVersion !== undefined || settings.interactive) {
        let extensionVersion = settings.extensionVersion;
        if (settings.interactive && !settings.extensionVersion) {
            extensionVersion = yield commons_1.findLatestLayerVersion(constants_1.EXTENSION_LAYER_KEY, region);
        }
        fullExtensionLayerARN = `${lambdaExtensionLayerArn}:${extensionVersion}`;
    }
    layerARNs = commons_1.addLayerArn(fullExtensionLayerARN, constants_1.DD_LAMBDA_EXTENSION_LAYER_NAME, layerARNs);
    if (originalLayerARNs.sort().join(',') !== layerARNs.sort().join(',')) {
        needsLayerUpdate = true;
    }
    if (needsLayerUpdate) {
        needsUpdate = true;
        updateRequest.Layers = layerARNs;
    }
    layerARNs.forEach((layerARN) => {
        if (layerARN.includes(constants_1.DD_LAMBDA_EXTENSION_LAYER_NAME) &&
            newEnvVars[constants_1.API_KEY_ENV_VAR] === undefined &&
            newEnvVars[constants_1.API_KEY_SECRET_ARN_ENV_VAR] === undefined &&
            newEnvVars[constants_1.KMS_API_KEY_ENV_VAR] === undefined) {
            throw new Error(`When 'extensionLayer' is set, ${constants_1.CI_API_KEY_ENV_VAR}, ${constants_1.CI_KMS_API_KEY_ENV_VAR}, or ${constants_1.CI_API_KEY_SECRET_ARN_ENV_VAR} must also be set`);
        }
    });
    return needsUpdate ? updateRequest : undefined;
});
exports.calculateUpdateRequest = calculateUpdateRequest;
//# sourceMappingURL=instrument.js.map