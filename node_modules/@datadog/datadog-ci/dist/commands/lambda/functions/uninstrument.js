"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateUpdateRequest = exports.getUninstrumentedFunctionConfigsFromRegEx = exports.getUninstrumentedFunctionConfig = exports.getUninstrumentedFunctionConfigs = void 0;
const constants_1 = require("../constants");
const loggroup_1 = require("../loggroup");
const tags_1 = require("../tags");
const commons_1 = require("./commons");
const getUninstrumentedFunctionConfigs = (lambda, cloudWatch, functionARNs, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const lambdaFunctionConfigs = yield commons_1.getLambdaFunctionConfigs(lambda, functionARNs);
    const configs = [];
    for (const config of lambdaFunctionConfigs) {
        const functionConfig = yield exports.getUninstrumentedFunctionConfig(lambda, cloudWatch, config, forwarderARN);
        configs.push(functionConfig);
    }
    return configs;
});
exports.getUninstrumentedFunctionConfigs = getUninstrumentedFunctionConfigs;
const getUninstrumentedFunctionConfig = (lambda, cloudWatch, config, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const functionARN = config.FunctionArn;
    const runtime = config.Runtime;
    if (!commons_1.isSupportedRuntime(runtime)) {
        throw Error(`Can't un-instrument ${functionARN}, runtime ${runtime} not supported`);
    }
    const updateRequest = exports.calculateUpdateRequest(config, runtime);
    let logGroupConfiguration;
    if (forwarderARN) {
        const logGroupName = `/aws/lambda/${config.FunctionName}`;
        logGroupConfiguration = yield loggroup_1.calculateLogGroupRemoveRequest(cloudWatch, logGroupName, forwarderARN);
    }
    const tagConfiguration = yield tags_1.calculateTagRemoveRequest(lambda, functionARN);
    return {
        functionARN,
        lambdaConfig: config,
        logGroupConfiguration,
        tagConfiguration,
        updateRequest,
    };
});
exports.getUninstrumentedFunctionConfig = getUninstrumentedFunctionConfig;
const getUninstrumentedFunctionConfigsFromRegEx = (lambda, cloudWatch, pattern, forwarderArn) => __awaiter(void 0, void 0, void 0, function* () {
    const matchedFunctions = yield commons_1.getLambdaFunctionConfigsFromRegex(lambda, pattern);
    const functionsToUpdate = [];
    for (const config of matchedFunctions) {
        const functionConfig = yield exports.getUninstrumentedFunctionConfig(lambda, cloudWatch, config, forwarderArn);
        functionsToUpdate.push(functionConfig);
    }
    return functionsToUpdate;
});
exports.getUninstrumentedFunctionConfigsFromRegEx = getUninstrumentedFunctionConfigsFromRegEx;
const calculateUpdateRequest = (config, runtime) => {
    var _a, _b;
    const oldEnvVars = Object.assign({}, (_a = config.Environment) === null || _a === void 0 ? void 0 : _a.Variables);
    const functionARN = config.FunctionArn;
    if (functionARN === undefined) {
        return undefined;
    }
    const updateRequest = {
        FunctionName: functionARN,
    };
    let needsUpdate = false;
    // Remove Handler for Python
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.PYTHON) {
        const expectedHandler = constants_1.PYTHON_HANDLER_LOCATION;
        if (config.Handler === expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR];
            delete oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR];
        }
    }
    // Remove Handler for Node
    if (constants_1.RUNTIME_LOOKUP[runtime] === constants_1.RuntimeType.NODE) {
        const expectedHandler = constants_1.NODE_HANDLER_LOCATION;
        if (config.Handler === expectedHandler) {
            needsUpdate = true;
            updateRequest.Handler = oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR];
            delete oldEnvVars[constants_1.LAMBDA_HANDLER_ENV_VAR];
        }
    }
    /**
     * Array used to remove environment vars used in
     * the Lambda environment.
     */
    const environmentVarsArray = [
        constants_1.API_KEY_ENV_VAR,
        constants_1.API_KEY_SECRET_ARN_ENV_VAR,
        constants_1.KMS_API_KEY_ENV_VAR,
        constants_1.SITE_ENV_VAR,
        constants_1.CAPTURE_LAMBDA_PAYLOAD_ENV_VAR,
        constants_1.ENVIRONMENT_ENV_VAR,
        constants_1.EXTRA_TAGS_ENV_VAR,
        constants_1.FLUSH_TO_LOG_ENV_VAR,
        constants_1.MERGE_XRAY_TRACES_ENV_VAR,
        constants_1.LOG_LEVEL_ENV_VAR,
        constants_1.SERVICE_ENV_VAR,
        constants_1.TRACE_ENABLED_ENV_VAR,
        constants_1.VERSION_ENV_VAR,
        constants_1.ENABLE_PROFILING_ENV_VAR,
        constants_1.PROFILER_ENV_VAR,
        constants_1.PROFILER_PATH_ENV_VAR,
        constants_1.DOTNET_TRACER_HOME_ENV_VAR,
    ];
    // Remove Environment Variables
    for (const environmentVar of environmentVarsArray) {
        if (oldEnvVars[environmentVar]) {
            needsUpdate = true;
            delete oldEnvVars[environmentVar];
        }
    }
    updateRequest.Environment = {
        Variables: oldEnvVars,
    };
    // Remove Layers
    let needsLayerRemoval = false;
    const lambdaLibraryLayerName = constants_1.LAYER_LOOKUP[runtime];
    const originalLayerARNs = commons_1.getLayers(config);
    const layerARNs = ((_b = config.Layers) !== null && _b !== void 0 ? _b : [])
        .filter((layer) => { var _a, _b; return !((_a = layer.Arn) === null || _a === void 0 ? void 0 : _a.includes(lambdaLibraryLayerName)) && !((_b = layer.Arn) === null || _b === void 0 ? void 0 : _b.includes(constants_1.DD_LAMBDA_EXTENSION_LAYER_NAME)); })
        .map((layer) => { var _a; return (_a = layer.Arn) !== null && _a !== void 0 ? _a : ''; });
    if (originalLayerARNs.sort().join(',') !== layerARNs.sort().join(',')) {
        needsLayerRemoval = true;
    }
    if (needsLayerRemoval) {
        needsUpdate = true;
        updateRequest.Layers = layerARNs;
    }
    return needsUpdate ? updateRequest : undefined;
};
exports.calculateUpdateRequest = calculateUpdateRequest;
//# sourceMappingURL=uninstrument.js.map