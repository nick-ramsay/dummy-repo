"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentCommand = void 0;
const aws_sdk_1 = require("aws-sdk");
const chalk_1 = require("chalk");
const clipanion_1 = require("clipanion");
const utils_1 = require("../../helpers/utils");
const git_1 = require("../git-metadata/git");
const upload_1 = require("../git-metadata/upload");
const constants_1 = require("./constants");
const commons_1 = require("./functions/commons");
const instrument_1 = require("./functions/instrument");
const prompt_1 = require("./prompt");
class InstrumentCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = {
            functions: [],
            region: process.env[constants_1.AWS_DEFAULT_REGION_ENV_VAR],
            tracing: 'true',
        };
        this.dryRun = false;
        this.functions = [];
        this.interactive = false;
        this.sourceCodeIntegration = false;
    }
    execute() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const lambdaConfig = { lambda: this.config };
            this.config = (yield utils_1.parseConfigFile(lambdaConfig, this.configPath)).lambda;
            let hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            if (this.interactive) {
                try {
                    if (commons_1.isMissingAWSCredentials()) {
                        this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[!]'))} No AWS credentials found, let's set them up! Or you can re-run the command and supply the AWS credentials in the same way when you invoke the AWS CLI.\n`);
                        yield prompt_1.requestAWSCredentials();
                    }
                    // Always ask for region since the user may not want to use the default
                    this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[!]'))} Configure AWS region.\n`);
                    yield prompt_1.requestAWSRegion(process.env[constants_1.AWS_DEFAULT_REGION_ENV_VAR]);
                    if (commons_1.isMissingDatadogEnvVars()) {
                        this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[!]'))} Configure Datadog settings.\n`);
                        yield prompt_1.requestDatadogEnvVars();
                    }
                }
                catch (e) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} ${e}\n`);
                    return 1;
                }
                const region = (_b = (_a = this.region) !== null && _a !== void 0 ? _a : this.config.region) !== null && _b !== void 0 ? _b : process.env[constants_1.AWS_DEFAULT_REGION_ENV_VAR];
                this.region = region;
                // If user doesn't specify functions, allow them
                // to select from all of the functions from the
                // requested region.
                if (!hasSpecifiedFunctions) {
                    try {
                        const lambda = new aws_sdk_1.Lambda({ region });
                        this.context.stdout.write('Fetching Lambda functions, this might take a while.\n');
                        const functionNames = (_c = (yield commons_1.getAllLambdaFunctionConfigs(lambda)).map((config) => config.FunctionName).sort()) !== null && _c !== void 0 ? _c : [];
                        if (functionNames.length === 0) {
                            this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't find any Lambda functions in the specified region.\n`);
                            return 1;
                        }
                        const functions = yield prompt_1.requestFunctionSelection(functionNames);
                        this.functions = functions;
                    }
                    catch (err) {
                        this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                        return 1;
                    }
                }
                try {
                    yield prompt_1.requestEnvServiceVersion();
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Grabbing env, service, and version values from user. ${err}\n`);
                    return 1;
                }
                this.setEnvServiceVersion();
            }
            const settings = this.getSettings();
            if (settings === undefined) {
                return 1;
            }
            hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            const hasSpecifiedRegExPattern = this.regExPattern !== undefined && this.regExPattern !== '';
            if (!hasSpecifiedFunctions && !hasSpecifiedRegExPattern) {
                this.context.stdout.write(`${chalk_1.red('[Error]')} No functions specified for instrumentation.\n`);
                return 1;
            }
            if (settings.extensionVersion && settings.forwarderARN) {
                this.context.stdout.write(`${chalk_1.red('[Error]')} "extensionVersion" and "forwarder" should not be used at the same time.\n`);
                return 1;
            }
            if (this.sourceCodeIntegration) {
                if (!process.env.DATADOG_API_KEY) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Missing DATADOG_API_KEY in your environment\n`);
                    return 1;
                }
                try {
                    yield this.getGitDataAndUpload(settings);
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} ${err}\n`);
                    return 1;
                }
            }
            const configGroups = [];
            if (hasSpecifiedRegExPattern) {
                if (hasSpecifiedFunctions) {
                    const usedCommand = this.functions.length !== 0 ? '"--functions"' : 'Functions in config file';
                    this.context.stdout.write(`${chalk_1.red('[Error]')} ${usedCommand} and "--functions-regex" should not be used at the same time.\n`);
                    return 1;
                }
                if (this.regExPattern.match(':')) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} "--functions-regex" isn't meant to be used with ARNs.\n`);
                    return 1;
                }
                const region = this.region || this.config.region;
                if (!region) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} No default region specified. Use \`-r\`, \`--region\`.\n`);
                    return 1;
                }
                try {
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    const lambda = new aws_sdk_1.Lambda({ region });
                    this.context.stdout.write('Fetching Lambda functions, this might take a while.\n');
                    const configs = yield instrument_1.getInstrumentedFunctionConfigsFromRegEx(lambda, cloudWatchLogs, region, this.regExPattern, settings);
                    configGroups.push({ configs, lambda, cloudWatchLogs, region: region });
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                    return 1;
                }
            }
            else {
                let functionGroups;
                try {
                    functionGroups = commons_1.collectFunctionsByRegion(this.functions.length !== 0 ? this.functions : this.config.functions, this.region || this.config.region);
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't group functions. ${err}`);
                    return 1;
                }
                for (const [region, functionList] of Object.entries(functionGroups)) {
                    const lambda = new aws_sdk_1.Lambda({ region });
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    try {
                        const configs = yield instrument_1.getInstrumentedFunctionConfigs(lambda, cloudWatchLogs, region, functionList, settings);
                        configGroups.push({ configs, lambda, cloudWatchLogs, region });
                    }
                    catch (err) {
                        this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                        return 1;
                    }
                }
            }
            const configList = configGroups.map((group) => group.configs).reduce((a, b) => a.concat(b));
            if (!commons_1.checkRuntimeTypesAreUniform(configList)) {
                throw Error('Detected Lambda functions using different runtimes. Please only instrument batches of functions that share a similar runtime');
            }
            this.printPlannedActions(configList);
            if (this.dryRun || configList.length === 0) {
                return 0;
            }
            const willUpdate = commons_1.willUpdateFunctionConfigs(configList);
            if (this.interactive && willUpdate) {
                this.context.stdout.write(`${chalk_1.yellow('[!]')} Confirmation needed.\n`);
                const isConfirmed = yield prompt_1.requestChangesConfirmation('Do you want to apply the changes?');
                if (!isConfirmed) {
                    return 0;
                }
                this.context.stdout.write(`${chalk_1.yellow('[!]')} Instrumenting functions.\n`);
            }
            const promises = Object.values(configGroups).map((group) => commons_1.updateLambdaFunctionConfigs(group.lambda, group.cloudWatchLogs, group.configs));
            try {
                yield Promise.all(promises);
            }
            catch (err) {
                this.context.stdout.write(`${chalk_1.red('[Error]')} Failure during update. ${err}\n`);
                return 1;
            }
            return 0;
        });
    }
    getCurrentGitStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const simpleGit = yield git_1.newSimpleGit();
            const gitCommitInfo = yield git_1.getCommitInfo(simpleGit);
            if (gitCommitInfo === undefined) {
                throw new Error('Git commit info is not defined');
            }
            const status = yield simpleGit.status();
            return { isClean: status.isClean(), ahead: status.ahead, files: status.files, hash: gitCommitInfo === null || gitCommitInfo === void 0 ? void 0 : gitCommitInfo.hash };
        });
    }
    getGitDataAndUpload(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentStatus;
            try {
                currentStatus = yield this.getCurrentGitStatus();
            }
            catch (err) {
                throw Error("Couldn't get local git status");
            }
            if (!currentStatus.isClean) {
                throw Error('Local git repository is dirty');
            }
            if (currentStatus.ahead > 0) {
                throw Error('Local changes have not been pushed remotely. Aborting git upload.');
            }
            const commitSha = currentStatus.hash;
            if (settings.extraTags) {
                settings.extraTags += `,git.commit.sha:${commitSha}`;
            }
            else {
                settings.extraTags = `git.commit.sha:${commitSha}`;
            }
            try {
                yield this.uploadGitData();
            }
            catch (err) {
                throw Error(`Error uploading git data: ${err}\n`);
            }
        });
    }
    getSettings() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const layerVersionStr = (_a = this.layerVersion) !== null && _a !== void 0 ? _a : this.config.layerVersion;
        const extensionVersionStr = (_b = this.extensionVersion) !== null && _b !== void 0 ? _b : this.config.extensionVersion;
        const layerAWSAccount = (_c = this.layerAWSAccount) !== null && _c !== void 0 ? _c : this.config.layerAWSAccount;
        const forwarderARN = (_d = this.forwarder) !== null && _d !== void 0 ? _d : this.config.forwarder;
        let layerVersion;
        if (layerVersionStr !== undefined) {
            layerVersion = parseInt(layerVersionStr, 10);
        }
        if (Number.isNaN(layerVersion)) {
            this.context.stdout.write(`Invalid layer version ${layerVersion}.\n`);
            return;
        }
        let extensionVersion;
        if (extensionVersionStr !== undefined) {
            extensionVersion = parseInt(extensionVersionStr, 10);
        }
        if (Number.isNaN(extensionVersion)) {
            this.context.stdout.write(`Invalid extension version ${extensionVersion}.\n`);
            return;
        }
        const stringBooleansMap = {
            captureLambdaPayload: (_e = this.captureLambdaPayload) !== null && _e !== void 0 ? _e : this.config.captureLambdaPayload,
            flushMetricsToLogs: (_f = this.flushMetricsToLogs) !== null && _f !== void 0 ? _f : this.config.flushMetricsToLogs,
            mergeXrayTraces: (_g = this.mergeXrayTraces) !== null && _g !== void 0 ? _g : this.config.mergeXrayTraces,
            tracing: (_h = this.tracing) !== null && _h !== void 0 ? _h : this.config.tracing,
        };
        for (const [stringBoolean, value] of Object.entries(stringBooleansMap)) {
            if (!['true', 'false', undefined].includes(value === null || value === void 0 ? void 0 : value.toString().toLowerCase())) {
                this.context.stdout.write(`Invalid boolean specified for ${stringBoolean}.\n`);
                return;
            }
        }
        const captureLambdaPayload = commons_1.coerceBoolean(false, this.captureLambdaPayload, this.config.captureLambdaPayload);
        const flushMetricsToLogs = commons_1.coerceBoolean(true, this.flushMetricsToLogs, this.config.flushMetricsToLogs);
        const mergeXrayTraces = commons_1.coerceBoolean(false, this.mergeXrayTraces, this.config.mergeXrayTraces);
        const tracingEnabled = commons_1.coerceBoolean(true, this.tracing, this.config.tracing);
        const interactive = commons_1.coerceBoolean(false, this.interactive, this.config.interactive);
        const logLevel = (_j = this.logLevel) !== null && _j !== void 0 ? _j : this.config.logLevel;
        const service = (_k = this.service) !== null && _k !== void 0 ? _k : this.config.service;
        const environment = (_l = this.environment) !== null && _l !== void 0 ? _l : this.config.environment;
        const version = (_m = this.version) !== null && _m !== void 0 ? _m : this.config.version;
        const tagsMap = {
            environment,
            service,
            version,
        };
        const tagsMissing = [];
        for (const [tag, value] of Object.entries(tagsMap)) {
            if (!value) {
                tagsMissing.push(tag);
            }
        }
        if (tagsMissing.length > 0) {
            const tags = tagsMissing.join(', ').replace(/, ([^,]*)$/, ' and $1');
            const plural = tagsMissing.length > 1;
            this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[Warning]'))} The ${tags} tag${plural ? 's have' : ' has'} not been configured. Learn more about Datadog unified service tagging: ${chalk_1.underline(chalk_1.blueBright('https://docs.datadoghq.com/getting_started/tagging/unified_service_tagging/#serverless-environment.'))}\n`);
        }
        const extraTags = (_p = (_o = this.extraTags) === null || _o === void 0 ? void 0 : _o.toLowerCase()) !== null && _p !== void 0 ? _p : (_q = this.config.extraTags) === null || _q === void 0 ? void 0 : _q.toLowerCase();
        if (extraTags && !commons_1.sentenceMatchesRegEx(extraTags, constants_1.EXTRA_TAGS_REG_EXP)) {
            this.context.stdout.write('Extra tags do not comply with the <key>:<value> array.\n');
            return;
        }
        return {
            captureLambdaPayload,
            environment,
            extensionVersion,
            extraTags,
            flushMetricsToLogs,
            forwarderARN,
            interactive,
            layerAWSAccount,
            layerVersion,
            logLevel,
            mergeXrayTraces,
            service,
            tracingEnabled,
            version,
        };
    }
    printPlannedActions(configs) {
        const prefix = this.dryRun ? chalk_1.bold(chalk_1.cyan('[Dry Run] ')) : '';
        const willUpdate = commons_1.willUpdateFunctionConfigs(configs);
        if (!willUpdate) {
            this.context.stdout.write(`\n${prefix}No updates will be applied\n`);
            return;
        }
        this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[Warning]'))} Instrument your ${chalk_1.hex('#FF9900').bold('Lambda')} functions in a dev or staging environment first. Should the instrumentation result be unsatisfactory, run \`${chalk_1.bold('uninstrument')}\` with the same arguments to revert the changes.\n`);
        this.context.stdout.write(`\n${chalk_1.bold(chalk_1.yellow('[!]'))} Functions to be updated:\n`);
        for (const config of configs) {
            this.context.stdout.write(`\t- ${chalk_1.bold(config.functionARN)}\n`);
            // Later, we should inform which layer is the latest.
            if (this.interactive) {
                if (!this.extensionVersion || !this.extensionVersion) {
                    this.context.stdout.write(`\t${chalk_1.bold(chalk_1.yellow('[Warning]'))} At least one latest layer version is being used. Ensure to lock in versions for production applications using \`--layerVersion\` and \`--extensionVersion\`.\n`);
                }
            }
        }
        this.context.stdout.write(`\n${prefix}Will apply the following updates:\n`);
        for (const config of configs) {
            if (config.updateRequest) {
                this.context.stdout.write(`UpdateFunctionConfiguration -> ${config.functionARN}\n${JSON.stringify(config.updateRequest, undefined, 2)}\n`);
            }
            const { logGroupConfiguration, tagConfiguration } = config;
            if (tagConfiguration === null || tagConfiguration === void 0 ? void 0 : tagConfiguration.tagResourceRequest) {
                this.context.stdout.write(`TagResource -> ${tagConfiguration.tagResourceRequest.Resource}\n${JSON.stringify(tagConfiguration.tagResourceRequest.Tags, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.createLogGroupRequest) {
                this.context.stdout.write(`CreateLogGroup -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.createLogGroupRequest, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.deleteSubscriptionFilterRequest) {
                this.context.stdout.write(`DeleteSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.deleteSubscriptionFilterRequest, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.subscriptionFilterRequest) {
                this.context.stdout.write(`PutSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.subscriptionFilterRequest, undefined, 2)}\n`);
            }
        }
    }
    setEnvServiceVersion() {
        this.environment = process.env[constants_1.ENVIRONMENT_ENV_VAR] || undefined;
        this.service = process.env[constants_1.SERVICE_ENV_VAR] || undefined;
        this.version = process.env[constants_1.VERSION_ENV_VAR] || undefined;
    }
    uploadGitData() {
        return __awaiter(this, void 0, void 0, function* () {
            const cli = new clipanion_1.Cli();
            cli.register(upload_1.UploadCommand);
            if ((yield cli.run(['git-metadata', 'upload'], this.context)) !== 0) {
                throw Error("Couldn't upload git metadata");
            }
            return;
        });
    }
}
exports.InstrumentCommand = InstrumentCommand;
InstrumentCommand.addPath('lambda', 'instrument');
InstrumentCommand.addOption('functions', clipanion_1.Command.Array('-f,--function'));
InstrumentCommand.addOption('regExPattern', clipanion_1.Command.String('--functions-regex,--functionsRegex'));
InstrumentCommand.addOption('region', clipanion_1.Command.String('-r,--region'));
InstrumentCommand.addOption('extensionVersion', clipanion_1.Command.String('-e,--extension-version,--extensionVersion'));
InstrumentCommand.addOption('layerVersion', clipanion_1.Command.String('-v,--layer-version,--layerVersion'));
InstrumentCommand.addOption('layerAWSAccount', clipanion_1.Command.String('-a,--layer-account,--layerAccount', { hidden: true }));
InstrumentCommand.addOption('tracing', clipanion_1.Command.String('--tracing'));
InstrumentCommand.addOption('mergeXrayTraces', clipanion_1.Command.String('--merge-xray-traces,--mergeXrayTraces'));
InstrumentCommand.addOption('flushMetricsToLogs', clipanion_1.Command.String('--flush-metrics-to-logs,--flushMetricsToLogs'));
InstrumentCommand.addOption('dryRun', clipanion_1.Command.Boolean('-d,--dry'));
InstrumentCommand.addOption('configPath', clipanion_1.Command.String('--config'));
InstrumentCommand.addOption('forwarder', clipanion_1.Command.String('--forwarder'));
InstrumentCommand.addOption('logLevel', clipanion_1.Command.String('--log-level,--logLevel'));
InstrumentCommand.addOption('service', clipanion_1.Command.String('--service'));
InstrumentCommand.addOption('environment', clipanion_1.Command.String('--env'));
InstrumentCommand.addOption('version', clipanion_1.Command.String('--version'));
InstrumentCommand.addOption('extraTags', clipanion_1.Command.String('--extra-tags,--extraTags'));
InstrumentCommand.addOption('sourceCodeIntegration', clipanion_1.Command.Boolean('-s,--source-code-integration,--sourceCodeIntegration'));
InstrumentCommand.addOption('interactive', clipanion_1.Command.Boolean('-i,--interactive'));
InstrumentCommand.addOption('captureLambdaPayload', clipanion_1.Command.String('--capture-lambda-payload,--captureLambdaPayload'));
//# sourceMappingURL=instrument.js.map