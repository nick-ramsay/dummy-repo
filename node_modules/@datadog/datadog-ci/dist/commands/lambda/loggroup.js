"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubscriptionFilters = exports.getSubscriptionFilterState = exports.hasLogGroup = exports.calculateLogGroupRemoveRequest = exports.calculateLogGroupUpdateRequest = exports.applyLogGroupConfig = exports.SubscriptionState = void 0;
const constants_1 = require("./constants");
var SubscriptionState;
(function (SubscriptionState) {
    SubscriptionState[SubscriptionState["Empty"] = 0] = "Empty";
    SubscriptionState[SubscriptionState["CorrectDestination"] = 1] = "CorrectDestination";
    SubscriptionState[SubscriptionState["WrongDestinationOwned"] = 2] = "WrongDestinationOwned";
    SubscriptionState[SubscriptionState["WrongDestinationUnowned"] = 3] = "WrongDestinationUnowned";
})(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));
const applyLogGroupConfig = (logs, config) => __awaiter(void 0, void 0, void 0, function* () {
    const { createLogGroupRequest, deleteSubscriptionFilterRequest, subscriptionFilterRequest } = config;
    if (createLogGroupRequest !== undefined) {
        yield logs.createLogGroup(createLogGroupRequest).promise();
    }
    if (deleteSubscriptionFilterRequest !== undefined) {
        yield logs.deleteSubscriptionFilter(deleteSubscriptionFilterRequest).promise();
    }
    if (subscriptionFilterRequest !== undefined) {
        yield logs.putSubscriptionFilter(subscriptionFilterRequest).promise();
    }
});
exports.applyLogGroupConfig = applyLogGroupConfig;
const calculateLogGroupUpdateRequest = (logs, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
        subscriptionFilterRequest: {
            destinationArn: forwarderARN,
            filterName: constants_1.SUBSCRIPTION_FILTER_NAME,
            filterPattern: '',
            logGroupName,
        },
    };
    const logGroupPresent = yield exports.hasLogGroup(logs, logGroupName);
    let subscriptionState = SubscriptionState.Empty;
    if (logGroupPresent) {
        subscriptionState = yield exports.getSubscriptionFilterState(logs, logGroupName, forwarderARN);
    }
    else {
        config.createLogGroupRequest = {
            logGroupName,
        };
    }
    if (subscriptionState === SubscriptionState.CorrectDestination) {
        // All up to date, nothing to be done
        return;
    }
    if (subscriptionState === SubscriptionState.WrongDestinationUnowned) {
        // Can't update, don't own the subscription
        throw Error(`Unknown subscription filter already on log group ${logGroupName}. Only one subscription is allowed.`);
    }
    return config;
});
exports.calculateLogGroupUpdateRequest = calculateLogGroupUpdateRequest;
const calculateLogGroupRemoveRequest = (logs, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const config = {
        logGroupName,
    };
    const subscriptionFilters = yield exports.getSubscriptionFilters(logs, logGroupName);
    const subscriptionToRemove = subscriptionFilters === null || subscriptionFilters === void 0 ? void 0 : subscriptionFilters.find((subscription) => subscription.destinationArn === forwarderARN || subscription.filterName === constants_1.SUBSCRIPTION_FILTER_NAME);
    if (subscriptionToRemove) {
        config.deleteSubscriptionFilterRequest = {
            filterName: subscriptionToRemove.filterName,
            logGroupName,
        };
    }
    return config;
});
exports.calculateLogGroupRemoveRequest = calculateLogGroupRemoveRequest;
const hasLogGroup = (logs, logGroupName) => __awaiter(void 0, void 0, void 0, function* () {
    const args = {
        logGroupNamePrefix: logGroupName,
    };
    const result = yield logs.describeLogGroups(args).promise();
    const { logGroups } = result;
    if (logGroups === undefined || logGroups.length === 0) {
        return false;
    }
    return logGroups.find((lg) => lg.logGroupName === logGroupName) !== undefined;
});
exports.hasLogGroup = hasLogGroup;
const getSubscriptionFilterState = (logs, logGroupName, forwarderARN) => __awaiter(void 0, void 0, void 0, function* () {
    const subscriptionFilters = yield exports.getSubscriptionFilters(logs, logGroupName);
    if (subscriptionFilters === undefined || subscriptionFilters.length === 0) {
        return SubscriptionState.Empty;
    }
    if (subscriptionFilters.find((sf) => sf.destinationArn === forwarderARN) !== undefined) {
        return SubscriptionState.CorrectDestination;
    }
    if (subscriptionFilters.find((sf) => sf.filterName === constants_1.SUBSCRIPTION_FILTER_NAME)) {
        // Subscription filter was created by this CI tool
        return SubscriptionState.WrongDestinationOwned;
    }
    return SubscriptionState.WrongDestinationUnowned;
});
exports.getSubscriptionFilterState = getSubscriptionFilterState;
const getSubscriptionFilters = (logs, logGroupName) => __awaiter(void 0, void 0, void 0, function* () {
    const subscriptionFiltersRequest = {
        logGroupName,
    };
    const { subscriptionFilters } = yield logs.describeSubscriptionFilters(subscriptionFiltersRequest).promise();
    return subscriptionFilters;
});
exports.getSubscriptionFilters = getSubscriptionFilters;
//# sourceMappingURL=loggroup.js.map