"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UninstrumentCommand = void 0;
const aws_sdk_1 = require("aws-sdk");
const chalk_1 = require("chalk");
const clipanion_1 = require("clipanion");
const utils_1 = require("../../helpers/utils");
const constants_1 = require("./constants");
const commons_1 = require("./functions/commons");
const uninstrument_1 = require("./functions/uninstrument");
const prompt_1 = require("./prompt");
class UninstrumentCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = {
            functions: [],
            region: process.env[constants_1.AWS_DEFAULT_REGION_ENV_VAR],
        };
        this.dryRun = false;
        this.functions = [];
        this.interactive = false;
    }
    execute() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const lambdaConfig = { lambda: this.config };
            this.config = (yield utils_1.parseConfigFile(lambdaConfig, this.configPath)).lambda;
            let hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            if (this.interactive) {
                try {
                    if (commons_1.isMissingAWSCredentials()) {
                        this.context.stdout.write(`${chalk_1.bold(chalk_1.yellow('[!]'))} No AWS credentials found, let's set them up! Or you can re-run the command and supply the AWS credentials in the same way when you invoke the AWS CLI.\n`);
                        yield prompt_1.requestAWSCredentials();
                    }
                }
                catch (e) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} ${e}\n`);
                    return 1;
                }
                const region = (_b = (_a = this.region) !== null && _a !== void 0 ? _a : this.config.region) !== null && _b !== void 0 ? _b : process.env[constants_1.AWS_DEFAULT_REGION_ENV_VAR];
                this.region = region;
                if (!hasSpecifiedFunctions) {
                    try {
                        const lambda = new aws_sdk_1.Lambda({ region });
                        this.context.stdout.write('Fetching Lambda functions, this might take a while.\n');
                        const functionNames = (_c = (yield commons_1.getAllLambdaFunctionConfigs(lambda)).map((config) => config.FunctionName).sort()) !== null && _c !== void 0 ? _c : [];
                        if (functionNames.length === 0) {
                            this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't find any Lambda functions in the specified region.\n`);
                            return 1;
                        }
                        const functions = yield prompt_1.requestFunctionSelection(functionNames);
                        this.functions = functions;
                    }
                    catch (err) {
                        this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                        return 1;
                    }
                }
            }
            hasSpecifiedFunctions = this.functions.length !== 0 || this.config.functions.length !== 0;
            const hasSpecifiedRegExPattern = this.regExPattern !== undefined && this.regExPattern !== '';
            if (!hasSpecifiedFunctions && !hasSpecifiedRegExPattern) {
                this.context.stdout.write(`${chalk_1.red('[Error]')} No functions specified for un-instrumentation.\n`);
                return 1;
            }
            const configGroups = [];
            // Fetch lambda function configurations that are
            // available to be un-instrumented.
            if (hasSpecifiedRegExPattern) {
                if (hasSpecifiedFunctions) {
                    const usedCommand = this.functions.length !== 0 ? '"--functions"' : 'Functions in config file';
                    this.context.stdout.write(`${chalk_1.red('[Error]')} ${usedCommand} and "--functions-regex" should not be used at the same time.\n`);
                    return 1;
                }
                if (this.regExPattern.match(':')) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} "--functions-regex" isn't meant to be used with ARNs.\n`);
                    return 1;
                }
                const region = this.region || this.config.region;
                if (!region) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} No default region specified. Use \`-r\`, \`--region\`.`);
                    return 1;
                }
                try {
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    const lambda = new aws_sdk_1.Lambda({ region });
                    this.context.stdout.write('Fetching Lambda functions, this might take a while.\n');
                    const configs = yield uninstrument_1.getUninstrumentedFunctionConfigsFromRegEx(lambda, cloudWatchLogs, this.regExPattern, this.forwarder);
                    configGroups.push({ configs, lambda, cloudWatchLogs });
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                    return 1;
                }
            }
            else {
                let functionGroups;
                try {
                    functionGroups = commons_1.collectFunctionsByRegion(this.functions.length !== 0 ? this.functions : this.config.functions, this.region || this.config.region);
                }
                catch (err) {
                    this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't group functions. ${err}`);
                    return 1;
                }
                for (const [region, functionARNs] of Object.entries(functionGroups)) {
                    const lambda = new aws_sdk_1.Lambda({ region });
                    const cloudWatchLogs = new aws_sdk_1.CloudWatchLogs({ region });
                    try {
                        const configs = yield uninstrument_1.getUninstrumentedFunctionConfigs(lambda, cloudWatchLogs, functionARNs, this.forwarder);
                        configGroups.push({ configs, lambda, cloudWatchLogs });
                    }
                    catch (err) {
                        this.context.stdout.write(`${chalk_1.red('[Error]')} Couldn't fetch Lambda functions. ${err}\n`);
                        return 1;
                    }
                }
            }
            const configList = configGroups.map((group) => group.configs).reduce((a, b) => a.concat(b));
            this.printPlannedActions(configList);
            if (this.dryRun || configList.length === 0) {
                return 0;
            }
            const willUpdate = commons_1.willUpdateFunctionConfigs(configList);
            if (this.interactive && willUpdate) {
                this.context.stdout.write(`${chalk_1.yellow('[!]')} Confirmation needed.\n`);
                const isConfirmed = yield prompt_1.requestChangesConfirmation('Do you want to apply the changes?');
                if (!isConfirmed) {
                    return 0;
                }
                this.context.stdout.write(`${chalk_1.yellow('[!]')} Uninstrumenting functions.\n`);
            }
            // Un-instrument functions.
            const promises = Object.values(configGroups).map((group) => {
                commons_1.updateLambdaFunctionConfigs(group.lambda, group.cloudWatchLogs, group.configs);
            });
            try {
                yield Promise.all(promises);
            }
            catch (err) {
                this.context.stdout.write(`${chalk_1.red('[Error]')} Failure during un-instrumentation. ${err}`);
                return 1;
            }
            return 0;
        });
    }
    printPlannedActions(configs) {
        const prefix = this.dryRun ? chalk_1.bold(chalk_1.cyan('[Dry Run] ')) : '';
        const willUpdate = commons_1.willUpdateFunctionConfigs(configs);
        if (!willUpdate) {
            this.context.stdout.write(`${prefix}No updates will be applied\n`);
            return;
        }
        this.context.stdout.write(`\n${chalk_1.bold(chalk_1.yellow('[!]'))} Functions to be updated:\n`);
        for (const config of configs) {
            this.context.stdout.write(`\t- ${chalk_1.bold(config.functionARN)}\n`);
        }
        this.context.stdout.write(`\n${prefix}Will apply the following updates:\n`);
        for (const config of configs) {
            if (config.updateRequest) {
                this.context.stdout.write(`UpdateFunctionConfiguration -> ${config.functionARN}\n${JSON.stringify(config.updateRequest, undefined, 2)}\n`);
            }
            const { logGroupConfiguration, tagConfiguration } = config;
            if (tagConfiguration === null || tagConfiguration === void 0 ? void 0 : tagConfiguration.untagResourceRequest) {
                this.context.stdout.write(`UntagResource -> ${tagConfiguration.untagResourceRequest.Resource}\n${JSON.stringify(tagConfiguration.untagResourceRequest.TagKeys, undefined, 2)}\n`);
            }
            if (logGroupConfiguration === null || logGroupConfiguration === void 0 ? void 0 : logGroupConfiguration.deleteSubscriptionFilterRequest) {
                this.context.stdout.write(`DeleteSubscriptionFilter -> ${logGroupConfiguration.logGroupName}\n${JSON.stringify(logGroupConfiguration.deleteSubscriptionFilterRequest, undefined, 2)}\n`);
            }
        }
    }
}
exports.UninstrumentCommand = UninstrumentCommand;
UninstrumentCommand.addPath('lambda', 'uninstrument');
UninstrumentCommand.addOption('functions', clipanion_1.Command.Array('-f,--function'));
UninstrumentCommand.addOption('region', clipanion_1.Command.String('-r,--region'));
UninstrumentCommand.addOption('configPath', clipanion_1.Command.String('--config'));
UninstrumentCommand.addOption('dryRun', clipanion_1.Command.Boolean('-d,--dry'));
UninstrumentCommand.addOption('forwarder', clipanion_1.Command.String('--forwarder'));
UninstrumentCommand.addOption('regExPattern', clipanion_1.Command.String('--functions-regex,--functionsRegex'));
UninstrumentCommand.addOption('interactive', clipanion_1.Command.Boolean('-i,--interactive'));
/**
 * Commands that are not really in use, but to
 * make uninstrumentation easier for the user.
 */
UninstrumentCommand.addOption('extensionVersion', clipanion_1.Command.String('-e,--extension-version,--extensionVersion', { hidden: true }));
UninstrumentCommand.addOption('layerVersion', clipanion_1.Command.String('-v,--layer-version,--layerVersion', { hidden: true }));
UninstrumentCommand.addOption('tracing', clipanion_1.Command.String('--tracing', { hidden: true }));
UninstrumentCommand.addOption('mergeXrayTraces', clipanion_1.Command.String('--merge-xray-traces,--mergeXrayTraces', { hidden: true }));
UninstrumentCommand.addOption('flushMetricsToLogs', clipanion_1.Command.String('--flush-metrics-to-logs,--flushMetricsToLogs', { hidden: true }));
UninstrumentCommand.addOption('logLevel', clipanion_1.Command.String('--log-level,--logLevel', { hidden: true }));
UninstrumentCommand.addOption('service', clipanion_1.Command.String('--service', { hidden: true }));
UninstrumentCommand.addOption('environment', clipanion_1.Command.String('--env', { hidden: true }));
UninstrumentCommand.addOption('version', clipanion_1.Command.String('--version', { hidden: true }));
UninstrumentCommand.addOption('extraTags', clipanion_1.Command.String('--extra-tags,--extraTags', { hidden: true }));
UninstrumentCommand.addOption('captureLambdaPayload', clipanion_1.Command.String('--capture-lambda-payload,--captureLambdaPayload', { hidden: true }));
//# sourceMappingURL=uninstrument.js.map