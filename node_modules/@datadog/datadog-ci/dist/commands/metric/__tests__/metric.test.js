"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const advanced_1 = require("clipanion/lib/advanced");
const metric_1 = require("../metric");
const makeCLI = () => {
    const cli = new advanced_1.Cli();
    cli.register(metric_1.MetricCommand);
    return cli;
};
const createMockContext = () => {
    let out = '';
    let err = '';
    return {
        stderr: {
            toString: () => err,
            write: (input) => {
                err += input;
            },
        },
        stdout: {
            toString: () => out,
            write: (input) => {
                out += input;
            },
        },
    };
};
describe('parse metrics', () => {
    test('should fail if metrics key value pair does not contain a :', () => {
        expect(() => {
            metric_1.parseMetrics(['notkeyvalue', 'key:1']);
        }).toThrow('invalid metrics key value pair "notkeyvalue"');
    });
    test('should fail if metrics key value pair is not numeric', () => {
        expect(() => {
            metric_1.parseMetrics(['key:notanumber', 'key1:55']);
        }).toThrow('value is not numeric');
    });
    test('should work for all valid number types', () => {
        expect(metric_1.parseMetrics(['int:1', 'float:1.1', 'negativeint:-1', 'negativefloat:-0.7391'])).toStrictEqual({
            float: 1.1,
            int: 1,
            negativefloat: -0.7391,
            negativeint: -1,
        });
    });
});
describe('execute', () => {
    const runCLI = (level, metrics, env) => __awaiter(void 0, void 0, void 0, function* () {
        const cli = makeCLI();
        const context = createMockContext();
        process.env = Object.assign({ DATADOG_API_KEY: 'PLACEHOLDER' }, env);
        const metricsList = [];
        metrics.forEach((t) => {
            metricsList.push('--metrics');
            metricsList.push(t);
        });
        const code = yield cli.run(['metric', '--level', level, ...metricsList], context);
        return { context, code };
    });
    test('should fail if an invalid level given', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('stage', ['key:1'], { BUILDKITE: 'true', BUILDKITE_BUILD_ID: 'id' });
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Level must be one of [pipeline, job]');
    }));
    test('should fail if no metrics provided', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('pipeline', [], { BUILDKITE: 'true', BUILDKITE_BUILD_ID: 'id' });
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('--metrics is required');
    }));
    test('should fail if not running in a supported provider', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('pipeline', ['key:1'], {});
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Only providers [GitHub, GitLab, CircleCI, Buildkite] are supported');
    }));
    test('should fail if provider is GitHub and level is job', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('job', ['key:1'], { GITHUB_ACTIONS: 'true', GITHUB_RUN_ID: '40' });
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Cannot use level "job" for GitHub Actions.');
    }));
});
//# sourceMappingURL=metric.test.js.map