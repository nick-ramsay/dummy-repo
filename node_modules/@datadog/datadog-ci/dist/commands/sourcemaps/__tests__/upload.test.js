"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable: no-string-literal
const os_1 = __importDefault(require("os"));
const chalk_1 = __importDefault(require("chalk"));
const advanced_1 = require("clipanion/lib/advanced");
const interfaces_1 = require("../interfaces");
const upload_1 = require("../upload");
describe('upload', () => {
    describe('getMinifiedURL', () => {
        test('should return correct URL', () => {
            const command = new upload_1.UploadCommand();
            command['basePath'] = '/js/sourcemaps';
            command['minifiedPathPrefix'] = 'http://datadog.com/js';
            expect(command['getMinifiedURL']('/js/sourcemaps/common.min.js.map')).toBe('http://datadog.com/js/common.min.js.map');
        });
    });
    describe('getMinifiedURL: minifiedPathPrefix has the protocol omitted', () => {
        test('should return correct URL', () => {
            const command = new upload_1.UploadCommand();
            command['basePath'] = '/js/sourcemaps';
            command['minifiedPathPrefix'] = '//datadog.com/js';
            expect(command['getMinifiedURL']('/js/sourcemaps/common.min.js.map')).toBe('//datadog.com/js/common.min.js.map');
        });
    });
    describe('getMinifiedURL: minifiedPathPrefix is an absolute path', () => {
        test('should return correct URL', () => {
            const command = new upload_1.UploadCommand();
            command['basePath'] = '/js/sourcemaps';
            command['minifiedPathPrefix'] = '/js';
            expect(command['getMinifiedURL']('/js/sourcemaps/common.min.js.map')).toBe('/js/common.min.js.map');
        });
    });
    describe('isMinifiedPathPrefixValid: full URL', () => {
        test('should return false', () => {
            const command = new upload_1.UploadCommand();
            command['minifiedPathPrefix'] = 'http://datadog.com/js';
            expect(command['isMinifiedPathPrefixValid']()).toBe(true);
        });
    });
    describe('isMinifiedPathPrefixValid: URL without protocol', () => {
        test('should return false', () => {
            const command = new upload_1.UploadCommand();
            command['minifiedPathPrefix'] = '//datadog.com/js';
            expect(command['isMinifiedPathPrefixValid']()).toBe(true);
        });
    });
    describe('isMinifiedPathPrefixValid: leading slash', () => {
        test('should return false', () => {
            const command = new upload_1.UploadCommand();
            command['minifiedPathPrefix'] = '/js';
            expect(command['isMinifiedPathPrefixValid']()).toBe(true);
        });
    });
    describe('isMinifiedPathPrefixValid: no leading slash', () => {
        test('should return false', () => {
            const command = new upload_1.UploadCommand();
            command['minifiedPathPrefix'] = 'js';
            expect(command['isMinifiedPathPrefixValid']()).toBe(false);
        });
    });
    describe('getApiHelper', () => {
        test('should throw an error if API key is undefined', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = {};
            const command = new upload_1.UploadCommand();
            expect(command['getRequestBuilder'].bind(command)).toThrow(`Missing ${chalk_1.default.bold('DATADOG_API_KEY')} in your environment.`);
        }));
    });
    describe('addRepositoryDataToPayloads', () => {
        test('repository url and commit still defined without payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const command = new upload_1.UploadCommand();
            const write = jest.fn();
            command.context = { stdout: { write } };
            const sourcemaps = new Array(new interfaces_1.Sourcemap('src/commands/sourcemaps/__tests__/fixtures/sourcemap-with-no-files/empty.min.js', 'http://example/empty.min.js', 'src/commands/sourcemaps/__tests__/fixtures/sourcemap-with-no-files/empty.min.js.map'));
            // The command will fetch git metadatas for the current datadog-ci repository.
            // The `empty.min.js.map` contains no files, therefore no file payload should be set.
            yield command['addRepositoryDataToPayloads'](sourcemaps);
            expect(sourcemaps[0].gitData).toBeDefined();
            expect(sourcemaps[0].gitData.gitRepositoryURL).toBeDefined();
            expect(sourcemaps[0].gitData.gitCommitSha).toHaveLength(40);
            expect(sourcemaps[0].gitData.gitRepositoryPayload).toBeUndefined();
        }));
        test('should include payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const command = new upload_1.UploadCommand();
            const write = jest.fn();
            command.context = { stdout: { write } };
            const sourcemaps = new Array(new interfaces_1.Sourcemap('src/commands/sourcemaps/__tests__/fixtures/basic/common.min.js', 'http://example/common.min.js', 'src/commands/sourcemaps/__tests__/fixtures/basic/common.min.js.map'));
            // The command will fetch git metadatas for the current datadog-ci repository.
            // The `common.min.js.map` contains the "git.test.ts" filename which matches a tracked filename,
            // therefore a file payload should be set.
            // Removing the "git.test.ts" file will break this test.
            yield command['addRepositoryDataToPayloads'](sourcemaps);
            expect(sourcemaps[0].gitData).toBeDefined();
            expect(sourcemaps[0].gitData.gitRepositoryURL).toBeDefined();
            expect(sourcemaps[0].gitData.gitCommitSha).toHaveLength(40);
            expect(sourcemaps[0].gitData.gitRepositoryPayload).toBeDefined();
        }));
    });
});
describe('execute', () => {
    const runCLI = (path) => __awaiter(void 0, void 0, void 0, function* () {
        const cli = makeCli();
        const context = createMockContext();
        process.env = { DATADOG_API_KEY: 'PLACEHOLDER' };
        const code = yield cli.run([
            'sourcemaps',
            'upload',
            path,
            '--release-version',
            '1234',
            '--service',
            'test-service',
            '--minified-path-prefix',
            'https://static.com/js',
            '--dry-run',
        ], context);
        return { context, code };
    });
    test('relative path with double dots', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/doesnotexist/../fixtures/basic');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        checkConsoleOutput(output, {
            basePath: 'src/commands/sourcemaps/__tests__/fixtures/basic',
            concurrency: 20,
            jsFilesURLs: ['https://static.com/js/common.min.js'],
            minifiedPathPrefix: 'https://static.com/js',
            projectPath: '',
            service: 'test-service',
            sourcemapsPaths: ['src/commands/sourcemaps/__tests__/fixtures/basic/common.min.js.map'],
            version: '1234',
        });
    }));
    test('relative path', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/fixtures/basic');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        checkConsoleOutput(output, {
            basePath: 'src/commands/sourcemaps/__tests__/fixtures/basic',
            concurrency: 20,
            jsFilesURLs: ['https://static.com/js/common.min.js'],
            minifiedPathPrefix: 'https://static.com/js',
            projectPath: '',
            service: 'test-service',
            sourcemapsPaths: ['src/commands/sourcemaps/__tests__/fixtures/basic/common.min.js.map'],
            version: '1234',
        });
    }));
    test('absolute path', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI(process.cwd() + '/src/commands/sourcemaps/__tests__/fixtures/basic');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        checkConsoleOutput(output, {
            basePath: `${process.cwd()}/src/commands/sourcemaps/__tests__/fixtures/basic`,
            concurrency: 20,
            jsFilesURLs: ['https://static.com/js/common.min.js'],
            minifiedPathPrefix: 'https://static.com/js',
            projectPath: '',
            service: 'test-service',
            sourcemapsPaths: [`${process.cwd()}/src/commands/sourcemaps/__tests__/fixtures/basic/common.min.js.map`],
            version: '1234',
        });
    }));
    test('using the mjs extension', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/mjs');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        checkConsoleOutput(output, {
            basePath: 'src/commands/sourcemaps/__tests__/mjs',
            concurrency: 20,
            jsFilesURLs: ['https://static.com/js/common.mjs'],
            minifiedPathPrefix: 'https://static.com/js',
            projectPath: '',
            service: 'test-service',
            sourcemapsPaths: ['src/commands/sourcemaps/__tests__/mjs/common.mjs.map'],
            version: '1234',
        });
    }));
    test('all files are skipped', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/fixtures/stdout-output/all-skipped');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        output.reverse();
        expect(output[3]).toContain('Some sourcemaps have been skipped');
        expect(output[2]).toContain('Details about the 2 found sourcemaps:');
        expect(output[1]).toContain('  * 2 sourcemaps were skipped');
    }));
    test('mix of skipped filed and correct files', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/fixtures/stdout-output/mixed');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        output.reverse();
        expect(output[4]).toContain('Some sourcemaps have been skipped');
        expect(output[3]).toContain('Details about the 3 found sourcemaps:');
        expect(output[2]).toContain('  * 2 sourcemaps successfully uploaded');
        expect(output[1]).toContain('  * 1 sourcemap was skipped');
    }));
    test('completely empty sourcemap should be skipped', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('./src/commands/sourcemaps/__tests__/fixtures/empty-file/');
        const output = context.stdout.toString().split(os_1.default.EOL);
        expect(code).toBe(0);
        output.reverse();
        expect(output[3]).toContain('Some sourcemaps have been skipped');
        expect(output[2]).toContain('Details about the 2 found sourcemaps:');
        expect(output[1]).toContain('  * 2 sourcemaps were skipped');
    }));
});
const makeCli = () => {
    const cli = new advanced_1.Cli();
    cli.register(upload_1.UploadCommand);
    return cli;
};
const createMockContext = () => {
    let data = '';
    return {
        stdout: {
            toString: () => data,
            write: (input) => {
                data += input;
            },
        },
    };
};
const checkConsoleOutput = (output, expected) => {
    expect(output[0]).toContain('DRY-RUN MODE ENABLED. WILL NOT UPLOAD SOURCEMAPS');
    expect(output[1]).toContain(`Starting upload with concurrency ${expected.concurrency}.`);
    expect(output[2]).toContain(`Will look for sourcemaps in ${expected.basePath}`);
    expect(output[3]).toContain(`Will match JS files for errors on files starting with ${expected.minifiedPathPrefix}`);
    expect(output[4]).toContain(`version: ${expected.version} service: ${expected.service} project path: ${expected.projectPath}`);
    const uploadedFileLines = output.slice(5, -4);
    expect(expected.sourcemapsPaths.length).toEqual(uploadedFileLines.length); // Safety check
    expect(expected.jsFilesURLs.length).toEqual(uploadedFileLines.length); // Safety check
    uploadedFileLines.forEach((_, index) => {
        expect(uploadedFileLines[index]).toContain(`[DRYRUN] Uploading sourcemap ${expected.sourcemapsPaths} for JS file available at ${expected.jsFilesURLs}`);
    });
    if (uploadedFileLines.length > 1) {
        expect(output.slice(-2, -1)[0]).toContain(`[DRYRUN] Handled ${uploadedFileLines.length} sourcemaps with success`);
    }
    else {
        expect(output.slice(-2, -1)[0]).toContain(`[DRYRUN] Handled ${uploadedFileLines.length} sourcemap with success`);
    }
};
//# sourceMappingURL=upload.test.js.map