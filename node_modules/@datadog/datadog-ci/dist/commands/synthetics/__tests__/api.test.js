"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const api_1 = require("../api");
const interfaces_1 = require("../interfaces");
const fixtures_1 = require("./fixtures");
describe('dd-api', () => {
    const apiConfiguration = {
        apiKey: '123',
        appKey: '123',
        baseIntakeUrl: 'baseintake',
        baseUrl: 'base',
        proxyOpts: { protocol: 'http' },
    };
    const LOCATION = {
        display_name: 'fake location',
        id: 42,
        is_active: true,
        name: 'fake-loc',
        region: 'fake-region',
    };
    const RESULT_ID = '123';
    const POLL_RESULTS = {
        results: [
            {
                check: fixtures_1.getApiTest('abc-def-ghi'),
                dc_id: 0,
                result: {},
                resultID: RESULT_ID,
                timestamp: 0,
            },
        ],
    };
    const TRIGGERED_TEST_ID = 'fakeId';
    const TRIGGER_RESULTS = {
        locations: [LOCATION],
        results: [
            {
                device: 'laptop_large',
                location: 42,
                public_id: TRIGGERED_TEST_ID,
                result_id: RESULT_ID,
            },
        ],
        triggered_check_ids: [TRIGGERED_TEST_ID],
    };
    const PRESIGNED_URL_PAYLOAD = {
        url: 'wss://presigned.url',
    };
    test('should get results from api', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(axios_1.default, 'create').mockImplementation((() => () => ({ data: POLL_RESULTS })));
        const api = api_1.apiConstructor(apiConfiguration);
        const { pollResults } = api;
        const { results } = yield pollResults([RESULT_ID]);
        expect(results[0].resultID).toBe(RESULT_ID);
    }));
    test('should trigger tests using api', () => __awaiter(void 0, void 0, void 0, function* () {
        jest.spyOn(axios_1.default, 'create').mockImplementation((() => () => ({ data: TRIGGER_RESULTS })));
        const api = api_1.apiConstructor(apiConfiguration);
        const { triggerTests } = api;
        const tests = [{ public_id: TRIGGERED_TEST_ID, executionRule: interfaces_1.ExecutionRule.BLOCKING }];
        const { results, triggered_check_ids } = yield triggerTests({ tests });
        expect(triggered_check_ids).toEqual([TRIGGERED_TEST_ID]);
        expect(results[0].public_id).toBe(TRIGGERED_TEST_ID);
        expect(results[0].result_id).toBe(RESULT_ID);
    }));
    test('should retry request that failed with code 5xx', () => __awaiter(void 0, void 0, void 0, function* () {
        const serverError = new Error('Server Error');
        serverError.response = { status: 502 };
        const requestMock = jest.fn();
        requestMock.mockImplementation(() => {
            throw serverError;
        });
        jest.spyOn(axios_1.default, 'create').mockImplementation((() => requestMock));
        const { getTest } = api_1.apiConstructor(apiConfiguration);
        yield expect(getTest('fake-public-id')).rejects.toThrow();
        expect(requestMock).toHaveBeenCalledTimes(4);
    }));
    test('should get a presigned URL from api', () => __awaiter(void 0, void 0, void 0, function* () {
        const spy = jest.spyOn(axios_1.default, 'create').mockImplementation((() => () => ({ data: PRESIGNED_URL_PAYLOAD })));
        const api = api_1.apiConstructor(apiConfiguration);
        const { getPresignedURL } = api;
        const { url } = yield getPresignedURL([TRIGGERED_TEST_ID]);
        expect(url).toEqual(PRESIGNED_URL_PAYLOAD.url);
        spy.mockRestore();
    }));
    describe('proxy configuration', () => {
        const tests = [{ public_id: '123-456-789', executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }];
        let initialHttpProxyEnv;
        beforeAll(() => {
            initialHttpProxyEnv = process.env.HTTP_PROXY;
        });
        afterAll(() => {
            if (initialHttpProxyEnv !== undefined) {
                process.env.HTTP_PROXY = initialHttpProxyEnv;
            }
            else {
                delete process.env.HTTP_PROXY;
            }
        });
        beforeEach(() => {
            delete process.env.HTTP_PROXY;
        });
        test('use proxy defined in configuration', () => __awaiter(void 0, void 0, void 0, function* () {
            const { close: proxyClose, config: proxyOpts, calls } = fixtures_1.getSyntheticsProxy();
            try {
                const proxyApiConfiguration = Object.assign(Object.assign({}, apiConfiguration), { proxyOpts });
                const api = api_1.apiConstructor(proxyApiConfiguration);
                const searchOutput = yield api.searchTests('tag:test');
                expect(searchOutput).toEqual(fixtures_1.mockSearchResponse);
                expect(calls.search).toHaveBeenCalled();
                const tunnelOutput = yield api.getPresignedURL(['123-456-789']);
                expect(tunnelOutput).toEqual({ url: expect.stringContaining('ws://127.0.0.1:') });
                expect(calls.presignedUrl).toHaveBeenCalled();
                const testOutput = yield api.getTest('123-456-789');
                expect(testOutput).toEqual(fixtures_1.getApiTest('123-456-789'));
                expect(calls.get).toHaveBeenCalled();
                const triggerOutput = yield api.triggerTests({ tests });
                expect(triggerOutput).toEqual(fixtures_1.mockTestTriggerResponse);
                expect(calls.trigger).toHaveBeenCalledWith({ tests });
            }
            finally {
                yield proxyClose();
            }
        }));
        test('use proxy defined in environment variable', () => __awaiter(void 0, void 0, void 0, function* () {
            const { close: proxyClose, config: proxyOpts, calls } = fixtures_1.getSyntheticsProxy();
            process.env.HTTP_PROXY = `http://localhost:${proxyOpts.port}`;
            try {
                const api = api_1.apiConstructor(apiConfiguration);
                const searchOutput = yield api.searchTests('tag:test');
                expect(searchOutput).toEqual(fixtures_1.mockSearchResponse);
                expect(calls.search).toHaveBeenCalled();
                const triggerOutput = yield api.triggerTests({ tests });
                expect(triggerOutput).toEqual(fixtures_1.mockTestTriggerResponse);
                expect(calls.trigger).toHaveBeenCalledWith({ tests });
            }
            finally {
                yield proxyClose();
            }
        }));
        test('use configuration proxy over environment variable', () => __awaiter(void 0, void 0, void 0, function* () {
            const { close: proxyClose, config: proxyOpts, calls } = fixtures_1.getSyntheticsProxy();
            process.env.HTTP_PROXY = 'http://inexistanthost/';
            try {
                const proxyApiConfiguration = Object.assign(Object.assign({}, apiConfiguration), { proxyOpts });
                const api = api_1.apiConstructor(proxyApiConfiguration);
                const triggerOutput = yield api.triggerTests({ tests });
                expect(triggerOutput).toEqual(fixtures_1.mockTestTriggerResponse);
                expect(calls.trigger).toHaveBeenCalledWith({ tests });
            }
            finally {
                yield proxyClose();
            }
        }));
    });
});
//# sourceMappingURL=api.test.js.map