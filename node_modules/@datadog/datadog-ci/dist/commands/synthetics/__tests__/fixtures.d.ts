/// <reference types="jest" />
/// <reference types="node" />
import * as http from 'http';
import { ProxyConfiguration } from '../../../helpers/utils';
import { ApiTestResult, BrowserTestResult, CommandConfig, ConfigOverride, ExecutionRule, Location, MainReporter, MultiStep, MultiStepsTestResult, PollResult, Step, Suite, Summary, Test, Trigger, TriggerResponse } from '../interfaces';
export declare type MockedReporter = {
    [K in keyof MainReporter]: jest.Mock<void, Parameters<MainReporter[K]>>;
};
export declare const mockReporter: MainReporter;
export declare const ciConfig: CommandConfig;
export declare const getApiTest: (publicId: string) => Test;
export declare const getStep: () => Step;
export declare const getMultiStep: () => MultiStep;
export declare const getTestSuite: () => Suite;
export declare const getBrowserPollResult: (resultId: string, resultOpts?: Partial<BrowserTestResult>) => PollResult;
export declare const getApiPollResult: (resultId: string, resultOpts?: Partial<ApiTestResult>) => PollResult;
export declare const getBrowserResult: (opts?: Partial<BrowserTestResult>) => BrowserTestResult;
export declare const getApiResult: (opts?: Partial<ApiTestResult>) => ApiTestResult;
export declare const getMultiStepsResult: () => MultiStepsTestResult;
export declare const getTriggerResult: (publicId: string, resultId: string) => TriggerResponse;
export declare const mockLocation: Location;
export declare const mockSearchResponse: {
    tests: {
        public_id: string;
    }[];
};
export declare const mockTestTriggerResponse: Trigger;
export declare const getSyntheticsProxy: () => {
    calls: {
        get: jest.Mock<any, any>;
        poll: jest.Mock<any, any>;
        presignedUrl: jest.Mock<any, any>;
        search: jest.Mock<any, any>;
        trigger: jest.Mock<any, any>;
        tunnel: jest.Mock<any, any>;
    };
    close: () => Promise<[unknown, unknown]>;
    config: ProxyConfiguration;
    server: http.Server;
};
export interface RenderResultsTestCase {
    description: string;
    expected: {
        exitCode: 0 | 1;
        summary: Summary;
    };
    failOnCriticalErrors: boolean;
    failOnTimeout: boolean;
    fixtures: {
        results: Record<string, PollResult[]>;
        tests: Test[];
        triggers: Trigger;
    };
    summary: Summary;
}
interface RenderResultsTestFixtureConfigs {
    configOverride: ConfigOverride;
    executionRule?: ExecutionRule;
    publicId: string;
    resultError?: string;
    resultIsUnhealthy?: boolean;
    resultPassed: boolean;
}
export declare class RenderResultsHelper {
    private resultIdCounter;
    createFixtures(testFixturesConfigs: RenderResultsTestFixtureConfigs[]): RenderResultsTestCase['fixtures'];
    private combineTestFixtures;
    private getNextTriggerResultAndPolledResults;
    private getTestFixtures;
    private resetResultIdCounter;
}
export {};
