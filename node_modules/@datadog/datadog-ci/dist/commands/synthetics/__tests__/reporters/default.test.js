"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const deep_extend_1 = __importDefault(require("deep-extend"));
const interfaces_1 = require("../../interfaces");
const default_1 = require("../../reporters/default");
const utils_1 = require("../../utils");
const fixtures_1 = require("../fixtures");
/**
 * A good amount of these tests rely on Jest snapshot assertions.
 * If you make some changes in the output of the default repoter, chances are you
 * will also have to update the snapshots from `./__snapshots__/default.test.ts.snap`.
 * To do that, you can run the following command: `yarn test --updateSnapshot reporters/default.test.ts`.
 * More information on https://jestjs.io/docs/snapshot-testing.
 */
describe('Default reporter', () => {
    const writeMock = jest.fn();
    const mockContext = {
        context: {
            stdout: {
                write: writeMock,
            },
        },
    };
    const reporter = new default_1.DefaultReporter(mockContext);
    it('should log for each hook', () => {
        // `testWait`/`testResult` is skipped as nothing is logged for the default reporter.
        const calls = [
            ['error', ['error']],
            ['initErrors', [['error']]],
            ['log', ['log']],
            ['reportStart', [{ startTime: 0 }]],
            ['runEnd', [utils_1.createSummary()]],
            ['testEnd', [{ options: {} }, [], '', []]],
            ['testTrigger', [{}, '', '', {}]],
            ['testsWait', [[{}]]],
        ];
        for (const [fnName, args] of calls) {
            reporter[fnName](...args);
            expect(writeMock).toHaveBeenCalledTimes(1);
            writeMock.mockClear();
        }
    });
    describe('testTrigger', () => {
        beforeEach(() => {
            writeMock.mockClear();
        });
        const testObject = {
            name: 'Request on example.org',
        };
        const testId = 'aaa-bbb-ccc';
        const cases = [
            ['Blocking test, without config overwrite', interfaces_1.ExecutionRule.BLOCKING, {}],
            ['Blocking test, with 1 config override', interfaces_1.ExecutionRule.BLOCKING, { startUrl: 'foo' }],
            ['Blocking test, with 2 config overrides', interfaces_1.ExecutionRule.BLOCKING, { startUrl: 'foo', body: 'hello' }],
            ['Non-blocking test from Datadog, without config overwrite', interfaces_1.ExecutionRule.NON_BLOCKING, {}],
            ['Non-blocking test from Datadog, with 1 config override', interfaces_1.ExecutionRule.NON_BLOCKING, { startUrl: 'foo' }],
            [
                'Non-blocking test from Datadog, with 2 config overrides',
                interfaces_1.ExecutionRule.NON_BLOCKING,
                { startUrl: 'foo', body: 'hello' },
            ],
            [
                'Non-blocking test, with 1 config override',
                interfaces_1.ExecutionRule.NON_BLOCKING,
                { executionRule: interfaces_1.ExecutionRule.NON_BLOCKING },
            ],
            [
                'Non-blocking test, with 2 config overrides',
                interfaces_1.ExecutionRule.NON_BLOCKING,
                { startUrl: 'foo', executionRule: interfaces_1.ExecutionRule.NON_BLOCKING },
            ],
            ['Skipped test, with 1 config override', interfaces_1.ExecutionRule.SKIPPED, { executionRule: interfaces_1.ExecutionRule.SKIPPED }],
            [
                'Skipped test, with 2 config overrides',
                interfaces_1.ExecutionRule.SKIPPED,
                { startUrl: 'foo', executionRule: interfaces_1.ExecutionRule.SKIPPED },
            ],
            ['Skipped test from Datadog, without config overwrite', interfaces_1.ExecutionRule.SKIPPED, {}],
            ['Skipped test from Datadog, with 1 config override', interfaces_1.ExecutionRule.SKIPPED, { startUrl: 'foo' }],
            ['Skipped test from Datadog, with 2 config overrides', interfaces_1.ExecutionRule.SKIPPED, { startUrl: 'foo', body: 'hello' }],
        ];
        test.each(cases)('%s', (title, executionRule, config) => {
            reporter.testTrigger(testObject, testId, executionRule, config);
            const mostRecentOutput = writeMock.mock.calls[writeMock.mock.calls.length - 1][0];
            expect(mostRecentOutput).toMatchSnapshot();
        });
    });
    describe('testEnd', () => {
        beforeEach(() => {
            writeMock.mockClear();
        });
        const createApiPollResult = (resultId, passed, executionRule = interfaces_1.ExecutionRule.BLOCKING) => {
            const errorMessage = JSON.stringify([
                {
                    actual: 1234,
                    operator: 'lessThan',
                    target: 1000,
                    type: 'responseTime',
                },
            ]);
            const failure = { code: 'INCORRECT_ASSERTION', message: errorMessage };
            return deep_extend_1.default(fixtures_1.getApiPollResult(resultId), {
                enrichment: { config_override: { executionRule } },
                result: Object.assign({ passed }, (!passed ? { failure } : {})),
            });
        };
        const getNonBlockingApiTest = (publicId) => deep_extend_1.default(fixtures_1.getApiTest(publicId), { options: { ci: { executionRule: interfaces_1.ExecutionRule.NON_BLOCKING } } });
        const baseUrlFixture = 'https://app.datadoghq.com/';
        const locationNamesFixture = { 1: fixtures_1.mockLocation.display_name };
        const cases = [
            {
                description: '1 API test, 1 location, 1 result: success',
                fixtures: {
                    baseUrl: baseUrlFixture,
                    failOnCriticalErrors: false,
                    failOnTimeout: false,
                    locationNames: locationNamesFixture,
                    results: [fixtures_1.getApiPollResult('1')],
                    test: fixtures_1.getApiTest('aaa-aaa-aaa'),
                },
            },
            {
                description: '1 API test (blocking), 1 location, 3 results: success, failed non-blocking, failed',
                fixtures: {
                    baseUrl: baseUrlFixture,
                    failOnCriticalErrors: false,
                    failOnTimeout: false,
                    locationNames: locationNamesFixture,
                    results: [
                        fixtures_1.getApiPollResult('1'),
                        createApiPollResult('2', false, interfaces_1.ExecutionRule.NON_BLOCKING),
                        createApiPollResult('3', false),
                    ],
                    test: fixtures_1.getApiTest('aaa-aaa-aaa'),
                },
            },
            {
                description: '1 API test (non-blocking), 1 location, 3 results: success, failed non-blocking, failed',
                fixtures: {
                    baseUrl: baseUrlFixture,
                    failOnCriticalErrors: false,
                    failOnTimeout: false,
                    locationNames: locationNamesFixture,
                    results: [
                        fixtures_1.getApiPollResult('1'),
                        createApiPollResult('2', false, interfaces_1.ExecutionRule.NON_BLOCKING),
                        createApiPollResult('3', false),
                    ],
                    test: getNonBlockingApiTest('aaa-aaa-aaa'),
                },
            },
        ];
        test.each(cases)('$description', (testCase) => {
            const { test, results, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout } = testCase.fixtures;
            reporter.testEnd(test, results, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout);
            const mostRecentOutput = writeMock.mock.calls[writeMock.mock.calls.length - 1][0];
            expect(mostRecentOutput).toMatchSnapshot();
        });
    });
    describe('runEnd', () => {
        beforeEach(() => {
            writeMock.mockClear();
        });
        const baseSummary = utils_1.createSummary();
        const complexSummary = {
            criticalErrors: 2,
            failed: 1,
            failedNonBlocking: 3,
            passed: 2,
            skipped: 1,
            testsNotFound: new Set(['ccc-ccc-ccc', 'ddd-ddd-ddd']),
            timedOut: 1,
        };
        const cases = [
            {
                description: 'Simple case with 1 test with 1 result (passed)',
                summary: Object.assign(Object.assign({}, baseSummary), { passed: 1 }),
            },
            {
                description: 'Complex case with all the tests and results outcomes possible',
                summary: complexSummary,
            },
            {
                description: 'Case where some outcomes are empty or missing',
                summary: Object.assign(Object.assign({}, baseSummary), { criticalErrors: 1, failedNonBlocking: 1, passed: 3, testsNotFound: new Set(['bbb-bbb-bbb']) }),
            },
        ];
        test.each(cases)('$description', (testCase) => {
            reporter.runEnd(testCase.summary);
            const mostRecentOutput = writeMock.mock.calls[writeMock.mock.calls.length - 1][0];
            expect(mostRecentOutput).toMatchSnapshot();
        });
    });
});
//# sourceMappingURL=default.test.js.map