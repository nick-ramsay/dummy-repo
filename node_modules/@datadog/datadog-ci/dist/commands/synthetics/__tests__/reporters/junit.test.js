"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable: no-string-literal
const fs_1 = require("fs");
const interfaces_1 = require("../../interfaces");
const junit_1 = require("../../reporters/junit");
const fixtures_1 = require("../fixtures");
const globalTestMock = fixtures_1.getApiTest('123-456-789');
const globalStepMock = fixtures_1.getStep();
const globalResultMock = fixtures_1.getBrowserPollResult('1');
describe('Junit reporter', () => {
    const writeMock = jest.fn();
    const commandMock = {
        context: {
            stdout: {
                write: writeMock,
            },
        },
        jUnitReport: 'junit',
    };
    let reporter;
    describe('constructor', () => {
        beforeEach(() => {
            reporter = new junit_1.JUnitReporter(commandMock);
        });
        it("should append '.xml' to destination if isn't there", () => {
            expect(reporter['destination']).toBe('junit.xml');
        });
        it('should give a default run name', () => {
            expect(reporter['json'].testsuites.$.name).toBe('Undefined run');
        });
    });
    describe('runEnd', () => {
        beforeEach(() => {
            reporter = new junit_1.JUnitReporter(commandMock);
            jest.spyOn(fs_1.promises, 'writeFile');
            jest.spyOn(reporter['builder'], 'buildObject');
        });
        it('should build the xml', () => __awaiter(void 0, void 0, void 0, function* () {
            yield reporter.runEnd();
            expect(reporter['builder'].buildObject).toHaveBeenCalledWith(reporter['json']);
            expect(fs_1.promises.writeFile).toHaveBeenCalledWith('junit.xml', expect.any(String), 'utf8');
            expect(writeMock).toHaveBeenCalledTimes(1);
            // Cleaning
            yield fs_1.promises.unlink(reporter['destination']);
        }));
        it('should gracefully fail', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(reporter['builder'], 'buildObject').mockImplementation(() => {
                throw new Error('Fail');
            });
            yield reporter.runEnd();
            expect(fs_1.promises.writeFile).not.toHaveBeenCalled();
            expect(writeMock).toHaveBeenCalledTimes(1);
        }));
        it('should create the file', () => __awaiter(void 0, void 0, void 0, function* () {
            reporter['destination'] = 'junit/report.xml';
            yield reporter.runEnd();
            const stat = yield fs_1.promises.stat(reporter['destination']);
            expect(stat).toBeDefined();
            // Cleaning
            yield fs_1.promises.unlink(reporter['destination']);
            yield fs_1.promises.rmdir('junit');
        }));
        it('should not throw on existing directory', () => __awaiter(void 0, void 0, void 0, function* () {
            yield fs_1.promises.mkdir('junit');
            reporter['destination'] = 'junit/report.xml';
            yield reporter.runEnd();
            // Cleaning
            yield fs_1.promises.unlink(reporter['destination']);
            yield fs_1.promises.rmdir('junit');
        }));
    });
    describe('testEnd', () => {
        const rest = [[], '', {}, true, true];
        beforeEach(() => {
            reporter = new junit_1.JUnitReporter(commandMock);
        });
        it('should give a default suite name', () => {
            reporter.testEnd(globalTestMock, ...rest);
            const testsuite = reporter['json'].testsuites.testsuite[0];
            expect(testsuite.$.name).toBe('Undefined suite');
        });
        it('should use the same report for tests from same suite', () => {
            const testMock = Object.assign({ suite: 'Suite 1' }, globalTestMock);
            reporter.testEnd(testMock, ...rest);
            reporter.testEnd(testMock, ...rest);
            expect(reporter['json'].testsuites.testsuite.length).toBe(1);
        });
        it('should add stats to the run', () => {
            reporter.testEnd(globalTestMock, ...rest);
            const testsuite = reporter['json'].testsuites.testsuite[0];
            expect(testsuite.$).toMatchObject(junit_1.getDefaultStats());
        });
        it('should report errors', () => {
            const browserResult1 = Object.assign(Object.assign({}, globalResultMock), { result: Object.assign(Object.assign({}, fixtures_1.getBrowserResult()), { stepDetails: [
                        Object.assign(Object.assign({}, fixtures_1.getStep()), { allowFailure: true, browserErrors: [
                                {
                                    description: 'error description',
                                    name: 'error name',
                                    type: 'error type',
                                },
                                {
                                    description: 'error description',
                                    name: 'error name',
                                    type: 'error type',
                                },
                            ], error: 'error', warnings: [
                                {
                                    message: 'warning message',
                                    type: 'warning type',
                                },
                            ] }),
                        fixtures_1.getStep(),
                    ] }) });
            const browserResult2 = Object.assign(Object.assign({}, globalResultMock), { result: fixtures_1.getBrowserResult() });
            const browserResult3 = Object.assign(Object.assign({}, globalResultMock), { result: Object.assign(Object.assign({}, fixtures_1.getBrowserResult()), { error: interfaces_1.ERRORS.TIMEOUT }) });
            const apiResult = Object.assign(Object.assign({}, fixtures_1.getApiPollResult('1')), { result: Object.assign(Object.assign({}, fixtures_1.getMultiStepsResult()), { steps: [
                        Object.assign(Object.assign({}, fixtures_1.getMultiStep()), { failure: {
                                code: '1',
                                message: 'message',
                            } }),
                    ] }) });
            reporter.testEnd(globalTestMock, [browserResult1, browserResult2, browserResult3, apiResult], '', {}, true, true);
            const testsuite = reporter['json'].testsuites.testsuite[0];
            const results = [
                [1, 2, 0, 1],
                [0, 0, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 1, 0],
            ];
            const entries = Object.entries(testsuite.testcase);
            for (const [i, testcase] of entries) {
                const result = results[i];
                expect(testcase.allowed_error.length).toBe(result[0]);
                expect(testcase.browser_error.length).toBe(result[1]);
                expect(testcase.error.length).toBe(result[2]);
                expect(testcase.warning.length).toBe(result[3]);
            }
        });
    });
    describe('getTestCase', () => {
        it('should add stats to the suite', () => {
            const resultMock = Object.assign(Object.assign({}, globalResultMock), {
                result: Object.assign(Object.assign({}, globalResultMock.result), { stepDetails: [
                        globalStepMock,
                        Object.assign(Object.assign({}, globalStepMock), {
                            browserErrors: [{ type: 'error', name: 'Error', description: 'Description' }],
                            error: 'Error',
                            subTestStepDetails: [globalStepMock],
                            warnings: [{ type: 'warning', message: 'Warning' }],
                        }),
                    ] }),
            });
            const suite = reporter['getTestCase'](fixtures_1.getApiTest('123-456-789'), resultMock, {}, true, true);
            expect(suite.$).toMatchObject(Object.assign(Object.assign({}, junit_1.getDefaultStats()), { errors: 2, failures: 1, tests: 3, warnings: 1 }));
        });
    });
});
//# sourceMappingURL=junit.test.js.map