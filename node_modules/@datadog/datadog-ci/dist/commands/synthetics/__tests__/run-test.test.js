"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ciUtils = __importStar(require("../../../helpers/utils"));
const errors_1 = require("../errors");
const interfaces_1 = require("../interfaces");
const runTests = __importStar(require("../run-test"));
const tunnel_1 = require("../tunnel");
const utils = __importStar(require("../utils"));
const fixtures_1 = require("./fixtures");
describe('run-test', () => {
    beforeEach(() => {
        jest.restoreAllMocks();
        jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({}); }));
        process.env = {};
    });
    describe('execute', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        test('should apply config override for tests triggered by public id', () => __awaiter(void 0, void 0, void 0, function* () {
            const getTestsToTriggersMock = jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [],
            }));
            jest.spyOn(utils, 'runTests').mockImplementation();
            const startUrl = '{{PROTOCOL}}//myhost{{PATHNAME}}{{PARAMS}}';
            const locations = ['location1', 'location2'];
            const configOverride = { locations, startUrl };
            const apiHelper = {};
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => ({}));
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, publicIds: ['public-id-1', 'public-id-2'] }))).rejects.toThrow();
            expect(getTestsToTriggersMock).toHaveBeenCalledWith(apiHelper, expect.arrayContaining([
                expect.objectContaining({ id: 'public-id-1', config: configOverride }),
                expect.objectContaining({ id: 'public-id-2', config: configOverride }),
            ]), expect.anything());
        }));
        test('should not wait for `skipped` only tests batch results', () => __awaiter(void 0, void 0, void 0, function* () {
            const getTestsToTriggersMock = jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [],
            }));
            const apiHelper = {};
            const configOverride = { executionRule: interfaces_1.ExecutionRule.SKIPPED };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => ({}));
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, publicIds: ['public-id-1', 'public-id-2'] }))).rejects.toMatchError(new errors_1.CiError('NO_TESTS_TO_RUN'));
            expect(getTestsToTriggersMock).toHaveBeenCalledWith(apiHelper, expect.arrayContaining([
                expect.objectContaining({ id: 'public-id-1', config: configOverride }),
                expect.objectContaining({ id: 'public-id-2', config: configOverride }),
            ]), expect.anything());
        }));
        test('should not open tunnel if no test to run', () => __awaiter(void 0, void 0, void 0, function* () {
            const getTestsToTriggersMock = jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [],
            }));
            const apiHelper = {
                getPresignedURL: jest.fn(),
            };
            const configOverride = { executionRule: interfaces_1.ExecutionRule.SKIPPED };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, publicIds: ['public-id-1', 'public-id-2'], tunnel: true }))).rejects.toMatchError(new errors_1.CiError('NO_TESTS_TO_RUN'));
            expect(getTestsToTriggersMock).toHaveBeenCalledWith(apiHelper, expect.arrayContaining([
                expect.objectContaining({ id: 'public-id-1', config: configOverride }),
                expect.objectContaining({ id: 'public-id-2', config: configOverride }),
            ]), expect.anything());
            expect(apiHelper.getPresignedURL).not.toHaveBeenCalled();
        }));
        test('open and close tunnel for successful runs', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(utils, 'wait').mockImplementation(() => new Promise((res) => setTimeout(res, 10)));
            const startTunnelSpy = jest
                .spyOn(tunnel_1.Tunnel.prototype, 'start')
                .mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({ host: 'host', id: 'id', privateKey: 'key' }); }));
            const stopTunnelSpy = jest.spyOn(tunnel_1.Tunnel.prototype, 'stop');
            jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [{ options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: '123-456-789' }],
            }));
            jest.spyOn(utils, 'runTests').mockResolvedValue(Object.assign(Object.assign({}, fixtures_1.mockTestTriggerResponse), { triggered_check_ids: [] }));
            const apiHelper = {
                getPresignedURL: () => ({ url: 'url' }),
                pollResults: () => ({ results: [fixtures_1.getApiPollResult('1')] }),
                triggerTests: () => fixtures_1.mockTestTriggerResponse,
            };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            yield runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { failOnCriticalErrors: true, publicIds: ['123-456-789'], tunnel: true }));
            expect(startTunnelSpy).toHaveBeenCalledTimes(1);
            expect(stopTunnelSpy).toHaveBeenCalledTimes(1);
        }));
        const cases = [
            [403, 'AUTHORIZATION_ERROR'],
            [502, 'UNAVAILABLE_TEST_CONFIG'],
        ];
        describe.each(cases)('%s triggers %s', (status, error) => {
            test(`getTestsList throws - ${status}`, () => __awaiter(void 0, void 0, void 0, function* () {
                const serverError = new Error('Server Error');
                serverError.response = { data: { errors: ['Error'] }, status };
                serverError.config = { baseURL: 'baseURL', url: 'url' };
                const apiHelper = {
                    searchTests: jest.fn(() => {
                        throw serverError;
                    }),
                };
                jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
                yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { testSearchQuery: 'a-search-query', tunnel: true }))).rejects.toMatchError(new errors_1.CriticalError(error, 'Server Error'));
            }));
            test(`getTestsToTrigger throws - ${status}`, () => __awaiter(void 0, void 0, void 0, function* () {
                const serverError = new Error('Server Error');
                serverError.response = { data: { errors: ['Bad Gateway'] }, status };
                serverError.config = { baseURL: 'baseURL', url: 'url' };
                const apiHelper = {
                    getTest: jest.fn(() => {
                        throw serverError;
                    }),
                };
                jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
                yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { publicIds: ['public-id-1'], tunnel: true }))).rejects.toMatchError(new errors_1.CriticalError(error, 'Server Error'));
            }));
        });
        test('getPresignedURL throws', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [{ options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: 'publicId' }],
            }));
            const serverError = new Error('Server Error');
            serverError.response = { data: { errors: ['Bad Gateway'] }, status: 502 };
            serverError.config = { baseURL: 'baseURL', url: 'url' };
            const apiHelper = {
                getPresignedURL: jest.fn(() => {
                    throw serverError;
                }),
            };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { publicIds: ['public-id-1', 'public-id-2'], tunnel: true }))).rejects.toMatchError(new errors_1.CriticalError('UNAVAILABLE_TUNNEL_CONFIG', 'Server Error'));
        }));
        test('runTests throws', () => __awaiter(void 0, void 0, void 0, function* () {
            jest
                .spyOn(tunnel_1.Tunnel.prototype, 'start')
                .mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({ host: 'host', id: 'id', privateKey: 'key' }); }));
            const stopTunnelSpy = jest.spyOn(tunnel_1.Tunnel.prototype, 'stop');
            jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [{ options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: 'publicId' }],
            }));
            const serverError = new Error('Server Error');
            serverError.response = { data: { errors: ['Bad Gateway'] }, status: 502 };
            serverError.config = { baseURL: 'baseURL', url: 'url' };
            const apiHelper = {
                getPresignedURL: () => ({ url: 'url' }),
                triggerTests: jest.fn(() => {
                    throw serverError;
                }),
            };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { publicIds: ['public-id-1', 'public-id-2'], tunnel: true }))).rejects.toMatchError(new errors_1.CriticalError('TRIGGER_TESTS_FAILED', '[] Failed to trigger tests: query on baseURLurl returned: "Bad Gateway"\n'));
            expect(stopTunnelSpy).toHaveBeenCalledTimes(1);
        }));
        test('waitForResults throws', () => __awaiter(void 0, void 0, void 0, function* () {
            const location = {
                display_name: 'us1',
                id: 1,
                is_active: true,
                name: 'us1',
                region: 'us1',
            };
            jest
                .spyOn(tunnel_1.Tunnel.prototype, 'start')
                .mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({ host: 'host', id: 'id', privateKey: 'key' }); }));
            const stopTunnelSpy = jest.spyOn(tunnel_1.Tunnel.prototype, 'stop');
            jest.spyOn(utils, 'getTestsToTrigger').mockReturnValue(Promise.resolve({
                overriddenTestsToTrigger: [],
                summary: utils.createSummary(),
                tests: [{ options: { ci: { executionRule: interfaces_1.ExecutionRule.BLOCKING } }, public_id: 'publicId' }],
            }));
            jest.spyOn(utils, 'runTests').mockReturnValue(Promise.resolve({
                locations: [location],
                results: [{ device: 'chrome_laptop.large', location: 1, public_id: 'publicId', result_id: '1111' }],
                triggered_check_ids: [],
            }));
            const serverError = new Error('Server Error');
            serverError.response = { data: { errors: ['Bad Gateway'] }, status: 502 };
            serverError.config = { baseURL: 'baseURL', url: 'url' };
            const apiHelper = {
                getPresignedURL: () => ({ url: 'url' }),
                pollResults: jest.fn(() => {
                    throw serverError;
                }),
            };
            jest.spyOn(runTests, 'getApiHelper').mockImplementation(() => apiHelper);
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { failOnCriticalErrors: true, publicIds: ['public-id-1', 'public-id-2'], tunnel: true }))).rejects.toMatchError(new errors_1.CriticalError('POLL_RESULTS_FAILED', 'Server Error'));
            expect(stopTunnelSpy).toHaveBeenCalledTimes(1);
        }));
    });
    describe('getDatadogHost', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        test('should default to datadog us api', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = {};
            expect(runTests.getDatadogHost(false, fixtures_1.ciConfig)).toBe('https://api.datadoghq.com/api/v1');
            expect(runTests.getDatadogHost(true, fixtures_1.ciConfig)).toBe('https://intake.synthetics.datadoghq.com/api/v1');
        }));
        test('should use DD_API_HOST_OVERRIDE', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = { DD_API_HOST_OVERRIDE: 'https://foobar' };
            expect(runTests.getDatadogHost(true, fixtures_1.ciConfig)).toBe('https://foobar/api/v1');
            expect(runTests.getDatadogHost(true, fixtures_1.ciConfig)).toBe('https://foobar/api/v1');
        }));
        test('should use Synthetics intake endpoint', () => __awaiter(void 0, void 0, void 0, function* () {
            expect(runTests.getDatadogHost(true, Object.assign(Object.assign({}, fixtures_1.ciConfig), { datadogSite: 'datadoghq.com' }))).toBe('https://intake.synthetics.datadoghq.com/api/v1');
            expect(runTests.getDatadogHost(true, Object.assign(Object.assign({}, fixtures_1.ciConfig), { datadogSite: 'datad0g.com' }))).toBe('https://intake.synthetics.datad0g.com/api/v1');
        }));
    });
    describe('getApiHelper', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        test('should throw an error if API or Application key are undefined', () => __awaiter(void 0, void 0, void 0, function* () {
            process.env = {};
            expect(() => runTests.getApiHelper(fixtures_1.ciConfig)).toThrow(new errors_1.CriticalError('MISSING_APP_KEY'));
            yield expect(runTests.executeTests(fixtures_1.mockReporter, fixtures_1.ciConfig)).rejects.toMatchError(new errors_1.CriticalError('MISSING_APP_KEY'));
            expect(() => runTests.getApiHelper(Object.assign(Object.assign({}, fixtures_1.ciConfig), { appKey: 'fakeappkey' }))).toThrow(new errors_1.CriticalError('MISSING_API_KEY'));
            yield expect(runTests.executeTests(fixtures_1.mockReporter, Object.assign(Object.assign({}, fixtures_1.ciConfig), { appKey: 'fakeappkey' }))).rejects.toMatchError(new errors_1.CriticalError('MISSING_API_KEY'));
        }));
    });
    describe('getTestsList', () => {
        beforeEach(() => {
            jest.restoreAllMocks();
        });
        const conf1 = {
            tests: [{ config: {}, id: 'abc-def-ghi' }],
        };
        const conf2 = {
            tests: [{ config: {}, id: 'jkl-mno-pqr' }],
        };
        const fakeSuites = [
            {
                content: conf1,
                name: 'Suite 1',
            },
            {
                content: conf2,
                name: 'Suite 2',
            },
        ];
        const startUrl = 'fakeUrl';
        const fakeApi = {
            searchTests: () => ({
                tests: [
                    {
                        public_id: 'stu-vwx-yza',
                    },
                ],
            }),
        };
        test('should find all tests and extend global config', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(utils, 'getSuites').mockImplementation((() => fakeSuites));
            const configOverride = { startUrl };
            yield expect(runTests.getTestsList(fakeApi, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride }), fixtures_1.mockReporter)).resolves.toEqual([
                {
                    config: { startUrl },
                    id: 'abc-def-ghi',
                    suite: 'Suite 1',
                },
                {
                    config: { startUrl },
                    id: 'jkl-mno-pqr',
                    suite: 'Suite 2',
                },
            ]);
        }));
        test('should search tests and extend global config', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(utils, 'getSuites').mockImplementation((() => fakeSuites));
            const configOverride = { startUrl };
            const searchQuery = 'fake search';
            yield expect(runTests.getTestsList(fakeApi, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, testSearchQuery: searchQuery }), fixtures_1.mockReporter)).resolves.toEqual([
                {
                    config: { startUrl },
                    id: 'stu-vwx-yza',
                    suite: 'Query: fake search',
                },
            ]);
        }));
        test('should use given globs to get tests list', () => __awaiter(void 0, void 0, void 0, function* () {
            const getSuitesMock = jest.spyOn(utils, 'getSuites').mockImplementation((() => fakeSuites));
            const configOverride = { startUrl };
            const files = ['new glob', 'another one'];
            yield runTests.getTestsList(fakeApi, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, files }), fixtures_1.mockReporter);
            expect(getSuitesMock).toHaveBeenCalledTimes(2);
            expect(getSuitesMock).toHaveBeenCalledWith('new glob', fixtures_1.mockReporter);
            expect(getSuitesMock).toHaveBeenCalledWith('another one', fixtures_1.mockReporter);
        }));
        test('should return tests from provided suites with overrides', () => __awaiter(void 0, void 0, void 0, function* () {
            const getSuitesMock = jest.spyOn(utils, 'getSuites').mockImplementation((() => fakeSuites));
            const configOverride = { startUrl };
            const files = [];
            const tests = yield runTests.getTestsList(fakeApi, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, files }), fixtures_1.mockReporter, fakeSuites);
            expect(tests).toEqual([
                { config: { startUrl }, id: conf1.tests[0].id, suite: fakeSuites[0].name },
                { config: { startUrl }, id: conf2.tests[0].id, suite: fakeSuites[1].name },
            ]);
            expect(getSuitesMock).not.toHaveBeenCalled();
        }));
        test('should merge getSuites and user provided suites', () => __awaiter(void 0, void 0, void 0, function* () {
            const userSuites = [fakeSuites[0]];
            const globSuites = [fakeSuites[1]];
            const getSuitesMock = jest.spyOn(utils, 'getSuites').mockImplementation((() => globSuites));
            const configOverride = { startUrl };
            const files = ['glob'];
            const tests = yield runTests.getTestsList(fakeApi, Object.assign(Object.assign({}, fixtures_1.ciConfig), { global: configOverride, files }), fixtures_1.mockReporter, userSuites);
            expect(tests).toEqual([
                { config: { startUrl }, id: conf1.tests[0].id, suite: fakeSuites[0].name },
                { config: { startUrl }, id: conf2.tests[0].id, suite: fakeSuites[1].name },
            ]);
            expect(getSuitesMock).toHaveBeenCalled();
        }));
    });
});
//# sourceMappingURL=run-test.test.js.map