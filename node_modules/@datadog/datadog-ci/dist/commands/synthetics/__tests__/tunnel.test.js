"use strict";
// tslint:disable: no-string-literal
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const utils_1 = require("ts-jest/utils");
const tunnel_1 = require("../tunnel");
const websocket_1 = require("../websocket");
const fixtures_1 = require("./fixtures");
jest.mock('../websocket');
describe('Tunnel', () => {
    const mockConnect = jest.fn();
    const mockClose = jest.fn();
    const mockWebSocket = {
        close: mockClose,
        connect: mockConnect,
        duplex: () => new stream_1.PassThrough(),
        firstMessage: { host: 'host', id: 'tunnel-id' },
        keepAlive: () => __awaiter(void 0, void 0, void 0, function* () {
            return new Promise(() => {
                // Never resolve
            });
        }),
        waitForFirstMessage: () => __awaiter(void 0, void 0, void 0, function* () { return Promise.resolve(JSON.stringify(mockWebSocket.firstMessage)); }),
    };
    const defaultProxyOpts = { protocol: 'http' };
    const testIDs = ['aaa-bbb-ccc'];
    const wsPresignedURL = 'wss://tunnel.synthetics';
    const mockedWebSocket = utils_1.mocked(websocket_1.WebSocket, true);
    test('starts by connecting over WebSocket and closes the WebSocket when stopping', () => __awaiter(void 0, void 0, void 0, function* () {
        mockedWebSocket.mockImplementation(() => mockWebSocket);
        const tunnel = new tunnel_1.Tunnel(wsPresignedURL, testIDs, defaultProxyOpts, fixtures_1.mockReporter);
        const connectionInfo = yield tunnel.start();
        expect(websocket_1.WebSocket).toHaveBeenCalledWith(wsPresignedURL, expect.any(Object));
        expect(mockConnect).toHaveBeenCalled();
        expect(connectionInfo.host).toEqual('host');
        expect(connectionInfo.id).toEqual('tunnel-id');
        expect(connectionInfo.privateKey.length).toBeGreaterThan(0);
        // TODO: test SSH authentication and processing
        // Stop the tunnel
        yield tunnel.stop();
        expect(mockClose).toHaveBeenCalled();
    }));
    test('throws an error if the WebSocket connection fails', () => __awaiter(void 0, void 0, void 0, function* () {
        mockedWebSocket.mockImplementation(() => ({
            close: mockClose,
            connect: mockConnect,
        }));
        const websocketConnectError = new Error('Error when connecting over WebSocket!');
        mockConnect.mockImplementation(() => {
            throw websocketConnectError;
        });
        const tunnel = new tunnel_1.Tunnel(wsPresignedURL, testIDs, defaultProxyOpts, fixtures_1.mockReporter);
        yield expect(tunnel.start()).rejects.toThrow(websocketConnectError);
        expect(mockClose).toBeCalled();
        mockConnect.mockRestore();
    }));
    test('sets websocket proxy options', () => __awaiter(void 0, void 0, void 0, function* () {
        mockedWebSocket.mockImplementation(() => mockWebSocket);
        const localProxyOpts = {
            host: '127.0.0.1',
            port: 8080,
            protocol: 'http',
        };
        const tunnel = new tunnel_1.Tunnel(wsPresignedURL, testIDs, localProxyOpts, fixtures_1.mockReporter);
        yield tunnel.start();
        expect(websocket_1.WebSocket).toHaveBeenCalledWith(wsPresignedURL, localProxyOpts);
        // Stop the tunnel
        yield tunnel.stop();
    }));
});
//# sourceMappingURL=tunnel.test.js.map