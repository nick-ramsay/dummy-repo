"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('glob');
jest.mock('fs');
const fs = __importStar(require("fs"));
const axios_1 = __importDefault(require("axios"));
const glob_1 = __importDefault(require("glob"));
process.env.DATADOG_SYNTHETICS_CI_TRIGGER_APP = 'env_default';
const ciHelpers = __importStar(require("../../../helpers/ci"));
const api_1 = require("../api");
const errors_1 = require("../errors");
const interfaces_1 = require("../interfaces");
const utils = __importStar(require("../utils"));
const fixtures_1 = require("./fixtures");
describe('utils', () => {
    const apiConfiguration = {
        apiKey: '123',
        appKey: '123',
        baseIntakeUrl: 'baseintake',
        baseUrl: 'base',
        proxyOpts: { protocol: 'http' },
    };
    const api = api_1.apiConstructor(apiConfiguration);
    describe('getSuites', () => {
        const GLOB = 'testGlob';
        const FILES = ['file1', 'file2'];
        const FILES_CONTENT = {
            file1: '{"tests":"file1"}',
            file2: '{"tests":"file2"}',
        };
        fs.readFile.mockImplementation((path, opts, callback) => callback(undefined, FILES_CONTENT[path]));
        glob_1.default.mockImplementation((query, callback) => callback(undefined, FILES));
        test('should get suites', () => __awaiter(void 0, void 0, void 0, function* () {
            const suites = yield utils.getSuites(GLOB, fixtures_1.mockReporter);
            expect(JSON.stringify(suites)).toBe(`[{"name":"file1","content":${FILES_CONTENT.file1}},{"name":"file2","content":${FILES_CONTENT.file2}}]`);
        }));
    });
    describe('runTest', () => {
        const fakeId = '123-456-789';
        const fakeTrigger = {
            results: [],
            triggered_check_ids: [fakeId],
        };
        afterAll(() => {
            jest.clearAllMocks();
        });
        test('should run test', () => __awaiter(void 0, void 0, void 0, function* () {
            const axiosMock = jest.spyOn(axios_1.default, 'create');
            axiosMock.mockImplementation((() => (e) => {
                if (e.url === '/synthetics/tests/trigger/ci') {
                    return { data: fakeTrigger };
                }
            }));
            const output = yield utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }]);
            expect(output).toEqual(fakeTrigger);
        }));
        test('runTests sends batch metadata', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(ciHelpers, 'getCIMetadata').mockImplementation(() => undefined);
            const payloadMetadataSpy = jest.fn();
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (request) => {
                payloadMetadataSpy(request.data.metadata);
                if (request.url === '/synthetics/tests/trigger/ci') {
                    return { data: fakeTrigger };
                }
            }));
            yield utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }]);
            expect(payloadMetadataSpy).toHaveBeenCalledWith(undefined);
            const metadata = {
                ci: { job: { name: 'job' }, pipeline: {}, provider: { name: 'jest' }, stage: {} },
                git: { commit: { author: {}, committer: {}, message: 'test' } },
            };
            jest.spyOn(ciHelpers, 'getCIMetadata').mockImplementation(() => metadata);
            yield utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }]);
            expect(payloadMetadataSpy).toHaveBeenCalledWith(metadata);
        }));
        test('runTests api call includes trigger app header', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(ciHelpers, 'getCIMetadata').mockImplementation(() => undefined);
            const headersMetadataSpy = jest.fn();
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (request) => {
                headersMetadataSpy(request.headers);
                if (request.url === '/synthetics/tests/trigger/ci') {
                    return { data: fakeTrigger };
                }
            }));
            yield utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }]);
            expect(headersMetadataSpy).toHaveBeenCalledWith(expect.objectContaining({ 'X-Trigger-App': 'env_default' }));
            utils.setCiTriggerApp('unit_test');
            yield utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }]);
            expect(headersMetadataSpy).toHaveBeenCalledWith(expect.objectContaining({ 'X-Trigger-App': 'unit_test' }));
        }));
        test('should run test with publicId from url', () => __awaiter(void 0, void 0, void 0, function* () {
            const axiosMock = jest.spyOn(axios_1.default, 'create');
            axiosMock.mockImplementation((() => (e) => {
                if (e.url === '/synthetics/tests/trigger/ci') {
                    return { data: fakeTrigger };
                }
            }));
            const output = yield utils.runTests(api, [
                {
                    executionRule: interfaces_1.ExecutionRule.NON_BLOCKING,
                    public_id: `http://localhost/synthetics/tests/details/${fakeId}`,
                },
            ]);
            expect(output).toEqual(fakeTrigger);
        }));
        test('triggerTests throws', () => __awaiter(void 0, void 0, void 0, function* () {
            const serverError = new Error('Server Error');
            Object.assign(serverError, {
                config: { baseURL: 'baseURL', url: 'url' },
                response: {
                    data: { errors: [] },
                    status: 502,
                },
            });
            const requestMock = jest.fn();
            requestMock.mockImplementation(() => {
                throw serverError;
            });
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => requestMock));
            yield expect(utils.runTests(api, [{ public_id: fakeId, executionRule: interfaces_1.ExecutionRule.NON_BLOCKING }])).rejects.toThrow(/Failed to trigger tests:/);
        }));
    });
    describe('getTestsToTrigger', () => {
        const fakeTests = {
            '123-456-789': {
                config: { request: { url: 'http://example.org/' } },
                name: 'Fake Test',
                public_id: '123-456-789',
                suite: 'Suite 1',
            },
            'ski-ppe-d01': {
                config: { request: { url: 'http://example.org/' } },
                name: 'Skipped Fake Test',
                options: { ci: { executionRule: 'skipped' } },
                public_id: 'ski-ppe-d01',
                suite: 'Suite 3',
            },
        };
        beforeAll(() => {
            const axiosMock = jest.spyOn(axios_1.default, 'create');
            axiosMock.mockImplementation((() => (e) => {
                const publicId = e.url.slice(18);
                if (fakeTests[publicId]) {
                    return { data: fakeTests[publicId] };
                }
                const error = new Error('Not found');
                error.status = 404;
                throw error;
            }));
        });
        afterAll(() => {
            jest.clearAllMocks();
        });
        test('only existing tests are returned', () => __awaiter(void 0, void 0, void 0, function* () {
            const triggerConfigs = [
                { suite: 'Suite 1', config: {}, id: '123-456-789' },
                { suite: 'Suite 2', config: {}, id: '987-654-321' },
                { suite: 'Suite 3', config: {}, id: 'ski-ppe-d01' },
            ];
            const { tests, overriddenTestsToTrigger, summary } = yield utils.getTestsToTrigger(api, triggerConfigs, fixtures_1.mockReporter);
            expect(tests).toStrictEqual([fakeTests['123-456-789']]);
            expect(overriddenTestsToTrigger).toStrictEqual([
                { executionRule: interfaces_1.ExecutionRule.BLOCKING, public_id: '123-456-789' },
                { executionRule: interfaces_1.ExecutionRule.SKIPPED, public_id: 'ski-ppe-d01' },
            ]);
            const expectedSummary = {
                criticalErrors: 0,
                failed: 0,
                failedNonBlocking: 0,
                passed: 0,
                skipped: 1,
                testsNotFound: new Set(['987-654-321']),
                timedOut: 0,
            };
            expect(summary).toEqual(expectedSummary);
        }));
        test('no tests triggered throws an error', () => __awaiter(void 0, void 0, void 0, function* () {
            yield expect(utils.getTestsToTrigger(api, [], fixtures_1.mockReporter)).rejects.toEqual(new errors_1.CiError('NO_TESTS_TO_RUN'));
        }));
    });
    describe('handleConfig', () => {
        test('empty config returns simple payload', () => {
            const publicId = 'abc-def-ghi';
            expect(utils.handleConfig({ public_id: publicId }, publicId, fixtures_1.mockReporter)).toEqual({
                executionRule: interfaces_1.ExecutionRule.BLOCKING,
                public_id: publicId,
            });
        });
        test('strictest executionRule is forwarded', () => {
            const expectHandledConfigToBe = (expectedExecutionRule, configExecutionRule, testExecutionRule) => {
                const publicId = 'abc-def-ghi';
                const fakeTest = {
                    config: { request: { url: 'http://example.org/path' } },
                    options: {},
                    public_id: publicId,
                };
                if (testExecutionRule) {
                    fakeTest.options.ci = { executionRule: testExecutionRule };
                }
                const configOverride = configExecutionRule ? { executionRule: configExecutionRule } : undefined;
                expect(utils.getExecutionRule(fakeTest, configOverride)).toBe(expectedExecutionRule);
                const handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
                expect(handledConfig.public_id).toBe(publicId);
                expect(handledConfig.executionRule).toBe(expectedExecutionRule);
            };
            const BLOCKING = interfaces_1.ExecutionRule.BLOCKING;
            const NON_BLOCKING = interfaces_1.ExecutionRule.NON_BLOCKING;
            const SKIPPED = interfaces_1.ExecutionRule.SKIPPED;
            // No override => BLOCKING
            expectHandledConfigToBe(BLOCKING);
            // CI config overrides only
            expectHandledConfigToBe(BLOCKING, BLOCKING);
            expectHandledConfigToBe(NON_BLOCKING, NON_BLOCKING);
            expectHandledConfigToBe(SKIPPED, SKIPPED);
            // Test config only
            expectHandledConfigToBe(BLOCKING, undefined, BLOCKING);
            expectHandledConfigToBe(NON_BLOCKING, undefined, NON_BLOCKING);
            expectHandledConfigToBe(SKIPPED, undefined, SKIPPED);
            // Strictest executionRule is forwarded
            expectHandledConfigToBe(NON_BLOCKING, BLOCKING, NON_BLOCKING);
            expectHandledConfigToBe(SKIPPED, SKIPPED, BLOCKING);
            expectHandledConfigToBe(SKIPPED, NON_BLOCKING, SKIPPED);
            expectHandledConfigToBe(SKIPPED, SKIPPED, NON_BLOCKING);
        });
        test('startUrl template is rendered if correct test type or subtype', () => {
            const publicId = 'abc-def-ghi';
            const fakeTest = {
                config: { request: { url: 'http://example.org/path#target' } },
                public_id: publicId,
                type: 'browser',
            };
            const configOverride = {
                startUrl: 'https://{{DOMAIN}}/newPath?oldPath={{ PATHNAME   }}{{HASH}}',
            };
            const expectedUrl = 'https://example.org/newPath?oldPath=/path#target';
            let handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
            expect(handledConfig.public_id).toBe(publicId);
            expect(handledConfig.startUrl).toBe(expectedUrl);
            fakeTest.type = 'api';
            fakeTest.subtype = 'http';
            handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
            expect(handledConfig.public_id).toBe(publicId);
            expect(handledConfig.startUrl).toBe(expectedUrl);
            fakeTest.subtype = 'dns';
            handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
            expect(handledConfig.public_id).toBe(publicId);
            expect(handledConfig.startUrl).toBeUndefined();
        });
        test('startUrl is not parsable', () => {
            const envVars = Object.assign({}, process.env);
            process.env = { CUSTOMVAR: '/newPath' };
            const publicId = 'abc-def-ghi';
            const fakeTest = {
                config: { request: { url: 'http://{{ FAKE_VAR }}/path' } },
                public_id: publicId,
                type: 'browser',
            };
            const configOverride = {
                startUrl: 'https://{{DOMAIN}}/newPath?oldPath={{CUSTOMVAR}}',
            };
            const expectedUrl = 'https://{{DOMAIN}}/newPath?oldPath=/newPath';
            const handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
            expect(handledConfig.public_id).toBe(publicId);
            expect(handledConfig.startUrl).toBe(expectedUrl);
            process.env = envVars;
        });
        test('startUrl with empty variable is replaced', () => {
            const publicId = 'abc-def-ghi';
            const fakeTest = {
                config: { request: { url: 'http://exmaple.org/path' } },
                public_id: publicId,
                type: 'browser',
            };
            const configOverride = {
                startUrl: 'http://127.0.0.1/newPath{{PARAMS}}',
            };
            const expectedUrl = 'http://127.0.0.1/newPath';
            const handledConfig = utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride);
            expect(handledConfig.public_id).toBe(publicId);
            expect(handledConfig.startUrl).toBe(expectedUrl);
        });
        test('config overrides are applied', () => {
            const publicId = 'abc-def-ghi';
            const fakeTest = {
                config: { request: { url: 'http://example.org/path' } },
                public_id: publicId,
                type: 'browser',
            };
            const configOverride = {
                allowInsecureCertificates: true,
                basicAuth: { username: 'user', password: 'password' },
                body: 'body',
                bodyType: 'application/json',
                cookies: 'name=value;',
                defaultStepTimeout: 15,
                deviceIds: ['device_id'],
                executionRule: interfaces_1.ExecutionRule.NON_BLOCKING,
                followRedirects: true,
                headers: { 'header-name': 'value' },
                locations: ['location'],
                pollingTimeout: 60 * 1000,
                retry: { count: 5, interval: 30 },
                startUrl: 'http://127.0.0.1:60/newPath',
                startUrlSubstitutionRegex: '.*',
                tunnel: { host: 'host', id: 'id', privateKey: 'privateKey' },
                variables: { VAR_1: 'value' },
            };
            expect(utils.handleConfig(fakeTest, publicId, fixtures_1.mockReporter, configOverride)).toEqual(Object.assign(Object.assign({}, configOverride), { public_id: publicId }));
        });
    });
    describe('hasResultPassed', () => {
        test('complete result', () => {
            const result = {
                device: { height: 0, id: 'laptop_large', width: 0 },
                duration: 0,
                eventType: 'finished',
                passed: true,
                startUrl: '',
                stepDetails: [],
            };
            expect(utils.hasResultPassed(result, false, true)).toBeTruthy();
            expect(utils.hasResultPassed(result, true, true)).toBeTruthy();
            result.passed = false;
            expect(utils.hasResultPassed(result, false, true)).toBeFalsy();
            expect(utils.hasResultPassed(result, true, true)).toBeFalsy();
        });
        test('result with error', () => {
            const result = {
                device: { height: 0, id: 'laptop_large', width: 0 },
                duration: 0,
                errorCode: 'ERRABORTED',
                eventType: 'finished',
                passed: false,
                startUrl: '',
                stepDetails: [],
            };
            expect(utils.hasResultPassed(result, false, true)).toBeFalsy();
            expect(utils.hasResultPassed(result, true, true)).toBeFalsy();
        });
        test('result with unhealthy result', () => {
            const result = {
                device: { height: 0, id: 'laptop_large', width: 0 },
                duration: 0,
                errorCode: 'ERRABORTED',
                eventType: 'finished',
                passed: false,
                startUrl: '',
                stepDetails: [],
                unhealthy: true,
            };
            expect(utils.hasResultPassed(result, false, true)).toBeTruthy();
            expect(utils.hasResultPassed(result, true, true)).toBeFalsy();
        });
        test('result with timeout result', () => {
            const result = {
                device: { height: 0, id: 'laptop_large', width: 0 },
                duration: 0,
                error: interfaces_1.ERRORS.TIMEOUT,
                eventType: 'finished',
                passed: false,
                startUrl: '',
                stepDetails: [],
            };
            expect(utils.hasResultPassed(result, true, true)).toBeFalsy();
            expect(utils.hasResultPassed(result, true, false)).toBeTruthy();
        });
    });
    test('result with endpoint failure result', () => {
        const result = {
            device: { height: 0, id: 'laptop_large', width: 0 },
            duration: 0,
            error: interfaces_1.ERRORS.ENDPOINT,
            eventType: 'finished',
            passed: false,
            startUrl: '',
            stepDetails: [],
        };
        expect(utils.hasResultPassed(result, false, true)).toBeTruthy();
        expect(utils.hasResultPassed(result, true, true)).toBeFalsy();
    });
    describe('getExecutionRule', () => {
        const cases = [
            [undefined, undefined, interfaces_1.ExecutionRule.BLOCKING],
            [undefined, interfaces_1.ExecutionRule.BLOCKING, interfaces_1.ExecutionRule.BLOCKING],
            [undefined, interfaces_1.ExecutionRule.NON_BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING],
            [interfaces_1.ExecutionRule.BLOCKING, undefined, interfaces_1.ExecutionRule.BLOCKING],
            [interfaces_1.ExecutionRule.BLOCKING, interfaces_1.ExecutionRule.BLOCKING, interfaces_1.ExecutionRule.BLOCKING],
            [interfaces_1.ExecutionRule.BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING],
            [interfaces_1.ExecutionRule.NON_BLOCKING, undefined, interfaces_1.ExecutionRule.NON_BLOCKING],
            [interfaces_1.ExecutionRule.NON_BLOCKING, interfaces_1.ExecutionRule.BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING],
            [interfaces_1.ExecutionRule.NON_BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING, interfaces_1.ExecutionRule.NON_BLOCKING],
        ];
        test.each(cases)('Test execution rule: %s, result execution rule: %s. Expected rule: %s', (testRule, resultRule, expectedRule) => {
            const test = fixtures_1.getApiTest('abc-def-ghi');
            expect(utils.getExecutionRule(testRule ? Object.assign(Object.assign({}, test), { options: Object.assign(Object.assign({}, test.options), { ci: { executionRule: testRule } }) }) : test, resultRule ? { executionRule: resultRule } : {})).toEqual(expectedRule);
        });
    });
    describe('getResultOutcome', () => {
        const cases = [
            [true, interfaces_1.ExecutionRule.BLOCKING, "passed" /* Passed */],
            [true, interfaces_1.ExecutionRule.NON_BLOCKING, "passed-non-blocking" /* PassedNonBlocking */],
            [false, interfaces_1.ExecutionRule.BLOCKING, "failed" /* Failed */],
            [false, interfaces_1.ExecutionRule.NON_BLOCKING, "failed-non-blocking" /* FailedNonBlocking */],
        ];
        test.each(cases)('Result passed: %s, execution rule: %s. Expected outcome: %s', (resultPassed, resultRule, expectedOutcome) => {
            jest.spyOn(utils, 'getExecutionRule').mockReturnValue(resultRule);
            jest.spyOn(utils, 'hasResultPassed').mockReturnValue(resultPassed);
            const test = fixtures_1.getApiTest('abc-def-ghi');
            const pollResult = fixtures_1.getApiPollResult('1');
            expect(utils.getResultOutcome(test, pollResult, true, true)).toEqual(expectedOutcome);
        });
    });
    describe('waitForResults', () => {
        const mockAxiosWithDefaultResult = () => {
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (r) => __awaiter(void 0, void 0, void 0, function* () {
                yield utils.wait(100);
                const results = JSON.parse(r.params.result_ids)
                    .filter((resultId) => resultId !== 'timingOutTest')
                    .map((resultId) => getPassingPollResult(resultId));
                return { data: { results } };
            })));
        };
        afterAll(() => {
            jest.clearAllMocks();
        });
        const getTestConfig = (publicId = 'abc-def-ghi') => fixtures_1.getApiTest(publicId);
        const getPassingPollResult = (resultId) => ({
            check: getTestConfig(),
            dc_id: 42,
            result: fixtures_1.getBrowserResult({ error: interfaces_1.ERRORS.TIMEOUT, passed: false }),
            resultID: resultId,
            timestamp: 0,
        });
        const getTestAndResult = (publicId = 'abc-def-ghi', resultId = '0123456789') => {
            const triggerResult = {
                device: 'laptop_large',
                location: 42,
                public_id: publicId,
                result_id: resultId,
            };
            const triggerConfig = {
                config: {},
                id: publicId,
                suite: 'Suite 1',
            };
            const passingPollResult = getPassingPollResult(resultId);
            return { passingPollResult, triggerConfig, triggerResult };
        };
        test('should poll result ids', () => __awaiter(void 0, void 0, void 0, function* () {
            mockAxiosWithDefaultResult();
            const { triggerResult, passingPollResult, triggerConfig } = getTestAndResult();
            const waitMock = jest.spyOn(utils, 'wait');
            waitMock.mockImplementation();
            const expectedResults = {};
            expectedResults[triggerResult.public_id] = [passingPollResult];
            expect(yield utils.waitForResults(api, [triggerResult], [triggerConfig], { defaultTimeout: 120000, failOnCriticalErrors: false }, fixtures_1.mockReporter)).toEqual(expectedResults);
            expect(fixtures_1.mockReporter.testResult).toHaveBeenCalledWith(triggerResult, passingPollResult);
        }));
        test('results should be timed-out if global pollingTimeout is exceeded', () => __awaiter(void 0, void 0, void 0, function* () {
            const { triggerResult } = getTestAndResult();
            const expectedResults = {};
            expectedResults[triggerResult.public_id] = [
                {
                    dc_id: triggerResult.location,
                    result: fixtures_1.getBrowserResult({
                        device: { height: 0, id: triggerResult.device, width: 0 },
                        error: interfaces_1.ERRORS.TIMEOUT,
                        passed: false,
                    }),
                    resultID: triggerResult.result_id,
                    timestamp: 0,
                },
            ];
            expect(yield utils.waitForResults(api, [triggerResult], [], { defaultTimeout: 0, failOnCriticalErrors: false }, fixtures_1.mockReporter)).toEqual(expectedResults);
        }));
        test('results should be timeout-ed if test pollingTimeout is exceeded', () => __awaiter(void 0, void 0, void 0, function* () {
            const { triggerResult } = getTestAndResult();
            const expectedResults = {};
            expectedResults[triggerResult.public_id] = [
                {
                    dc_id: triggerResult.location,
                    result: fixtures_1.getBrowserResult({
                        device: { height: 0, id: triggerResult.device, width: 0 },
                        error: interfaces_1.ERRORS.TIMEOUT,
                        passed: false,
                    }),
                    resultID: triggerResult.result_id,
                    timestamp: 0,
                },
            ];
            const testTriggerConfig = {
                config: { pollingTimeout: 0 },
                id: triggerResult.public_id,
                suite: 'Suite 1',
            };
            expect(yield utils.waitForResults(api, [triggerResult], [testTriggerConfig], { defaultTimeout: 120000, failOnCriticalErrors: false }, fixtures_1.mockReporter)).toEqual(expectedResults);
        }));
        test('correct number of pass and timeout results', () => __awaiter(void 0, void 0, void 0, function* () {
            mockAxiosWithDefaultResult();
            const { triggerResult, passingPollResult } = getTestAndResult();
            const waitMock = jest.spyOn(utils, 'wait');
            waitMock.mockImplementation();
            const expectedResults = {};
            const triggerResultPass = triggerResult;
            const triggerResultTimeOut = Object.assign(Object.assign({}, triggerResult), { result_id: 'timingOutTest' });
            expectedResults[triggerResult.public_id] = [
                passingPollResult,
                {
                    dc_id: triggerResultTimeOut.location,
                    result: fixtures_1.getBrowserResult({
                        device: { height: 0, id: triggerResultTimeOut.device, width: 0 },
                        error: interfaces_1.ERRORS.TIMEOUT,
                        passed: false,
                    }),
                    resultID: triggerResultTimeOut.result_id,
                    timestamp: 0,
                },
            ];
            expect(yield utils.waitForResults(api, [triggerResultPass, triggerResultTimeOut], [], { defaultTimeout: 2000, failOnCriticalErrors: false }, fixtures_1.mockReporter)).toEqual(expectedResults);
        }));
        test('tunnel failure', () => __awaiter(void 0, void 0, void 0, function* () {
            const waitMock = jest.spyOn(utils, 'wait');
            waitMock.mockImplementation();
            const { triggerResult } = getTestAndResult();
            // Fake pollResults to not update results and iterate until the isTunnelConnected is equal to false
            jest
                .spyOn(axios_1.default, 'create')
                .mockImplementation((() => (r) => __awaiter(void 0, void 0, void 0, function* () { return ({ data: { results: [] } }); })));
            const mockTunnel = {
                keepAlive: () => __awaiter(void 0, void 0, void 0, function* () {
                    throw new Error('keepAlive failed');
                }),
            };
            const expectedResults = {
                [triggerResult.public_id]: [
                    {
                        dc_id: triggerResult.location,
                        result: fixtures_1.getBrowserResult({
                            device: { height: 0, id: triggerResult.device, width: 0 },
                            error: interfaces_1.ERRORS.TUNNEL,
                            passed: false,
                            tunnel: true,
                        }),
                        resultID: triggerResult.result_id,
                        timestamp: 0,
                    },
                ],
            };
            expect(yield utils.waitForResults(api, [triggerResult], [], { defaultTimeout: 2000, failOnCriticalErrors: true }, fixtures_1.mockReporter, mockTunnel)).toEqual(expectedResults);
            expect(yield utils.waitForResults(api, [triggerResult], [], { defaultTimeout: 2000, failOnCriticalErrors: false }, fixtures_1.mockReporter, mockTunnel)).toEqual(expectedResults);
        }));
        test('pollResults throws', () => __awaiter(void 0, void 0, void 0, function* () {
            const { triggerResult } = getTestAndResult();
            jest.spyOn(utils, 'wait').mockImplementation();
            const axiosMock = jest.spyOn(axios_1.default, 'create');
            const serverError = new Error('Server Error');
            serverError.response = { status: 502 };
            axiosMock.mockImplementation((() => (r) => __awaiter(void 0, void 0, void 0, function* () {
                throw serverError;
            })));
            const mockTunnel = { keepAlive: () => __awaiter(void 0, void 0, void 0, function* () { return Promise.reject(); }) };
            const expectedResults = {
                [triggerResult.public_id]: [
                    {
                        dc_id: triggerResult.location,
                        result: fixtures_1.getBrowserResult({
                            device: { height: 0, id: triggerResult.device, width: 0 },
                            error: interfaces_1.ERRORS.ENDPOINT,
                            passed: false,
                            tunnel: true,
                        }),
                        resultID: triggerResult.result_id,
                        timestamp: 0,
                    },
                ],
            };
            expect(yield utils.waitForResults(api, [triggerResult], [], { defaultTimeout: 2000, failOnCriticalErrors: false }, fixtures_1.mockReporter, mockTunnel)).toEqual(expectedResults);
            yield expect(utils.waitForResults(api, [triggerResult], [], { defaultTimeout: 2000, failOnCriticalErrors: true }, fixtures_1.mockReporter, mockTunnel)).rejects.toThrow();
        }));
    });
    test('getStrictestExecutionRule', () => {
        const BLOCKING = interfaces_1.ExecutionRule.BLOCKING;
        const NON_BLOCKING = interfaces_1.ExecutionRule.NON_BLOCKING;
        const SKIPPED = interfaces_1.ExecutionRule.SKIPPED;
        expect(utils.getStrictestExecutionRule(BLOCKING, NON_BLOCKING)).toBe(NON_BLOCKING);
        expect(utils.getStrictestExecutionRule(NON_BLOCKING, BLOCKING)).toBe(NON_BLOCKING);
        expect(utils.getStrictestExecutionRule(NON_BLOCKING, SKIPPED)).toBe(SKIPPED);
        expect(utils.getStrictestExecutionRule(BLOCKING, undefined)).toBe(BLOCKING);
        expect(utils.getStrictestExecutionRule(SKIPPED, undefined)).toBe(SKIPPED);
    });
    describe('retry', () => {
        test('retry works fine', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield utils.retry(() => __awaiter(void 0, void 0, void 0, function* () { return 42; }), () => 1);
            expect(result).toBe(42);
        }));
        test('retry works fine after some retries', () => __awaiter(void 0, void 0, void 0, function* () {
            let counter = 0;
            const start = +new Date();
            const result = yield utils.retry(() => __awaiter(void 0, void 0, void 0, function* () {
                if (counter === 3) {
                    return 42;
                }
                counter += 1;
                throw new Error('');
            }), (retries) => 100 * (retries + 1));
            const end = +new Date();
            const approximateWait = 100 + 100 * 2 + 100 * 3;
            expect(result).toBe(42);
            expect(counter).toBe(3);
            expect(end - start - approximateWait < 50).toBeTruthy();
        }));
        test('retry rethrows after some retries', () => __awaiter(void 0, void 0, void 0, function* () {
            let counter = 0;
            yield expect(utils.retry(() => __awaiter(void 0, void 0, void 0, function* () {
                counter += 1;
                throw new Error('FAILURE');
            }), (retries) => {
                if (retries < 2) {
                    return 1;
                }
            })).rejects.toThrowError('FAILURE');
            expect(counter).toBe(3);
        }));
    });
    test('parseVariablesFromCli', () => {
        const mockLogFunction = (message) => undefined;
        expect(utils.parseVariablesFromCli(['TEST=42'], mockLogFunction)).toEqual({ TEST: '42' });
        expect(utils.parseVariablesFromCli(['TEST=42 with some spaces'], mockLogFunction)).toEqual({
            TEST: '42 with some spaces',
        });
        expect(utils.parseVariablesFromCli(['TEST=42=43=44'], mockLogFunction)).toEqual({ TEST: '42=43=44' });
        expect(utils.parseVariablesFromCli(['TEST='], mockLogFunction)).toEqual({ TEST: '' });
        expect(utils.parseVariablesFromCli([''], mockLogFunction)).toBeUndefined();
        expect(utils.parseVariablesFromCli(undefined, mockLogFunction)).toBeUndefined();
    });
});
//# sourceMappingURL=utils.test.js.map