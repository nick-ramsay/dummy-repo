"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunTestCommand = exports.DEFAULT_COMMAND_CONFIG = void 0;
const chalk_1 = __importDefault(require("chalk"));
const clipanion_1 = require("clipanion");
const deep_extend_1 = __importDefault(require("deep-extend"));
const utils_1 = require("../../helpers/utils");
const errors_1 = require("./errors");
const interfaces_1 = require("./interfaces");
const default_1 = require("./reporters/default");
const junit_1 = require("./reporters/junit");
const run_test_1 = require("./run-test");
const utils_2 = require("./utils");
exports.DEFAULT_COMMAND_CONFIG = {
    apiKey: '',
    appKey: '',
    configPath: 'datadog-ci.json',
    datadogSite: 'datadoghq.com',
    failOnCriticalErrors: false,
    failOnTimeout: true,
    files: ['{,!(node_modules)/**/}*.synthetics.json'],
    global: {},
    locations: [],
    pollingTimeout: 2 * 60 * 1000,
    proxy: { protocol: 'http' },
    publicIds: [],
    subdomain: 'app',
    tunnel: false,
    variableStrings: [],
};
class RunTestCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = JSON.parse(JSON.stringify(exports.DEFAULT_COMMAND_CONFIG)); // Deep copy to avoid mutation during unit tests
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const reporters = [new default_1.DefaultReporter(this)];
            this.reporter = utils_2.getReporter(reporters);
            if (this.jUnitReport) {
                reporters.push(new junit_1.JUnitReporter(this));
            }
            yield this.resolveConfig();
            const startTime = Date.now();
            if (this.config.tunnel) {
                this.reporter.log('You are using tunnel option, the chosen location(s) will be overridden by a location in your account region.\n');
            }
            let results;
            let summary;
            let tests;
            let triggers;
            try {
                ;
                ({ results, summary, tests, triggers } = yield run_test_1.executeTests(this.reporter, this.config));
            }
            catch (error) {
                if (error instanceof errors_1.CiError) {
                    this.reportCiError(error, this.reporter);
                    if (error instanceof errors_1.CriticalError) {
                        if (this.config.failOnCriticalErrors) {
                            return 1;
                        }
                        else {
                            this.reporter.error(chalk_1.default.yellow('Because `failOnCriticalErrors` is not set or disabled, the command will exit with an error code 0. ' +
                                'Use `failOnCriticalErrors: true` to exit with an error code 1.\n'));
                        }
                    }
                }
                return 0;
            }
            return this.renderResults(results, summary, tests, triggers, startTime);
        });
    }
    getAppBaseURL() {
        return `https://${this.config.subdomain}.${this.config.datadogSite}/`;
    }
    renderResults(results, summary, tests, triggers, startTime) {
        var _a, _b, _c;
        const getTest = (publicId) => tests.find((t) => t.public_id === publicId);
        const sortedPollResults = Object.entries(results)
            .reduce((accResults, [publicId, pollResults]) => accResults.concat(pollResults.map((r) => [getTest(publicId), r])), [])
            .sort(this.sortResultsByOutcome());
        // Rendering the results.
        (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.reportStart({ startTime });
        const locationNames = triggers.locations.reduce((mapping, location) => {
            mapping[location.id] = location.display_name;
            return mapping;
        }, {});
        if (!this.config.failOnTimeout) {
            if (!summary.timedOut) {
                summary.timedOut = 0;
            }
        }
        if (!this.config.failOnCriticalErrors) {
            if (!summary.criticalErrors) {
                summary.criticalErrors = 0;
            }
        }
        let hasSucceeded = true; // Determine if all the tests have succeeded
        for (const [test, pollResult] of sortedPollResults) {
            if (!this.config.failOnTimeout && pollResult.result.error === interfaces_1.ERRORS.TIMEOUT) {
                summary.timedOut++;
            }
            if (!this.config.failOnCriticalErrors && utils_2.isCriticalError(pollResult.result)) {
                summary.criticalErrors++;
            }
            const resultOutcome = utils_2.getResultOutcome(test, pollResult, this.config.failOnCriticalErrors, this.config.failOnTimeout);
            if (["passed" /* Passed */, "passed-non-blocking" /* PassedNonBlocking */].includes(resultOutcome)) {
                summary.passed++;
            }
            else if (resultOutcome === "failed-non-blocking" /* FailedNonBlocking */) {
                summary.failedNonBlocking++;
            }
            else {
                summary.failed++;
                hasSucceeded = false;
            }
            (_b = this.reporter) === null || _b === void 0 ? void 0 : _b.testEnd(test, [pollResult], this.getAppBaseURL(), locationNames, this.config.failOnCriticalErrors, this.config.failOnTimeout);
        }
        (_c = this.reporter) === null || _c === void 0 ? void 0 : _c.runEnd(summary);
        return hasSucceeded ? 0 : 1;
    }
    reportCiError(error, reporter) {
        switch (error.code) {
            // Non critical errors
            case 'NO_RESULTS_TO_POLL':
                reporter.log('No results to poll.\n');
                break;
            case 'NO_TESTS_TO_RUN':
                reporter.log('No test to run.\n');
                break;
            // Critical command errors
            case 'AUTHORIZATION_ERROR':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: authorization error ')}\n${error.message}\n\n`);
                reporter.log('Credentials refused, make sure `apiKey`, `appKey` and `datadogSite` are correct.\n');
                break;
            case 'MISSING_APP_KEY':
                reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_APP_KEY')} in your environment.\n`);
                break;
            case 'MISSING_API_KEY':
                reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_API_KEY')} in your environment.\n`);
                break;
            case 'POLL_RESULTS_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to poll test results ')}\n${error.message}\n\n`);
                break;
            case 'TUNNEL_START_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to start tunnel ')}\n${error.message}\n\n`);
                break;
            case 'TRIGGER_TESTS_FAILED':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to trigger tests ')}\n${error.message}\n\n`);
                break;
            case 'UNAVAILABLE_TEST_CONFIG':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to obtain test configurations with search query ')}\n${error.message}\n\n`);
                break;
            case 'UNAVAILABLE_TUNNEL_CONFIG':
                reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to get tunnel configuration ')}\n${error.message}\n\n`);
        }
    }
    resolveConfig() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Default < file < ENV < CLI
            // Override with file config variables
            try {
                this.config = yield utils_1.parseConfigFile(this.config, (_a = this.configPath) !== null && _a !== void 0 ? _a : this.config.configPath);
            }
            catch (error) {
                if (this.configPath) {
                    throw error;
                }
            }
            // Override with ENV variables
            this.config = deep_extend_1.default(this.config, utils_1.removeUndefinedValues({
                apiKey: process.env.DATADOG_API_KEY,
                appKey: process.env.DATADOG_APP_KEY,
                datadogSite: process.env.DATADOG_SITE,
                locations: (_b = process.env.DATADOG_SYNTHETICS_LOCATIONS) === null || _b === void 0 ? void 0 : _b.split(';'),
                subdomain: process.env.DATADOG_SUBDOMAIN,
            }));
            // Override with CLI parameters
            this.config = deep_extend_1.default(this.config, utils_1.removeUndefinedValues({
                apiKey: this.apiKey,
                appKey: this.appKey,
                configPath: this.configPath,
                datadogSite: this.datadogSite,
                failOnCriticalErrors: this.failOnCriticalErrors,
                failOnTimeout: this.failOnTimeout,
                files: this.files,
                publicIds: this.publicIds,
                subdomain: this.subdomain,
                testSearchQuery: this.testSearchQuery,
                tunnel: this.tunnel,
            }));
            // Override with Global CLI parameters
            this.config.global = deep_extend_1.default(this.config.global, utils_1.removeUndefinedValues({
                variables: utils_2.parseVariablesFromCli(this.variableStrings, (log) => { var _a; return (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.log(log); }),
            }));
            if (typeof this.config.files === 'string') {
                this.reporter.log('[DEPRECATED] "files" should be an array of string instead of a string.\n');
                this.config.files = [this.config.files];
            }
        });
    }
    /**
     * Sort results with the following rules:
     * - Passed results come first
     * - Then non-blocking failed results
     * - And finally failed results
     */
    sortResultsByOutcome() {
        const outcomeWeight = {
            ["passed-non-blocking" /* PassedNonBlocking */]: 1,
            ["passed" /* Passed */]: 2,
            ["failed-non-blocking" /* FailedNonBlocking */]: 3,
            ["failed" /* Failed */]: 4,
        };
        return ([t1, r1], [t2, r2]) => {
            const outcome1 = utils_2.getResultOutcome(t1, r1, this.config.failOnCriticalErrors, this.config.failOnTimeout);
            const outcome2 = utils_2.getResultOutcome(t2, r2, this.config.failOnCriticalErrors, this.config.failOnTimeout);
            return outcomeWeight[outcome1] - outcomeWeight[outcome2];
        };
    }
}
exports.RunTestCommand = RunTestCommand;
RunTestCommand.addPath('synthetics', 'run-tests');
RunTestCommand.addOption('apiKey', clipanion_1.Command.String('--apiKey'));
RunTestCommand.addOption('appKey', clipanion_1.Command.String('--appKey'));
RunTestCommand.addOption('configPath', clipanion_1.Command.String('--config'));
RunTestCommand.addOption('datadogSite', clipanion_1.Command.String('--datadogSite'));
RunTestCommand.addOption('failOnCriticalErrors', clipanion_1.Command.Boolean('--failOnCriticalErrors'));
RunTestCommand.addOption('failOnTimeout', clipanion_1.Command.Boolean('--failOnTimeout'));
RunTestCommand.addOption('files', clipanion_1.Command.Array('-f,--files'));
RunTestCommand.addOption('jUnitReport', clipanion_1.Command.String('-j,--jUnitReport'));
RunTestCommand.addOption('publicIds', clipanion_1.Command.Array('-p,--public-id'));
RunTestCommand.addOption('runName', clipanion_1.Command.String('-n,--runName'));
RunTestCommand.addOption('subdomain', clipanion_1.Command.Boolean('--subdomain'));
RunTestCommand.addOption('testSearchQuery', clipanion_1.Command.String('-s,--search'));
RunTestCommand.addOption('tunnel', clipanion_1.Command.Boolean('-t,--tunnel'));
RunTestCommand.addOption('variableStrings', clipanion_1.Command.Array('-v,--variable'));
//# sourceMappingURL=command.js.map