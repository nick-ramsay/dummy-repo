"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultReporter = void 0;
const chalk_1 = __importDefault(require("chalk"));
const interfaces_1 = require("../interfaces");
const utils_1 = require("../utils");
// Step rendering
const renderStepDuration = (duration) => {
    const getColor = () => {
        if (duration > 10000) {
            return chalk_1.default.bold.red;
        }
        if (duration > 5000) {
            return chalk_1.default.bold.yellow;
        }
        return chalk_1.default.bold;
    };
    const color = getColor();
    return `${color(duration.toString())}ms`;
};
const ICONS = {
    FAILED: chalk_1.default.bold.red('✖'),
    FAILED_NON_BLOCKING: chalk_1.default.bold.yellow('✖'),
    SKIPPED: chalk_1.default.bold.yellow('⇢'),
    SUCCESS: chalk_1.default.bold.green('✓'),
};
const renderStepIcon = (step) => {
    if (step.error) {
        return ICONS.FAILED;
    }
    if (step.skipped) {
        return ICONS.SKIPPED;
    }
    return ICONS.SUCCESS;
};
const renderStep = (step) => {
    const duration = renderStepDuration(step.duration);
    const icon = renderStepIcon(step);
    const value = step.value ? `\n    ${chalk_1.default.dim(step.value)}` : '';
    const error = step.error ? `\n    ${chalk_1.default.red.dim(step.error)}` : '';
    return `    ${icon} | ${duration} - ${step.description}${value}${error}`;
};
const readableOperation = {
    [interfaces_1.Operator.contains]: 'should contain',
    [interfaces_1.Operator.doesNotContain]: 'should not contain',
    [interfaces_1.Operator.is]: 'should be',
    [interfaces_1.Operator.isNot]: 'should not be',
    [interfaces_1.Operator.lessThan]: 'should be less than',
    [interfaces_1.Operator.matches]: 'should match',
    [interfaces_1.Operator.doesNotMatch]: 'should not match',
    [interfaces_1.Operator.isInLessThan]: 'will expire in less than',
    [interfaces_1.Operator.isInMoreThan]: 'will expire in more than',
    [interfaces_1.Operator.lessThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.moreThan]: 'should be more than',
    [interfaces_1.Operator.moreThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.validatesJSONPath]: 'assert on JSONPath extracted value',
    [interfaces_1.Operator.validatesXPath]: 'assert on XPath extracted value',
};
const renderApiError = (errorCode, errorMessage, color) => {
    if (errorCode === 'INCORRECT_ASSERTION') {
        try {
            const assertionsErrors = JSON.parse(errorMessage);
            const output = ['  - Assertion(s) failed:'];
            output.push(...assertionsErrors.map((error) => {
                const expected = chalk_1.default.underline(`${error.target}`);
                const actual = chalk_1.default.underline(`${error.actual}`);
                return `▶ ${error.type} ${readableOperation[error.operator]} ${expected}. Actual: ${actual}`;
            }));
            return color(output.join('\n    '));
        }
        catch (e) {
            // JSON parsing failed, do nothing to return the raw error
        }
    }
    return chalk_1.default.red(`    [${chalk_1.default.bold(errorCode)}] - ${chalk_1.default.dim(errorMessage)}`);
};
// Test execution rendering
const renderResultOutcome = (result, test, icon, color, failOnCriticalErrors, failOnTimeout) => {
    // Only display critical errors if failure is not filled.
    if (result.error && !(result.failure || result.errorMessage)) {
        return `  ${chalk_1.default.bold(`${ICONS.FAILED} | ${result.error}`)}`;
    }
    if (result.unhealthy) {
        const errorMessage = result.failure ? result.failure.message : result.errorMessage;
        const errorName = errorMessage && errorMessage !== 'Unknown error' ? errorMessage : 'General Error';
        return [
            `  ${chalk_1.default.yellow(`${ICONS.SKIPPED} | ${errorName}`)}`,
            `  ${chalk_1.default.yellow('We had an error during the execution of this test. The result will be ignored')}`,
        ].join('\n');
    }
    if (test.type === 'api') {
        const requestDescription = renderApiRequestDescription(test.subtype, test.config);
        if (result.failure || (result.errorCode && result.errorMessage)) {
            const errorCode = result.failure ? result.failure.code : result.errorCode;
            const errorMessage = result.failure ? result.failure.message : result.errorMessage;
            return [`  ${icon} ${color(requestDescription)}`, renderApiError(errorCode, errorMessage, color)].join('\n');
        }
        return `  ${icon} ${color(requestDescription)}`;
    }
    if (test.type === 'browser') {
        if (!utils_1.hasResultPassed(result, failOnCriticalErrors, failOnTimeout) && 'stepDetails' in result) {
            // We render the step only if the test hasn't passed to avoid cluttering the output.
            return result.stepDetails.map(renderStep).join('\n');
        }
        return '';
    }
};
const renderApiRequestDescription = (subType, config) => {
    const { request, steps } = config;
    if (subType === 'dns') {
        const text = `Query for ${request.host}`;
        if (request.dnsServer) {
            return `${text} on server ${request.dnsServer}`;
        }
        return text;
    }
    if (subType === 'ssl' || subType === 'tcp') {
        return `Host: ${request.host}:${request.port}`;
    }
    if (subType === 'multi' && steps) {
        const stepsDescription = Object.entries(steps
            .map((step) => step.subtype)
            .reduce((counts, type) => {
            counts[type] = (counts[type] || 0) + 1;
            return counts;
        }, {}))
            .map(([type, count]) => `${count} ${type.toUpperCase()} test`)
            .join(', ');
        return `Multistep test containing ${stepsDescription}`;
    }
    if (subType === 'http') {
        return `${chalk_1.default.bold(request.method)} - ${request.url}`;
    }
    return `${chalk_1.default.bold(subType)} test`;
};
const getResultUrl = (baseUrl, test, resultId) => {
    const ciQueryParam = 'from_ci=true';
    const testDetailUrl = `${baseUrl}synthetics/details/${test.public_id}`;
    if (test.type === 'browser') {
        return `${testDetailUrl}/result/${resultId}?${ciQueryParam}`;
    }
    return `${testDetailUrl}?resultId=${resultId}&${ciQueryParam}`;
};
const renderExecutionResult = (test, execution, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout) => {
    var _a;
    const { check: overriddenTest, dc_id, resultID, result } = execution;
    const resultOutcome = utils_1.getResultOutcome(overriddenTest !== null && overriddenTest !== void 0 ? overriddenTest : test, execution, failOnCriticalErrors, failOnTimeout);
    const [icon, setColor] = getResultIconAndColor(resultOutcome);
    const executionRule = utils_1.getExecutionRule(test, (_a = execution.enrichment) === null || _a === void 0 ? void 0 : _a.config_override);
    const executionRuleText = ["passed" /* Passed */, "passed-non-blocking" /* PassedNonBlocking */].includes(resultOutcome)
        ? ''
        : `[${setColor(executionRule === interfaces_1.ExecutionRule.BLOCKING ? 'blocking' : 'non-blocking')}] `;
    const testLabel = `${executionRuleText}[${chalk_1.default.bold.dim(test.public_id)}] ${chalk_1.default.bold(test.name)}`;
    const locationName = !!result.tunnel ? 'Tunneled' : locationNames[dc_id] || dc_id.toString();
    const location = setColor(`location: ${chalk_1.default.bold(locationName)}`);
    const device = test.type === 'browser' && 'device' in result ? ` - ${setColor(`device: ${chalk_1.default.bold(result.device.id)}`)}` : '';
    const resultIdentification = `${icon} ${testLabel} - ${location}${device}`;
    const outputLines = [resultIdentification];
    // Unhealthy test results don't have a duration or result URL
    if (!result.unhealthy) {
        const duration = utils_1.getResultDuration(result);
        const durationText = duration ? ` Total duration: ${duration} ms -` : '';
        const resultUrl = getResultUrl(baseUrl, test, resultID);
        const resultUrlStatus = result.error === interfaces_1.ERRORS.TIMEOUT ? '(not yet received)' : '';
        const resultInfo = `  ⎋${durationText} Result URL: ${chalk_1.default.dim.cyan(resultUrl)} ${resultUrlStatus}`;
        outputLines.push(resultInfo);
    }
    const resultOutcomeText = renderResultOutcome(result, overriddenTest || test, icon, setColor, failOnCriticalErrors, failOnTimeout);
    if (resultOutcomeText) {
        outputLines.push(resultOutcomeText);
    }
    return outputLines.join('\n');
};
const getResultIconAndColor = (resultOutcome) => {
    if (resultOutcome === "passed" /* Passed */ || resultOutcome === "passed-non-blocking" /* PassedNonBlocking */) {
        return [ICONS.SUCCESS, chalk_1.default.bold.green];
    }
    if (resultOutcome === "failed-non-blocking" /* FailedNonBlocking */) {
        return [ICONS.FAILED_NON_BLOCKING, chalk_1.default.bold.yellow];
    }
    return [ICONS.FAILED, chalk_1.default.bold.red];
};
class DefaultReporter {
    constructor({ context }) {
        this.write = context.stdout.write.bind(context.stdout);
    }
    error(error) {
        this.write(error);
    }
    initErrors(errors) {
        this.write(errors.join('\n') + '\n\n');
    }
    log(log) {
        this.write(log);
    }
    reportStart(timings) {
        const delay = (Date.now() - timings.startTime).toString();
        this.write(['', chalk_1.default.bold.cyan('=== REPORT ==='), `Took ${chalk_1.default.bold(delay)}ms`, '\n'].join('\n'));
    }
    runEnd(summary) {
        const { bold: b, gray, green, red, yellow } = chalk_1.default;
        const lines = [];
        const runSummary = [green(`${b(summary.passed)} passed`), red(`${b(summary.failed)} failed`)];
        if (summary.failedNonBlocking) {
            runSummary.push(yellow(`${b(summary.failedNonBlocking)} failed (non-blocking)`));
        }
        if (summary.skipped) {
            runSummary.push(`${b(summary.skipped)} skipped`);
        }
        if (summary.testsNotFound.size > 0) {
            const testsNotFoundListStr = gray(`(${[...summary.testsNotFound].join(', ')})`);
            lines.push(`${yellow(`${b(summary.testsNotFound.size)} ${pluralize('test', summary.testsNotFound.size)} not found`)} ${testsNotFoundListStr}`);
        }
        const extraInfo = [];
        if (summary.timedOut) {
            extraInfo.push(yellow(`${b(summary.timedOut)} timed out`));
        }
        if (summary.criticalErrors) {
            extraInfo.push(red(`${b(summary.criticalErrors)} critical errors`));
        }
        const extraInfoStr = extraInfo.length ? ' (' + extraInfo.join(', ') + ')' : '';
        lines.push(`${b('Run summary:')} ${runSummary.join(', ')}${extraInfoStr}\n\n`);
        this.write(lines.join('\n'));
    }
    testEnd(test, results, // Will always contain 1 result, as `testEnd` is called for each result
    baseUrl, locationNames, failOnCriticalErrors, failOnTimeout) {
        this.write(results
            .map((r) => renderExecutionResult(test, r, baseUrl, locationNames, failOnCriticalErrors, failOnTimeout))
            .join('\n\n')
            .concat('\n\n'));
    }
    testResult(response, result) {
        return;
    }
    testsWait(tests) {
        const testsList = tests.map((t) => t.public_id);
        if (testsList.length > 10) {
            testsList.splice(10);
            testsList.push('…');
        }
        const testsDisplay = chalk_1.default.gray(`(${testsList.join(', ')})`);
        this.write(`Waiting for ${chalk_1.default.bold.cyan(tests.length)} test ${pluralize('result', tests.length)} ${testsDisplay}…\n`);
    }
    testTrigger(test, testId, executionRule, config) {
        const idDisplay = `[${chalk_1.default.bold.dim(testId)}]`;
        const getMessage = () => {
            if (executionRule === interfaces_1.ExecutionRule.SKIPPED) {
                // Test is either skipped from datadog-ci config or from test config
                const isSkippedByCIConfig = config.executionRule === interfaces_1.ExecutionRule.SKIPPED;
                if (isSkippedByCIConfig) {
                    return `Skipped test "${chalk_1.default.yellow.dim(test.name)}"`;
                }
                else {
                    return `Skipped test "${chalk_1.default.yellow.dim(test.name)}" because of execution rule configuration in Datadog`;
                }
            }
            if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
                return `Found test "${chalk_1.default.green.bold(test.name)}" (non-blocking)`;
            }
            return `Found test "${chalk_1.default.green.bold(test.name)}"`;
        };
        const getConfigOverridesPart = () => {
            const nbConfigsOverridden = Object.keys(config).length;
            if (nbConfigsOverridden === 0) {
                return '';
            }
            return ' ' + chalk_1.default.gray(`(${nbConfigsOverridden} config ${pluralize('override', nbConfigsOverridden)})`);
        };
        this.write(`${idDisplay} ${getMessage()}${getConfigOverridesPart()}\n`);
    }
    testWait(test) {
        return;
    }
}
exports.DefaultReporter = DefaultReporter;
const pluralize = (word, count) => (count === 1 ? word : `${word}s`);
//# sourceMappingURL=default.js.map