"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUnitReporter = exports.getDefaultStats = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const xml2js_1 = require("xml2js");
const interfaces_1 = require("../interfaces");
const utils_1 = require("../utils");
const getDefaultStats = () => ({
    allowfailures: 0,
    errors: 0,
    failures: 0,
    skipped: 0,
    tests: 0,
    warnings: 0,
});
exports.getDefaultStats = getDefaultStats;
// Return the stats from a given object
// based on getDefaultStats
const getStats = (obj) => {
    const baseStats = exports.getDefaultStats();
    for (const entry of Object.entries(baseStats)) {
        const [key, value] = entry;
        baseStats[key] = value || baseStats[key];
    }
    return baseStats;
};
class JUnitReporter {
    constructor({ context, jUnitReport, runName }) {
        this.write = context.stdout.write.bind(context.stdout);
        this.destination = jUnitReport;
        if (!this.destination.endsWith('.xml')) {
            this.destination += '.xml';
        }
        this.builder = new xml2js_1.Builder();
        this.json = {
            testsuites: { $: { name: runName || 'Undefined run' }, testsuite: [] },
        };
    }
    runEnd() {
        return __awaiter(this, void 0, void 0, function* () {
            // Write the file
            try {
                const xml = this.builder.buildObject(this.json);
                yield fs_1.promises.mkdir(path_1.default.dirname(this.destination), { recursive: true });
                yield fs_1.promises.writeFile(this.destination, xml, 'utf8');
                this.write(`✅ Created a jUnit report at ${chalk_1.default.bold.green(this.destination)}\n`);
            }
            catch (e) {
                this.write(`❌ Couldn't write the report to ${chalk_1.default.bold.green(this.destination)}:\n${e.toString()}\n`);
            }
        });
    }
    testEnd(test, results, baseUrl, locations, failOnCriticalErrors, failOnTimeout) {
        const suiteRunName = test.suite || 'Undefined suite';
        let suiteRun = this.json.testsuites.testsuite.find((suite) => suite.$.name === suiteRunName);
        if (!suiteRun) {
            suiteRun = {
                $: Object.assign({ name: suiteRunName }, exports.getDefaultStats()),
                testcase: [],
            };
            this.json.testsuites.testsuite.push(suiteRun);
        }
        // Update stats for the suite.
        suiteRun.$ = Object.assign(Object.assign({}, suiteRun.$), this.getSuiteStats(results, getStats(suiteRun.$)));
        for (const result of results) {
            const testCase = this.getTestCase(test, result, locations, failOnCriticalErrors, failOnTimeout);
            // Timeout errors are only reported at the top level.
            if (result.result.error === interfaces_1.ERRORS.TIMEOUT) {
                testCase.error.push({
                    $: { type: 'timeout' },
                    _: result.result.error,
                });
            }
            if ('stepDetails' in result.result) {
                // It's a browser test.
                for (const stepDetail of result.result.stepDetails) {
                    const { allowed_error, browser_error, error, warning } = this.getBrowserTestStep(stepDetail);
                    testCase.allowed_error.push(...allowed_error);
                    testCase.browser_error.push(...browser_error);
                    testCase.error.push(...error);
                    testCase.warning.push(...warning);
                }
            }
            else if ('steps' in result.result) {
                // It's a multistep test.
                for (const step of result.result.steps) {
                    const { allowed_error, error } = this.getApiTestStep(step);
                    testCase.allowed_error.push(...allowed_error);
                    testCase.error.push(...error);
                }
            }
            suiteRun.testcase.push(testCase);
        }
    }
    getApiStepStats(step) {
        // TODO use more granular result based on step.assertionResults
        let allowfailures = 0;
        let skipped = 0;
        if ('allowFailure' in step) {
            allowfailures += step.allowFailure ? 1 : 0;
        }
        if ('skipped' in step) {
            skipped += step.skipped ? 1 : 0;
        }
        return {
            allowfailures,
            errors: step.passed ? 1 : 0,
            failures: step.passed ? 1 : 0,
            skipped,
            tests: 1,
            warnings: 0,
        };
    }
    getApiTestStep(step) {
        const allowedError = [];
        const error = [];
        if (step.failure) {
            const xmlError = {
                $: { type: step.failure.code, step: step.name, allowFailure: `${step.allowFailure}` },
                _: step.failure.message,
            };
            if (step.allowFailure) {
                allowedError.push(xmlError);
            }
            else {
                error.push(xmlError);
            }
        }
        return {
            allowed_error: allowedError,
            error,
        };
    }
    getBrowserStepStats(step) {
        const errors = step.browserErrors ? step.browserErrors.length : 0;
        return {
            allowfailures: step.allowFailure ? 1 : 0,
            errors: errors + (step.error ? 1 : 0),
            failures: step.error ? 1 : 0,
            skipped: step.skipped ? 1 : 0,
            tests: step.subTestStepDetails ? step.subTestStepDetails.length : 1,
            warnings: step.warnings ? step.warnings.length : 0,
        };
    }
    getBrowserTestStep(stepDetail) {
        var _a, _b;
        const allowedError = [];
        const browserError = [];
        const error = [];
        const warning = [];
        if ((_a = stepDetail.browserErrors) === null || _a === void 0 ? void 0 : _a.length) {
            browserError.push(...stepDetail.browserErrors.map((e) => ({
                $: { type: e.type, name: e.name, step: stepDetail.description },
                _: e.description,
            })));
        }
        if (stepDetail.error) {
            const xmlError = {
                $: { type: 'assertion', step: stepDetail.description, allowFailure: `${stepDetail.allowFailure}` },
                _: stepDetail.error,
            };
            if (stepDetail.allowFailure) {
                allowedError.push(xmlError);
            }
            else {
                error.push(xmlError);
            }
        }
        if ((_b = stepDetail.warnings) === null || _b === void 0 ? void 0 : _b.length) {
            warning.push(...stepDetail.warnings.map((w) => ({
                $: { type: w.type, step: stepDetail.description },
                _: w.message,
            })));
        }
        return {
            allowed_error: allowedError,
            browser_error: browserError,
            error,
            warning,
        };
    }
    getResultStats(result, stats = exports.getDefaultStats()) {
        let stepsStats = [];
        if ('stepDetails' in result.result) {
            // It's a browser test.
            stepsStats = result.result.stepDetails
                .map((step) => {
                if (!step.subTestStepDetails) {
                    return [step];
                }
                return [step, ...step.subTestStepDetails];
            })
                .reduce((acc, val) => acc.concat(val), [])
                .map(this.getBrowserStepStats);
        }
        else if ('steps' in result.result) {
            // It's an multistep API test
            stepsStats = result.result.steps.map(this.getApiStepStats);
        }
        else {
            stepsStats = [this.getApiStepStats(result.result)];
        }
        for (const stepStats of stepsStats) {
            stats.tests += stepStats.tests;
            stats.errors += stepStats.errors;
            stats.failures += stepStats.failures;
            stats.skipped += stepStats.skipped;
            stats.allowfailures += stepStats.allowfailures;
            stats.warnings += stepStats.warnings;
        }
        return stats;
    }
    getSuiteStats(results, stats = exports.getDefaultStats()) {
        for (const result of results) {
            stats = this.getResultStats(result, stats);
        }
        return stats;
    }
    getTestCase(test, result, locations, failOnCriticalErrors, failOnTimeout) {
        var _a;
        const timeout = result.result.error === interfaces_1.ERRORS.TIMEOUT;
        const resultOutcome = utils_1.getResultOutcome(test, result, failOnCriticalErrors, failOnTimeout);
        const passed = ["passed" /* Passed */, "passed-non-blocking" /* PassedNonBlocking */].includes(resultOutcome);
        return {
            $: Object.assign({ name: test.name, time: utils_1.getResultDuration(result.result) / 1000, timestamp: new Date(result.timestamp).toISOString() }, this.getResultStats(result)),
            allowed_error: [],
            browser_error: [],
            error: [],
            properties: {
                property: [
                    { $: { name: 'check_id', value: result.check_id } },
                    ...('device' in result.result
                        ? [
                            { $: { name: 'device', value: result.result.device.id } },
                            { $: { name: 'width', value: result.result.device.width } },
                            { $: { name: 'height', value: result.result.device.height } },
                        ]
                        : []),
                    { $: { name: 'execution_rule', value: (_a = test.options.ci) === null || _a === void 0 ? void 0 : _a.executionRule } },
                    { $: { name: 'location', value: locations[result.dc_id] } },
                    { $: { name: 'message', value: test.message } },
                    { $: { name: 'monitor_id', value: test.monitor_id } },
                    { $: { name: 'passed', value: `${passed}` } },
                    { $: { name: 'public_id', value: test.public_id } },
                    { $: { name: 'result_id', value: result.resultID } },
                    ...('startUrl' in result.result ? [{ $: { name: 'start_url', value: result.result.startUrl } }] : []),
                    { $: { name: 'status', value: test.status } },
                    { $: { name: 'tags', value: test.tags.join(',') } },
                    { $: { name: 'timeout', value: `${timeout}` } },
                    { $: { name: 'type', value: test.type } },
                ].filter((prop) => prop.$.value),
            },
            testcase: [],
            warning: [],
        };
    }
}
exports.JUnitReporter = JUnitReporter;
//# sourceMappingURL=junit.js.map