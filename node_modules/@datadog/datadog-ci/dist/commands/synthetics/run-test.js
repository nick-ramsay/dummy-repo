"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDatadogHost = exports.getApiHelper = exports.getTestsList = exports.executeTests = void 0;
const api_1 = require("./api");
const errors_1 = require("./errors");
const tunnel_1 = require("./tunnel");
const utils_1 = require("./utils");
const executeTests = (reporter, config, suites) => __awaiter(void 0, void 0, void 0, function* () {
    const api = exports.getApiHelper(config);
    const publicIdsFromCli = config.publicIds.map((id) => ({ config: config.global, id }));
    let testsToTrigger;
    let tunnel;
    const stopTunnel = () => __awaiter(void 0, void 0, void 0, function* () {
        if (tunnel) {
            yield tunnel.stop();
        }
    });
    if (publicIdsFromCli.length) {
        testsToTrigger = publicIdsFromCli;
    }
    else {
        try {
            testsToTrigger = yield exports.getTestsList(api, config, reporter, suites);
        }
        catch (error) {
            throw new errors_1.CriticalError(api_1.isForbiddenError(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
        }
    }
    if (!testsToTrigger.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    let testsToTriggerResult;
    try {
        testsToTriggerResult = yield utils_1.getTestsToTrigger(api, testsToTrigger, reporter);
    }
    catch (error) {
        if (error instanceof errors_1.CiError) {
            throw error;
        }
        throw new errors_1.CriticalError(api_1.isForbiddenError(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
    }
    const { tests, overriddenTestsToTrigger, summary } = testsToTriggerResult;
    // All tests have been skipped or are missing.
    if (!tests.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    const publicIdsToTrigger = tests.map(({ public_id }) => public_id);
    if (config.tunnel) {
        let presignedURL;
        try {
            // Get the pre-signed URL to connect to the tunnel service
            presignedURL = (yield api.getPresignedURL(publicIdsToTrigger)).url;
        }
        catch (error) {
            throw new errors_1.CriticalError('UNAVAILABLE_TUNNEL_CONFIG', error.message);
        }
        // Open a tunnel to Datadog
        try {
            tunnel = new tunnel_1.Tunnel(presignedURL, publicIdsToTrigger, config.proxy, reporter);
            const tunnelInfo = yield tunnel.start();
            overriddenTestsToTrigger.forEach((testToTrigger) => {
                testToTrigger.tunnel = tunnelInfo;
            });
        }
        catch (error) {
            yield stopTunnel();
            throw new errors_1.CriticalError('TUNNEL_START_FAILED', error.message);
        }
    }
    let triggers;
    try {
        triggers = yield utils_1.runTests(api, overriddenTestsToTrigger);
    }
    catch (error) {
        yield stopTunnel();
        throw new errors_1.CriticalError('TRIGGER_TESTS_FAILED', error.message);
    }
    if (!triggers.results) {
        yield stopTunnel();
        throw new errors_1.CiError('NO_RESULTS_TO_POLL');
    }
    const results = {};
    try {
        // Poll the results.
        const resultPolled = yield utils_1.waitForResults(api, triggers.results, testsToTrigger, { defaultTimeout: config.pollingTimeout, failOnCriticalErrors: config.failOnCriticalErrors }, reporter, tunnel);
        Object.assign(results, resultPolled);
    }
    catch (error) {
        throw new errors_1.CriticalError('POLL_RESULTS_FAILED', error.message);
    }
    finally {
        yield stopTunnel();
    }
    return { results, summary, tests, triggers };
});
exports.executeTests = executeTests;
const getTestsList = (api, config, reporter, suites = []) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // If "testSearchQuery" is provided, always default to running it.
    if (config.testSearchQuery) {
        const testSearchResults = yield api.searchTests(config.testSearchQuery);
        return testSearchResults.tests.map((test) => ({
            config: config.global,
            id: test.public_id,
            suite: `Query: ${config.testSearchQuery}`,
        }));
    }
    const suitesFromFiles = (yield Promise.all(config.files.map((glob) => utils_1.getSuites(glob, reporter))))
        .reduce((acc, val) => acc.concat(val), [])
        .filter((suite) => !!suite.content.tests);
    suites.push(...suitesFromFiles);
    const configFromEnvironment = ((_a = config.locations) === null || _a === void 0 ? void 0 : _a.length) ? { locations: config.locations } : {};
    const testsToTrigger = suites
        .map((suite) => suite.content.tests.map((test) => ({
        config: Object.assign(Object.assign(Object.assign({}, config.global), configFromEnvironment), test.config),
        id: test.id,
        suite: suite.name,
    })))
        .reduce((acc, suiteTests) => acc.concat(suiteTests), []);
    return testsToTrigger;
});
exports.getTestsList = getTestsList;
const getApiHelper = (config) => {
    if (!config.appKey) {
        throw new errors_1.CriticalError('MISSING_APP_KEY');
    }
    if (!config.apiKey) {
        throw new errors_1.CriticalError('MISSING_API_KEY');
    }
    return api_1.apiConstructor({
        apiKey: config.apiKey,
        appKey: config.appKey,
        baseIntakeUrl: exports.getDatadogHost(true, config),
        baseUrl: exports.getDatadogHost(false, config),
        proxyOpts: config.proxy,
    });
};
exports.getApiHelper = getApiHelper;
const getDatadogHost = (useIntake = false, config) => {
    const apiPath = 'api/v1';
    let host = `https://api.${config.datadogSite}`;
    const hostOverride = process.env.DD_API_HOST_OVERRIDE;
    if (hostOverride) {
        host = hostOverride;
    }
    else if (useIntake && (config.datadogSite === 'datadoghq.com' || config.datadogSite === 'datad0g.com')) {
        host = `https://intake.synthetics.${config.datadogSite}`;
    }
    return `${host}/${apiPath}`;
};
exports.getDatadogHost = getDatadogHost;
//# sourceMappingURL=run-test.js.map