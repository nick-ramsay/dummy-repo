"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tunnel = void 0;
const crypto_1 = require("crypto");
const net_1 = require("net");
const stream_1 = require("stream");
const chalk_1 = __importDefault(require("chalk"));
const ssh2_1 = require("ssh2");
const yamux_js_1 = require("yamux-js");
// tslint:disable-next-line:no-var-requires - SW-1310
const { KexInit } = require('ssh2/lib/protocol/kex');
// tslint:disable-next-line:no-var-requires - SW-1310
const SSH_CONSTANTS = require('ssh2/lib/protocol/constants');
const crypto_2 = require("./crypto");
const websocket_1 = require("./websocket");
class Tunnel {
    constructor(url, testIDs, proxy, reporter) {
        this.url = url;
        this.testIDs = testIDs;
        this.connected = false;
        this.forwardedSockets = new Set();
        this.FORWARDING_TIMEOUT = 40000;
        this.log = (message) => reporter.log(`[${chalk_1.default.bold.blue('Tunnel')}] ${message}\n`);
        this.logError = (message) => reporter.error(`[${chalk_1.default.bold.red('Tunnel')}] ${message}\n`);
        this.logWarning = (message) => reporter.log(`[${chalk_1.default.bold.yellow('Tunnel')}] ${message}\n`);
        // Setup SSH
        const { privateKey: hostPrivateKey } = crypto_2.generateOpenSSHKeys();
        const parsedHostPrivateKey = crypto_2.parseSSHKey(hostPrivateKey);
        const { publicKey, privateKey } = crypto_2.generateOpenSSHKeys();
        this.publicKey = crypto_2.parseSSHKey(publicKey);
        this.privateKey = privateKey;
        this.sshConfig = {
            algorithms: {
                serverHostKey: [parsedHostPrivateKey.type],
            },
            // Greatly increase highWaterMark (32kb -> 255kb) to avoid hanging with large requests
            highWaterMark: 255 * 1024,
            hostKeys: [hostPrivateKey],
        };
        this.ws = new websocket_1.WebSocket(this.url, proxy);
    }
    /**
     * keepAlive will return a promise that tracks the state of the tunnel (and reject in case of error)
     */
    keepAlive() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ws || !this.ws.keepAlive()) {
                throw new Error('No WebSocket connection');
            }
            return this.ws.keepAlive();
        });
    }
    /**
     * start the tunnel:
     *   - get the pre-signed URL to connect to the tunnel service
     *   - Set up SSH
     *   - establish a WebSocket connection to the tunnel service
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.log(`Opening tunnel for ${chalk_1.default.bold.dim(...this.testIDs)}…`);
            this.log('Generating encryption key, setting up SSH and opening WebSocket connection…');
            try {
                // Establish a WebSocket connection to the tunnel service
                yield this.ws.connect();
                // @todo: in case of reconnect, add tunnel ID to WebSocket URL to re-use the same tunnel (in the tunnel service)
                const connectionInfo = yield this.forwardWebSocketToSSH();
                return connectionInfo;
            }
            catch (err) {
                this.logError('Tunnel setup failed, cleaning up and exiting…');
                yield this.stop(); // Clean up
                throw err;
            }
        });
    }
    /**
     * stop the tunnel
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.log('Shutting down tunnel…');
            this.forwardedSockets.forEach((socket) => {
                if (!!socket) {
                    socket.destroy();
                }
            });
            if (this.multiplexer) {
                this.multiplexer.close();
            }
            yield this.ws.close();
        });
    }
    // Authenticate SSH with key authentication - username should be the test ID
    authenticateSSHConnection(ctx) {
        const allowedUsers = this.testIDs.map((testId) => Buffer.from(testId));
        // Ensure username is allowed
        const user = Buffer.from(ctx.username);
        if (!allowedUsers.some((allowedUser) => user.length === allowedUser.length && crypto_1.timingSafeEqual(user, allowedUser))) {
            return ctx.reject();
        }
        // Only allow key authentication
        if (ctx.method !== 'publickey') {
            return ctx.reject();
        }
        const allowedPubSSHKey = Buffer.from(this.publicKey.getPublicSSH());
        if (ctx.key.algo !== this.publicKey.type ||
            ctx.key.data.length !== allowedPubSSHKey.length ||
            !crypto_1.timingSafeEqual(ctx.key.data, allowedPubSSHKey) ||
            (ctx.signature && this.publicKey.verify(ctx.blob, ctx.signature) !== true)) {
            // Invalid key authentication
            return ctx.reject();
        }
        // A connection without a signature is only to check for public key validity
        if (!ctx.signature) {
            return ctx.accept();
        }
        // Username is allowed and key authentication was successful
        if (!this.connected) {
            // Limit to one log per tunnel
            this.connected = true;
            this.log('Successfully connected');
        }
        ctx.accept();
    }
    forwardProxiedPacketsFromSSH(client) {
        client
            .on('session', (accept) => {
            accept().on('close', () => {
                client.end();
            });
        })
            .on('tcpip', (accept, reject, { destIP, destPort }) => {
            // Forward packets
            // See https://github.com/mscdex/ssh2/issues/479#issuecomment-250416559
            let src;
            const dest = new net_1.Socket();
            dest.setTimeout(this.FORWARDING_TIMEOUT);
            this.forwardedSockets.add(dest);
            dest.on('timeout', () => {
                this.logWarning(`Connection timeout (${destIP})`);
                if (src) {
                    src.destroy();
                }
                else {
                    reject();
                }
                this.forwardedSockets.delete(dest);
                dest.end();
                dest.destroy();
            });
            dest.on('connect', () => {
                src = accept();
                if (!src) {
                    return dest.end();
                }
                stream_1.pipeline([dest, src], () => this.forwardedSockets.delete(dest));
                stream_1.pipeline([src, dest], () => this.forwardedSockets.delete(dest));
                src.on('close', () => {
                    dest.end();
                    dest.destroy();
                });
            });
            dest.on('error', (error) => {
                if (src) {
                    this.logWarning(`Error on opened connection (${destIP}): ${error.code}`);
                    src.close();
                }
                else {
                    if ('code' in error && error.code === 'ENOTFOUND') {
                        this.logWarning(`Unable to resolve host (${destIP})`);
                    }
                    else {
                        this.logWarning(`Connection error (${destIP}): ${error.code}`);
                    }
                    reject();
                    this.forwardedSockets.delete(dest);
                    dest.end();
                    dest.destroy();
                }
            });
            dest.on('close', () => {
                if (src) {
                    src.close();
                }
                else {
                    reject();
                }
                this.forwardedSockets.delete(dest);
            });
            dest.connect(destPort, destIP);
        })
            .on('request', (accept, reject, name, info) => {
            if (accept) {
                accept();
            }
        });
    }
    forwardWebSocketToSSH() {
        return __awaiter(this, void 0, void 0, function* () {
            const connectionInfo = yield this.getConnectionInfo();
            this.log(`Websocket connection to tunnel ${connectionInfo.id} opened, proxy is ready!`);
            // Stop any existing multiplexing
            if (this.multiplexer) {
                this.multiplexer.close();
            }
            // Set up multiplexing
            const multiplexerConfig = {
                // Increase maximum backlog size to more easily handle
                // running multiple large browser tests in parallel.
                acceptBacklog: 2048,
                enableKeepAlive: false,
            };
            this.multiplexer = new yamux_js_1.Server((stream) => {
                stream.on('error', (error) => {
                    this.logError(`Error in multiplexing: ${error}`);
                });
                this.processSSHStream(stream);
            }, multiplexerConfig);
            // Pipe WebSocket to multiplexing
            const duplex = this.ws.duplex();
            this.multiplexer.on('error', (error) => this.logError(`Multiplexer error: ${error.message}`));
            duplex.on('error', (error) => this.logError(`Websocket error: ${error.message}`));
            stream_1.pipeline([duplex, this.multiplexer], (err) => {
                if (err) {
                    this.logWarning(`Error on duplex connection close: ${err}`);
                }
            });
            stream_1.pipeline([this.multiplexer, duplex], (err) => {
                if (err) {
                    this.logWarning(`Error on Multiplexer connection close: ${err}`);
                }
            });
            return connectionInfo;
        });
    }
    getConnectionInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const rawConnectionInfo = yield this.ws.waitForFirstMessage();
            try {
                const connectionInfo = Object.assign({ privateKey: this.privateKey }, JSON.parse(rawConnectionInfo.toString()));
                return connectionInfo;
            }
            catch (_a) {
                throw new Error(`Unexpected response from tunnel service: ${rawConnectionInfo.toString()}\n`);
            }
        });
    }
    processSSHStream(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            // Process SSH stream - see https://github.com/mscdex/ssh2/blob/v0.8.x/lib/server.js#L24
            const serverConfig = Object.assign(Object.assign({}, this.sshConfig), { keepaliveInterval: 0 });
            ssh2_1.Server.KEEPALIVE_CLIENT_INTERVAL = 0;
            const server = new ssh2_1.Server(serverConfig, () => {
                // 'connection' event listener is required otherwise connection wont proceed.
            });
            const { ident } = this.sshConfig;
            const hostKeys = { 'ecdsa-sha2-nistp256': crypto_2.parseSSHKey(this.sshConfig.hostKeys[0]) };
            const encryptionConfig = {
                cipher: SSH_CONSTANTS.DEFAULT_CIPHER,
                compress: SSH_CONSTANTS.DEFAULT_COMPRESSION,
                lang: [],
                mac: SSH_CONSTANTS.DEFAULT_MAC,
            };
            const algorithms = {
                cs: encryptionConfig,
                kex: SSH_CONSTANTS.DEFAULT_KEX,
                sc: encryptionConfig,
                serverHostKey: ['ecdsa-sha2-nistp256'],
            };
            const offer = new KexInit(algorithms);
            const clientConfig = Object.assign(Object.assign({}, this.sshConfig), { keepaliveInterval: 0 });
            // SW-1310: Typing does not include IncomingClient
            const client = new ssh2_1.Server.IncomingClient(stream, hostKeys, ident, offer, undefined, server, clientConfig);
            client
                .on('authentication', (ctx) => this.authenticateSSHConnection(ctx))
                .on('ready', () => this.forwardProxiedPacketsFromSSH(client))
                .on('close', () => {
                server.close();
            })
                .on('error', (err) => {
                this.logError(`SSH error in proxy: ${err.message}`);
            });
        });
    }
}
exports.Tunnel = Tunnel;
//# sourceMappingURL=tunnel.js.map