"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const advanced_1 = require("clipanion/lib/advanced");
const tag_1 = require("../tag");
const makeCLI = () => {
    const cli = new advanced_1.Cli();
    cli.register(tag_1.TagCommand);
    return cli;
};
const createMockContext = () => {
    let out = '';
    let err = '';
    return {
        stderr: {
            toString: () => err,
            write: (input) => {
                err += input;
            },
        },
        stdout: {
            toString: () => out,
            write: (input) => {
                out += input;
            },
        },
    };
};
describe('execute', () => {
    const runCLI = (level, tags, env) => __awaiter(void 0, void 0, void 0, function* () {
        const cli = makeCLI();
        const context = createMockContext();
        process.env = Object.assign({ DATADOG_API_KEY: 'PLACEHOLDER' }, env);
        const tagsList = [];
        tags.forEach((t) => {
            tagsList.push('--tags');
            tagsList.push(t);
        });
        const code = yield cli.run(['tag', '--level', level, ...tagsList], context);
        return { context, code };
    });
    test('should fail if an invalid level given', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('stage', ['key:value'], { BUILDKITE: 'true', BUILDKITE_BUILD_ID: 'id' });
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Level must be one of [pipeline, job]');
    }));
    test('should fail if no tags provided', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('pipeline', [], {});
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('DD_TAGS environment variable or --tags command line argument is required');
    }));
    test('should fail if not running in a supported provider', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('pipeline', ['key:value'], {});
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Only providers [GitHub, GitLab, CircleCI, Buildkite] are supported');
    }));
    test('should fail if provider is GitHub and level is job', () => __awaiter(void 0, void 0, void 0, function* () {
        const { context, code } = yield runCLI('job', ['key:value'], { GITHUB_ACTIONS: 'true', GITHUB_RUN_ID: '40' });
        expect(code).toBe(1);
        expect(context.stderr.toString()).toContain('Cannot use level "job" for GitHub Actions.');
    }));
});
//# sourceMappingURL=tag.test.js.map