"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const clipanion_1 = require("clipanion");
const crypto_1 = __importDefault(require("crypto"));
const os_1 = __importDefault(require("os"));
const retry_1 = require("../../helpers/retry");
const tags_1 = require("../../helpers/tags");
const api_1 = require("./api");
const interfaces_1 = require("./interfaces");
// We use 127 as exit code for invalid commands since that is what *sh terminals return
const BAD_COMMAND_EXIT_CODE = 127;
class TraceCommand extends clipanion_1.Command {
    constructor() {
        super(...arguments);
        this.config = {
            apiKey: process.env.DATADOG_API_KEY || process.env.DD_API_KEY,
            envVarTags: process.env.DD_TAGS,
        };
    }
    execute() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.command || !this.command.length) {
                this.context.stderr.write('Missing command to run\n');
                return 1;
            }
            const [command, ...args] = this.command;
            const id = crypto_1.default.randomBytes(5).toString('hex');
            const startTime = new Date().toISOString();
            const childProcess = child_process_1.spawn(command, args, {
                env: Object.assign(Object.assign({}, process.env), { DD_CUSTOM_PARENT_ID: id }),
                stdio: ['inherit', 'inherit', 'pipe'],
            });
            const chunks = [];
            childProcess.stderr.pipe(this.context.stderr);
            const stderrCatcher = new Promise((resolve, reject) => {
                childProcess.stderr.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
                childProcess.stderr.on('error', (err) => reject(err));
                childProcess.stderr.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
            });
            const [status, signal] = yield new Promise((resolve, reject) => {
                childProcess.on('error', (error) => {
                    reject(error);
                });
                childProcess.on('close', (exitStatus, exitSignal) => {
                    resolve([exitStatus, exitSignal]);
                });
            });
            const stderr = yield stderrCatcher;
            const endTime = new Date().toISOString();
            const exitCode = (_a = status !== null && status !== void 0 ? status : this.signalToNumber(signal)) !== null && _a !== void 0 ? _a : BAD_COMMAND_EXIT_CODE;
            const [ciEnvVars, provider] = this.getCIEnvVars();
            if (provider) {
                const commandStr = this.command.join(' ');
                const envVarTags = this.config.envVarTags ? tags_1.parseTags(this.config.envVarTags.split(',')) : {};
                const cliTags = this.tags ? tags_1.parseTags(this.tags) : {};
                yield this.reportCustomSpan({
                    command: commandStr,
                    custom: {
                        id,
                        parent_id: process.env.DD_CUSTOM_PARENT_ID,
                    },
                    data: ciEnvVars,
                    end_time: endTime,
                    error_message: stderr,
                    exit_code: exitCode,
                    is_error: exitCode !== 0,
                    name: (_b = this.name) !== null && _b !== void 0 ? _b : commandStr,
                    start_time: startTime,
                    tags: Object.assign(Object.assign({}, cliTags), envVarTags),
                }, provider);
            }
            return exitCode;
        });
    }
    getCIEnvVars() {
        if (process.env.CIRCLECI) {
            return [
                this.getEnvironmentVars([
                    'CIRCLE_BRANCH',
                    'CIRCLE_BUILD_NUM',
                    'CIRCLE_BUILD_URL',
                    'CIRCLE_JOB',
                    'CIRCLE_NODE_INDEX',
                    'CIRCLE_NODE_TOTAL',
                    'CIRCLE_PROJECT_REPONAME',
                    'CIRCLE_PULL_REQUEST',
                    'CIRCLE_REPOSITORY_URL',
                    'CIRCLE_SHA1',
                    'CIRCLE_TAG',
                    'CIRCLE_WORKFLOW_ID',
                ]),
                interfaces_1.CIRCLECI,
            ];
        }
        if (process.env.JENKINS_HOME) {
            if (!process.env.DD_CUSTOM_TRACE_ID) {
                this.context.stdout.write(`${chalk_1.default.yellow.bold('[WARNING]')} Your Jenkins instance does not seem to be instrumented with the DataDog plugin.\n`);
                this.context.stdout.write('Please follow the instructions at https://docs.datadoghq.com/continuous_integration/setup_pipelines/jenkins/\n');
                return [{}];
            }
            return [
                this.getEnvironmentVars([
                    'BUILD_ID',
                    'BUILD_NUMBER',
                    'BUILD_TAG',
                    'BUILD_URL',
                    'DD_CUSTOM_TRACE_ID',
                    'EXECUTOR_NUMBER',
                    'GIT_AUTHOR_EMAIL',
                    'GIT_AUTHOR_NAME',
                    'GIT_BRANCH',
                    'GIT_COMMIT',
                    'GIT_COMMITTER_EMAIL',
                    'GIT_COMMITTER_NAME',
                    'GIT_URL',
                    'GIT_URL_1',
                    'JENKINS_URL',
                    'JOB_BASE_NAME',
                    'JOB_NAME',
                    'JOB_URL',
                    'NODE_NAME',
                    'NODE_LABELS',
                    'WORKSPACE',
                ]),
                interfaces_1.JENKINS,
            ];
        }
        const errorMsg = `Cannot detect any supported CI Provider. This command only works if run as part of your CI. Supported providers: ${interfaces_1.SUPPORTED_PROVIDERS}.`;
        if (this.noFail) {
            this.context.stdout.write(`${chalk_1.default.yellow.bold('[WARNING]')} ${errorMsg} Not failing since the --no-fail options was used.\n`);
            return [{}];
        }
        else {
            throw new Error(errorMsg);
        }
    }
    getApiHelper() {
        if (!this.config.apiKey) {
            this.context.stdout.write(`Neither ${chalk_1.default.red.bold('DATADOG_API_KEY')} nor ${chalk_1.default.red.bold('DD_API_KEY')} is in your environment.\n`);
            throw new Error('API key is missing');
        }
        return api_1.apiConstructor(this.getBaseIntakeUrl(), this.config.apiKey);
    }
    getBaseIntakeUrl() {
        const site = process.env.DATADOG_SITE || process.env.DD_SITE || 'datadoghq.com';
        return `https://webhook-intake.${site}`;
    }
    getEnvironmentVars(keys) {
        return keys.filter((key) => key in process.env).reduce((accum, key) => (Object.assign(Object.assign({}, accum), { [key]: process.env[key] })), {});
    }
    reportCustomSpan(payload, provider) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = this.getApiHelper();
            try {
                yield retry_1.retryRequest(() => api.reportCustomSpan(payload, provider), {
                    onRetry: (e, attempt) => {
                        this.context.stderr.write(chalk_1.default.yellow(`[attempt ${attempt}] Could not report custom span. Retrying...: ${e.message}\n`));
                    },
                    retries: 5,
                });
            }
            catch (error) {
                this.context.stderr.write(chalk_1.default.red(`Failed to report custom span: ${error.message}\n`));
            }
        });
    }
    signalToNumber(signal) {
        if (!signal) {
            return undefined;
        }
        return os_1.default.constants.signals[signal] + 128;
    }
}
exports.TraceCommand = TraceCommand;
TraceCommand.usage = clipanion_1.Command.Usage({
    description: 'Trace a command with a custom span and report it to Datadog.',
    details: `
            This command wraps another command, which it will launch, and report a custom span to Datadog.
            See README for details.
        `,
    examples: [
        [
            'Trace a command with name "Say Hello" and report to Datadog',
            'datadog-ci trace --name "Say Hello" -- echo "Hello World"',
        ],
        [
            'Trace a command with name "Say Hello" and a extra tags and report to Datadog',
            'datadog-ci trace --name "Say Hello" --tags key1:value1 --tags key2:value2 -- echo "Hello World"',
        ],
        [
            'Trace a command and report to the datadoghq.eu site',
            'DATADOG_SITE=datadoghq.eu datadog-ci trace -- echo "Hello World"',
        ],
    ],
});
TraceCommand.addPath('trace');
TraceCommand.addOption('noFail', clipanion_1.Command.Boolean('--no-fail'));
TraceCommand.addOption('name', clipanion_1.Command.String('--name'));
TraceCommand.addOption('tags', clipanion_1.Command.Array('--tags'));
TraceCommand.addOption('command', clipanion_1.Command.Rest({ required: 1 }));
//# sourceMappingURL=trace.js.map