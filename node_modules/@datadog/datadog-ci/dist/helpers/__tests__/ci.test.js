"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ci_1 = require("../ci");
const user_provided_git_1 = require("../user-provided-git");
const CI_PROVIDERS = fs_1.default.readdirSync(path_1.default.join(__dirname, 'ci-env'));
const ciAppTagsToMetadata = (tags) => {
    const metadata = {
        ci: { job: {}, pipeline: {}, provider: {}, stage: {} },
        git: { commit: { author: {}, committer: {} } },
    };
    Object.entries(tags).forEach(([tag, value]) => {
        // Ignore JSON fixtures pipeline number that can't be parsed to numbers
        if (!value || tag === 'ci.pipeline.number') {
            return;
        }
        // Get Metadata nested property from tag name ('git.commit.author.name')
        let currentAttr = metadata;
        // Current attribute up to second to last
        const properties = tag.split('.');
        for (let i = 0; i < properties.length - 1; i++) {
            currentAttr = currentAttr[properties[i]];
        }
        const attributeName = properties[properties.length - 1];
        currentAttr[attributeName] = value;
    });
    return metadata;
};
const ddMetadataToSpanTags = (ddMetadata) => {
    const spanTags = {};
    Object.entries(ddMetadata).map(([key, value]) => {
        let tagKey = key.split('_').slice(1).join('.').toLocaleLowerCase(); // Split and remove DD prefix
        if (tagKey === 'git.repository.url') {
            tagKey = 'git.repository_url';
        }
        else if (tagKey === 'ci.workspace.path') {
            tagKey = 'ci.workspace_path';
        }
        spanTags[tagKey] = value;
    });
    return spanTags;
};
describe('getCIMetadata', () => {
    test('non-recognized CI returns undefined', () => {
        process.env = {};
        expect(ci_1.getCIMetadata()).toBeUndefined();
    });
    test('pipeline number is parsed to int or ignored', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        process.env = { GITLAB_CI: 'gitlab' };
        process.env.CI_PIPELINE_IID = '0';
        expect((_a = ci_1.getCIMetadata()) === null || _a === void 0 ? void 0 : _a.ci.pipeline.number).toBe(0);
        process.env.CI_PIPELINE_IID = ' \n\r 12345 \n\n ';
        expect((_b = ci_1.getCIMetadata()) === null || _b === void 0 ? void 0 : _b.ci.pipeline.number).toBe(12345);
        process.env.CI_PIPELINE_IID = '123.45';
        expect((_c = ci_1.getCIMetadata()) === null || _c === void 0 ? void 0 : _c.ci.pipeline.number).toBe(123);
        process.env.CI_PIPELINE_IID = '999b';
        expect((_d = ci_1.getCIMetadata()) === null || _d === void 0 ? void 0 : _d.ci.pipeline.number).toBe(999);
        process.env.CI_PIPELINE_IID = '-1';
        expect((_e = ci_1.getCIMetadata()) === null || _e === void 0 ? void 0 : _e.ci.pipeline.number).toBe(-1);
        process.env.CI_PIPELINE_IID = '';
        expect((_f = ci_1.getCIMetadata()) === null || _f === void 0 ? void 0 : _f.ci.pipeline.number).toBeUndefined();
        process.env.CI_PIPELINE_IID = 'not a number';
        expect((_g = ci_1.getCIMetadata()) === null || _g === void 0 ? void 0 : _g.ci.pipeline.number).toBeUndefined();
        process.env.CI_PIPELINE_IID = '$1';
        expect((_h = ci_1.getCIMetadata()) === null || _h === void 0 ? void 0 : _h.ci.pipeline.number).toBeUndefined();
    });
    test('tags are properly truncated when required', () => {
        var _a, _b, _c, _d;
        const bigString = ''.padEnd(1600, 'a');
        process.env = { GITLAB_CI: 'gitlab' };
        process.env.CI_COMMIT_MESSAGE = bigString;
        process.env.CI_COMMIT_TAG = bigString;
        expect((_a = ci_1.getCIMetadata()) === null || _a === void 0 ? void 0 : _a.git.commit.message).toBe(bigString);
        expect((_b = ci_1.getCIMetadata()) === null || _b === void 0 ? void 0 : _b.git.tag).toBe(bigString);
        const tagSizeLimits = {
            'git.commit.message': 500,
        };
        expect((_c = ci_1.getCIMetadata(tagSizeLimits)) === null || _c === void 0 ? void 0 : _c.git.commit.message).toBe(bigString.substring(0, 500));
        expect((_d = ci_1.getCIMetadata(tagSizeLimits)) === null || _d === void 0 ? void 0 : _d.git.tag).toBe(bigString);
    });
    describe.each(CI_PROVIDERS)('%s', (ciProvider) => {
        const assertions = require(path_1.default.join(__dirname, 'ci-env', ciProvider));
        test.each(assertions)('spec %#', (env, tags) => {
            process.env = env;
            const expectedMetadata = ciAppTagsToMetadata(tags);
            expect(ci_1.getCIMetadata()).toEqual(expectedMetadata);
        });
    });
    describe.each(CI_PROVIDERS)('Ensure DD env variables override %s env variables', (ciProvider) => {
        const DD_METADATA = {
            DD_CI_JOB_NAME: 'DD_CI_JOB_NAME',
            DD_CI_JOB_URL: 'DD_CI_JOB_URL',
            DD_CI_PIPELINE_ID: 'DD_CI_PIPELINE_ID',
            DD_CI_PIPELINE_NAME: 'DD_CI_PIPELINE_NAME',
            DD_CI_PIPELINE_NUMBER: 'DD_CI_PIPELINE_NUMBER',
            DD_CI_PIPELINE_URL: 'DD_CI_PIPELINE_URL',
            DD_CI_PROVIDER_NAME: 'DD_CI_PROVIDER_NAME',
            DD_CI_STAGE_NAME: 'DD_CI_STAGE_NAME',
            DD_CI_WORKSPACE_PATH: 'DD_CI_WORKSPACE_PATH',
            DD_GIT_BRANCH: 'DD_GIT_BRANCH',
            DD_GIT_COMMIT_AUTHOR_DATE: 'DD_GIT_COMMIT_AUTHOR_DATE',
            DD_GIT_COMMIT_AUTHOR_EMAIL: 'DD_GIT_COMMIT_AUTHOR_EMAIL',
            DD_GIT_COMMIT_AUTHOR_NAME: 'DD_GIT_COMMIT_AUTHOR_NAME',
            DD_GIT_COMMIT_COMMITTER_DATE: 'DD_GIT_COMMIT_COMMITTER_DATE',
            DD_GIT_COMMIT_COMMITTER_EMAIL: 'DD_GIT_COMMIT_COMMITTER_EMAIL',
            DD_GIT_COMMIT_COMMITTER_NAME: 'DD_GIT_COMMIT_COMMITTER_NAME',
            DD_GIT_COMMIT_MESSAGE: 'DD_GIT_COMMIT_MESSAGE',
            DD_GIT_COMMIT_SHA: 'DD_GIT_COMMIT_SHA',
            DD_GIT_REPOSITORY_URL: 'DD_GIT_REPOSITORY_URL',
            DD_GIT_TAG: 'DD_GIT_TAG',
        };
        const expectedMetadata = ciAppTagsToMetadata(ddMetadataToSpanTags(DD_METADATA));
        delete expectedMetadata.git.branch;
        const assertions = require(path_1.default.join(__dirname, 'ci-env', ciProvider));
        it.each(assertions)('spec %#', (env, tags) => {
            process.env = Object.assign(Object.assign({}, env), DD_METADATA);
            const ciMetadata = ci_1.getCIMetadata();
            ciMetadata === null || ciMetadata === void 0 ? true : delete ciMetadata.git.branch;
            expect(ciMetadata).toEqual(expectedMetadata);
        });
    });
});
describe('ci spec', () => {
    test('returns an empty object if the CI is not supported', () => {
        process.env = {};
        const tags = Object.assign(Object.assign(Object.assign({}, ci_1.getCISpanTags()), user_provided_git_1.getUserCISpanTags()), user_provided_git_1.getUserGitSpanTags());
        expect(tags).toEqual({});
    });
    CI_PROVIDERS.forEach((ciProvider) => {
        const assertions = require(path_1.default.join(__dirname, 'ci-env', ciProvider));
        assertions.forEach(([env, expectedSpanTags], index) => {
            test(`reads env info for spec ${index} from ${ciProvider}`, () => {
                process.env = env;
                const tags = Object.assign(Object.assign({}, ci_1.getCISpanTags()), user_provided_git_1.getUserGitSpanTags());
                expect(tags).toEqual(expectedSpanTags);
            });
        });
    });
});
//# sourceMappingURL=ci.test.js.map