"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const simple_git_1 = __importDefault(require("simple-git"));
const git_1 = require("../git");
const tags_1 = require("../tags");
jest.mock('simple-git');
describe('getGitMetadata', () => {
    it('reads git metadata successfully', () => __awaiter(void 0, void 0, void 0, function* () {
        ;
        simple_git_1.default.mockImplementation(() => ({
            branch: () => ({ current: 'main' }),
            listRemote: () => 'repository_url',
            revparse: () => 'commitSHA',
            show: (input) => {
                if (input[1] === '--format=%s') {
                    return 'commit message';
                }
                return 'authorName,authorEmail,authorDate,committerName,committerEmail,committerDate';
            },
        }));
        const result = yield git_1.getGitMetadata();
        expect(result).toEqual({
            [tags_1.GIT_REPOSITORY_URL]: 'repository_url',
            [tags_1.GIT_BRANCH]: 'main',
            [tags_1.GIT_SHA]: 'commitSHA',
            [tags_1.GIT_COMMIT_MESSAGE]: 'commit message',
            [tags_1.GIT_COMMIT_COMMITTER_DATE]: 'committerDate',
            [tags_1.GIT_COMMIT_COMMITTER_EMAIL]: 'committerEmail',
            [tags_1.GIT_COMMIT_COMMITTER_NAME]: 'committerName',
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: 'authorDate',
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: 'authorEmail',
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: 'authorName',
        });
    }));
    it('does not crash when git is not available', () => __awaiter(void 0, void 0, void 0, function* () {
        ;
        simple_git_1.default.mockImplementation(() => ({
            branch: () => {
                throw new Error();
            },
            listRemote: () => {
                throw new Error();
            },
            revparse: () => {
                throw new Error();
            },
            show: () => {
                throw new Error();
            },
        }));
        const result = yield git_1.getGitMetadata();
        expect(result).toEqual({});
    }));
});
//# sourceMappingURL=git.test.js.map