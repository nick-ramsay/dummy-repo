"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const retry_1 = require("../retry");
describe('retry', () => {
    const retryCallback = jest.fn();
    const createResultWithErrors = (errors) => {
        let i = -1;
        return () => {
            i = i + 1;
            if (errors[i] === undefined) {
                return Promise.resolve({
                    config: {},
                    data: {},
                    headers: undefined,
                    status: 200,
                    statusText: '',
                });
            }
            return Promise.reject(errors[i]);
        };
    };
    beforeEach(() => {
        jest.restoreAllMocks();
    });
    const buildHttpError = (statusCode) => ({
        response: {
            status: statusCode,
        },
    });
    test('should retry retriable failed requests', () => __awaiter(void 0, void 0, void 0, function* () {
        yield retry_1.retryRequest(createResultWithErrors([buildHttpError(500), undefined]), {
            maxTimeout: 50,
            minTimeout: 10,
            onRetry: retryCallback,
            retries: 5,
        });
        expect(retryCallback).toBeCalledTimes(1);
    }));
    test('should retry non-http errors', () => __awaiter(void 0, void 0, void 0, function* () {
        yield retry_1.retryRequest(createResultWithErrors([{ message: 'Connection timeout' }, undefined]), {
            maxTimeout: 50,
            minTimeout: 10,
            onRetry: retryCallback,
            retries: 5,
        });
        expect(retryCallback).toBeCalledTimes(1);
    }));
    test('should not retry some clients failures', () => __awaiter(void 0, void 0, void 0, function* () {
        let threwError = false;
        try {
            yield retry_1.retryRequest(createResultWithErrors([buildHttpError(413)]), {
                maxTimeout: 50,
                minTimeout: 10,
                onRetry: retryCallback,
                retries: 5,
            });
        }
        catch (error) {
            threwError = true;
        }
        expect(threwError).toBeTruthy();
        expect(retryCallback).toBeCalledTimes(0);
    }));
    test('should retry only a given amount of times', () => __awaiter(void 0, void 0, void 0, function* () {
        let threwError = false;
        try {
            yield retry_1.retryRequest(createResultWithErrors([buildHttpError(500), buildHttpError(500), buildHttpError(500), buildHttpError(500)]), {
                maxTimeout: 20,
                minTimeout: 10,
                onRetry: retryCallback,
                retries: 3,
            });
        }
        catch (error) {
            threwError = true;
        }
        expect(threwError).toBeTruthy();
        expect(retryCallback).toBeCalledTimes(3);
    }));
    test('should not retry if the call was successful', () => __awaiter(void 0, void 0, void 0, function* () {
        yield retry_1.retryRequest(createResultWithErrors([undefined]), {
            maxTimeout: 50,
            minTimeout: 10,
            onRetry: retryCallback,
            retries: 5,
        });
        expect(retryCallback).toBeCalledTimes(0);
    }));
});
//# sourceMappingURL=retry.test.js.map