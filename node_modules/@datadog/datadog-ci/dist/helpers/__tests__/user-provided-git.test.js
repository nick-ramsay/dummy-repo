"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tags_1 = require("../tags");
const user_provided_git_1 = require("../user-provided-git");
describe('getUserGitSpanTags', () => {
    const DD_GIT_METADATA = {
        DD_GIT_BRANCH: 'DD_GIT_BRANCH',
        DD_GIT_COMMIT_AUTHOR_DATE: 'DD_GIT_COMMIT_AUTHOR_DATE',
        DD_GIT_COMMIT_AUTHOR_EMAIL: 'DD_GIT_COMMIT_AUTHOR_EMAIL',
        DD_GIT_COMMIT_AUTHOR_NAME: 'DD_GIT_COMMIT_AUTHOR_NAME',
        DD_GIT_COMMIT_COMMITTER_DATE: 'DD_GIT_COMMIT_COMMITTER_DATE',
        DD_GIT_COMMIT_COMMITTER_EMAIL: 'DD_GIT_COMMIT_COMMITTER_EMAIL',
        DD_GIT_COMMIT_COMMITTER_NAME: 'DD_GIT_COMMIT_COMMITTER_NAME',
        DD_GIT_COMMIT_MESSAGE: 'DD_GIT_COMMIT_MESSAGE',
        DD_GIT_COMMIT_SHA: 'DD_GIT_COMMIT_SHA',
        DD_GIT_REPOSITORY_URL: 'DD_GIT_REPOSITORY_URL',
    };
    it('reads user defined git metadata successfully', () => {
        process.env = Object.assign({}, DD_GIT_METADATA);
        const result = user_provided_git_1.getUserGitSpanTags();
        expect(result).toEqual({
            [tags_1.GIT_REPOSITORY_URL]: 'DD_GIT_REPOSITORY_URL',
            [tags_1.GIT_BRANCH]: 'DD_GIT_BRANCH',
            [tags_1.GIT_SHA]: 'DD_GIT_COMMIT_SHA',
            [tags_1.GIT_COMMIT_MESSAGE]: 'DD_GIT_COMMIT_MESSAGE',
            [tags_1.GIT_COMMIT_COMMITTER_DATE]: 'DD_GIT_COMMIT_COMMITTER_DATE',
            [tags_1.GIT_COMMIT_COMMITTER_EMAIL]: 'DD_GIT_COMMIT_COMMITTER_EMAIL',
            [tags_1.GIT_COMMIT_COMMITTER_NAME]: 'DD_GIT_COMMIT_COMMITTER_NAME',
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: 'DD_GIT_COMMIT_AUTHOR_DATE',
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: 'DD_GIT_COMMIT_AUTHOR_EMAIL',
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: 'DD_GIT_COMMIT_AUTHOR_NAME',
        });
    });
    it('does not include empty values', () => {
        process.env = Object.assign(Object.assign({}, DD_GIT_METADATA), { DD_GIT_COMMIT_SHA: undefined });
        const result = user_provided_git_1.getUserGitSpanTags();
        expect(result).toEqual({
            [tags_1.GIT_REPOSITORY_URL]: 'DD_GIT_REPOSITORY_URL',
            [tags_1.GIT_BRANCH]: 'DD_GIT_BRANCH',
            [tags_1.GIT_COMMIT_MESSAGE]: 'DD_GIT_COMMIT_MESSAGE',
            [tags_1.GIT_COMMIT_COMMITTER_DATE]: 'DD_GIT_COMMIT_COMMITTER_DATE',
            [tags_1.GIT_COMMIT_COMMITTER_EMAIL]: 'DD_GIT_COMMIT_COMMITTER_EMAIL',
            [tags_1.GIT_COMMIT_COMMITTER_NAME]: 'DD_GIT_COMMIT_COMMITTER_NAME',
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: 'DD_GIT_COMMIT_AUTHOR_DATE',
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: 'DD_GIT_COMMIT_AUTHOR_EMAIL',
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: 'DD_GIT_COMMIT_AUTHOR_NAME',
        });
    });
    it('overwrites branch when tag is available', () => {
        process.env = Object.assign(Object.assign({}, DD_GIT_METADATA), { DD_GIT_TAG: 'DD_GIT_TAG' });
        const result = user_provided_git_1.getUserGitSpanTags();
        expect(result).toEqual({
            [tags_1.GIT_TAG]: 'DD_GIT_TAG',
            [tags_1.GIT_REPOSITORY_URL]: 'DD_GIT_REPOSITORY_URL',
            [tags_1.GIT_SHA]: 'DD_GIT_COMMIT_SHA',
            [tags_1.GIT_COMMIT_MESSAGE]: 'DD_GIT_COMMIT_MESSAGE',
            [tags_1.GIT_COMMIT_COMMITTER_DATE]: 'DD_GIT_COMMIT_COMMITTER_DATE',
            [tags_1.GIT_COMMIT_COMMITTER_EMAIL]: 'DD_GIT_COMMIT_COMMITTER_EMAIL',
            [tags_1.GIT_COMMIT_COMMITTER_NAME]: 'DD_GIT_COMMIT_COMMITTER_NAME',
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: 'DD_GIT_COMMIT_AUTHOR_DATE',
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: 'DD_GIT_COMMIT_AUTHOR_EMAIL',
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: 'DD_GIT_COMMIT_AUTHOR_NAME',
        });
    });
    it('returns an empty object if no user git is defined', () => {
        process.env = {};
        const result = user_provided_git_1.getUserGitSpanTags();
        expect(result).toEqual({});
    });
});
describe('getUserCISpanTags', () => {
    const DD_CI_METADATA = {
        DD_CI_JOB_NAME: 'DD_CI_JOB_NAME',
        DD_CI_JOB_URL: 'DD_CI_JOB_URL',
        DD_CI_PIPELINE_ID: 'DD_CI_PIPELINE_ID',
        DD_CI_PIPELINE_NAME: 'DD_CI_PIPELINE_NAME',
        DD_CI_PIPELINE_NUMBER: 'DD_CI_PIPELINE_NUMBER',
        DD_CI_PIPELINE_URL: 'DD_CI_PIPELINE_URL',
        DD_CI_PROVIDER_NAME: 'DD_CI_PROVIDER_NAME',
        DD_CI_STAGE_NAME: 'DD_CI_STAGE_NAME',
        DD_CI_WORKSPACE_PATH: 'DD_CI_WORKSPACE_PATH',
    };
    it('reads user defined CI metadata successfully', () => {
        process.env = Object.assign({}, DD_CI_METADATA);
        const result = user_provided_git_1.getUserCISpanTags();
        expect(result).toEqual({
            [tags_1.CI_JOB_NAME]: 'DD_CI_JOB_NAME',
            [tags_1.CI_JOB_URL]: 'DD_CI_JOB_URL',
            [tags_1.CI_PIPELINE_ID]: 'DD_CI_PIPELINE_ID',
            [tags_1.CI_PIPELINE_NAME]: 'DD_CI_PIPELINE_NAME',
            [tags_1.CI_PIPELINE_NUMBER]: 'DD_CI_PIPELINE_NUMBER',
            [tags_1.CI_PIPELINE_URL]: 'DD_CI_PIPELINE_URL',
            [tags_1.CI_PROVIDER_NAME]: 'DD_CI_PROVIDER_NAME',
            [tags_1.CI_STAGE_NAME]: 'DD_CI_STAGE_NAME',
            [tags_1.CI_WORKSPACE_PATH]: 'DD_CI_WORKSPACE_PATH',
        });
    });
    it('does not include empty values', () => {
        process.env = Object.assign(Object.assign({}, DD_CI_METADATA), { DD_CI_PIPELINE_ID: undefined });
        const result = user_provided_git_1.getUserCISpanTags();
        expect(result).toEqual({
            [tags_1.CI_JOB_NAME]: 'DD_CI_JOB_NAME',
            [tags_1.CI_JOB_URL]: 'DD_CI_JOB_URL',
            [tags_1.CI_PIPELINE_NAME]: 'DD_CI_PIPELINE_NAME',
            [tags_1.CI_PIPELINE_NUMBER]: 'DD_CI_PIPELINE_NUMBER',
            [tags_1.CI_PIPELINE_URL]: 'DD_CI_PIPELINE_URL',
            [tags_1.CI_PROVIDER_NAME]: 'DD_CI_PROVIDER_NAME',
            [tags_1.CI_STAGE_NAME]: 'DD_CI_STAGE_NAME',
            [tags_1.CI_WORKSPACE_PATH]: 'DD_CI_WORKSPACE_PATH',
        });
    });
    it('returns an empty object if no user CI is defined', () => {
        process.env = {};
        const result = user_provided_git_1.getUserCISpanTags();
        expect(result).toEqual({});
    });
});
//# sourceMappingURL=user-provided-git.test.js.map