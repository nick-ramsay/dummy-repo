"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('fs');
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const http_1 = __importDefault(require("http"));
const proxy_1 = __importDefault(require("proxy"));
const proxy_agent_1 = __importDefault(require("proxy-agent"));
const ciUtils = __importStar(require("../utils"));
jest.useFakeTimers();
describe('utils', () => {
    beforeEach(() => {
        jest.restoreAllMocks();
    });
    test('Test pick', () => {
        const initialHash = { a: 1, b: 2 };
        let resultHash = ciUtils.pick(initialHash, ['a']);
        expect(Object.keys(resultHash).indexOf('b')).toBe(-1);
        expect(resultHash.a).toBe(1);
        resultHash = ciUtils.pick(initialHash, ['c']);
        expect(Object.keys(resultHash).length).toBe(0);
    });
    describe('parseConfigFile', () => {
        test('should read a config file', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({ newconfigkey: 'newconfigvalue' }); }));
            const config = yield ciUtils.parseConfigFile({});
            expect(config.newconfigkey).toBe('newconfigvalue');
        }));
        test('should throw an error if path is provided and config file is not found', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(fs_1.default, 'readFile').mockImplementation((a, b, cb) => cb({ code: 'ENOENT' }));
            const config = ciUtils.parseConfigFile({}, '/veryuniqueandabsentfile');
            yield expect(config).rejects.toEqual(Error('Config file not found'));
        }));
        test('should throw an error if JSON parsing fails', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(fs_1.default, 'readFile').mockImplementation((a, b, cb) => cb(undefined, 'thisisnoJSON'));
            yield expect(ciUtils.parseConfigFile({})).rejects.toEqual(Error('Config file is not correct JSON'));
        }));
        test('config file should overwrite default configuration', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(ciUtils, 'getConfig').mockImplementation(() => __awaiter(void 0, void 0, void 0, function* () { return ({ configKey: 'newconfigvalue' }); }));
            const config = yield ciUtils.parseConfigFile({ configKey: 'configvalue' });
            expect(config.configKey).toBe('newconfigvalue');
        }));
    });
    describe('getRequestBuilder', () => {
        const fakeEndpointBuilder = (request) => () => __awaiter(void 0, void 0, void 0, function* () { return request({}); });
        test('should add api key header', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.headers));
            const requestOptions = {
                apiKey: 'apiKey',
                baseUrl: 'http://fake-base.url/',
            };
            const request = ciUtils.getRequestBuilder(requestOptions);
            const fakeEndpoint = fakeEndpointBuilder(request);
            expect(yield fakeEndpoint()).toStrictEqual({ 'DD-API-KEY': 'apiKey' });
        }));
        test('should add api and application key header', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.headers));
            const requestOptions = {
                apiKey: 'apiKey',
                appKey: 'applicationKey',
                baseUrl: 'http://fake-base.url/',
            };
            const request = ciUtils.getRequestBuilder(requestOptions);
            const fakeEndpoint = fakeEndpointBuilder(request);
            expect(yield fakeEndpoint()).toStrictEqual({ 'DD-API-KEY': 'apiKey', 'DD-APPLICATION-KEY': 'applicationKey' });
        }));
        describe('proxy configuration', () => {
            test('should have a ProxyAgent by default', () => __awaiter(void 0, void 0, void 0, function* () {
                jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.httpsAgent));
                const requestOptions = {
                    apiKey: 'apiKey',
                    appKey: 'applicationKey',
                    baseUrl: 'http://fake-base.url/',
                };
                const request = ciUtils.getRequestBuilder(requestOptions);
                const fakeEndpoint = fakeEndpointBuilder(request);
                const httpsAgent = yield fakeEndpoint();
                expect(httpsAgent).toBeDefined();
                expect(httpsAgent).toBeInstanceOf(proxy_agent_1.default);
            }));
            test('should add proxy configuration when explicitly defined', () => __awaiter(void 0, void 0, void 0, function* () {
                jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.httpsAgent));
                const proxyOpts = { protocol: 'http', host: '1.2.3.4', port: 1234 };
                const requestOptions = {
                    apiKey: 'apiKey',
                    appKey: 'applicationKey',
                    baseUrl: 'http://fake-base.url/',
                    proxyOpts,
                };
                const request = ciUtils.getRequestBuilder(requestOptions);
                const fakeEndpoint = fakeEndpointBuilder(request);
                const httpsAgent = yield fakeEndpoint();
                expect(httpsAgent).toBeDefined();
                expect(httpsAgent.proxyUri).toBe('http://1.2.3.4:1234');
            }));
        });
        test('should accept overrideUrl', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.url));
            const requestOptions = {
                apiKey: 'apiKey',
                appKey: 'applicationKey',
                baseUrl: 'http://fake-base.url/',
                overrideUrl: 'override/url',
            };
            const request = ciUtils.getRequestBuilder(requestOptions);
            const fakeEndpoint = fakeEndpointBuilder(request);
            expect(yield fakeEndpoint()).toStrictEqual('override/url');
        }));
        test('should accept additional headers', () => __awaiter(void 0, void 0, void 0, function* () {
            jest.spyOn(axios_1.default, 'create').mockImplementation((() => (args) => args.headers));
            const requestOptions = {
                apiKey: 'apiKey',
                appKey: 'applicationKey',
                baseUrl: 'http://fake-base.url/',
                headers: new Map([
                    ['HEADER1', 'value1'],
                    ['HEADER2', 'value2'],
                ]),
                overrideUrl: 'override/url',
            };
            const request = ciUtils.getRequestBuilder(requestOptions);
            const fakeEndpoint = fakeEndpointBuilder(request);
            expect(yield fakeEndpoint()).toStrictEqual({
                'DD-API-KEY': 'apiKey',
                'DD-APPLICATION-KEY': 'applicationKey',
                HEADER1: 'value1',
                HEADER2: 'value2',
            });
        }));
    });
    describe('getApiHostForSite', () => {
        it.each([
            ['datad0g.com', 'app.datad0g.com'],
            ['datadoghq.com', 'api.datadoghq.com'],
            ['datadoghq.eu', 'api.datadoghq.eu'],
            ['whitelabel.com', 'api.whitelabel.com'],
        ])('for site = %p, returns api host = %p ', (site, expectedApiHost) => {
            expect(ciUtils.getApiHostForSite(site)).toEqual(expectedApiHost);
        });
    });
    describe('buildPath', () => {
        test('should return correct path', () => {
            const pathWithNoTrailingSlash = 'sourcemaps/js';
            const pathWithTrailingSlash = 'sourcemaps/js/';
            const fileName = 'file1.min.js';
            expect(ciUtils.buildPath(pathWithNoTrailingSlash, fileName)).toBe('sourcemaps/js/file1.min.js');
            expect(ciUtils.buildPath(pathWithTrailingSlash, fileName)).toBe('sourcemaps/js/file1.min.js');
        });
    });
    describe('getProxyUrl', () => {
        test('should return correct proxy URI', () => {
            expect(ciUtils.getProxyUrl()).toBe('');
            expect(ciUtils.getProxyUrl({ protocol: 'http' })).toBe('');
            expect(ciUtils.getProxyUrl({ host: '127.0.0.1', protocol: 'http' })).toBe('');
            expect(ciUtils.getProxyUrl({ host: '127.0.0.1', port: 1234, protocol: 'http' })).toBe('http://127.0.0.1:1234');
            const auth = { password: 'pwd', username: 'john' };
            expect(ciUtils.getProxyUrl({ auth, host: '127.0.0.1', port: 1234, protocol: 'http' })).toBe('http://john:pwd@127.0.0.1:1234');
            expect(ciUtils.getProxyUrl({ auth, protocol: 'http' })).toBe('');
        });
    });
    // Test the different possibilities of proxy configuration of getRequestHelper.
    // All the calls to getRequestHelpers should be https calls, but to keep the test suite
    // simple tests are using http calls (testing with https would require us to add tls certs
    // and configure axios to trust these tls certs, which requires an agent config, which
    // interferes a bit with how the proxies are configured since they are configured through an
    // agent themselves.
    // Proxy of https requests is still tested in the proxy-agent library itself.
    describe('Proxy configuration', () => {
        let initialHttpProxyEnv;
        beforeAll(() => {
            initialHttpProxyEnv = process.env.HTTP_PROXY;
        });
        afterAll(() => {
            if (initialHttpProxyEnv !== undefined) {
                process.env.HTTP_PROXY = initialHttpProxyEnv;
            }
            else {
                delete process.env.HTTP_PROXY;
            }
        });
        beforeEach(() => {
            delete process.env.HTTP_PROXY;
        });
        // Start a target http server and a proxy server listening on localhost,
        // returns the ports they listen to, a spy method allowing us to check if they've been
        // handling any requests, and a function to close them.
        const setupServer = () => __awaiter(void 0, void 0, void 0, function* () {
            // Create target http server
            const mockCallback = jest.fn((_, res) => {
                res.end('response from target http server');
            });
            const targetHttpServer = http_1.default.createServer(mockCallback);
            yield new Promise((resolve, reject) => {
                targetHttpServer.listen((err) => {
                    if (err) {
                        reject(err);
                    }
                    resolve();
                });
            });
            // Create proxy
            const proxyHttpServer = http_1.default.createServer();
            const proxyServer = proxy_1.default(proxyHttpServer);
            const spyProxy = jest.fn();
            proxyHttpServer.on('request', spyProxy);
            yield new Promise((resolve, reject) => {
                proxyServer.listen((err) => {
                    if (err) {
                        reject(err);
                    }
                    resolve();
                });
            });
            return {
                proxyServer: {
                    close: () => __awaiter(void 0, void 0, void 0, function* () {
                        return new Promise((resolve, reject) => {
                            proxyServer.close((err) => {
                                if (err) {
                                    reject(err);
                                }
                                resolve();
                            });
                        });
                    }),
                    port: proxyHttpServer.address().port,
                    spy: spyProxy,
                },
                targetServer: {
                    close: () => __awaiter(void 0, void 0, void 0, function* () {
                        return new Promise((resolve, reject) => {
                            targetHttpServer.close((err) => {
                                if (err) {
                                    reject(err);
                                }
                                resolve();
                            });
                        });
                    }),
                    port: targetHttpServer.address().port,
                    spy: mockCallback,
                },
            };
        });
        test('Work without a proxy defined', () => __awaiter(void 0, void 0, void 0, function* () {
            const { proxyServer, targetServer } = yield setupServer();
            try {
                const requestBuilder = ciUtils.getRequestBuilder({
                    apiKey: 'abc',
                    baseUrl: `http://localhost:${targetServer.port}`,
                });
                yield requestBuilder({
                    method: 'GET',
                    url: 'test-from-proxy',
                });
                expect(targetServer.spy.mock.calls.length).toBe(1);
                expect(proxyServer.spy.mock.calls.length).toBe(0);
            }
            finally {
                yield targetServer.close();
                yield proxyServer.close();
            }
        }));
        test('Proxy configured explicitly', () => __awaiter(void 0, void 0, void 0, function* () {
            const { proxyServer, targetServer } = yield setupServer();
            try {
                const requestBuilder = ciUtils.getRequestBuilder({
                    apiKey: 'abc',
                    baseUrl: `http://localhost:${targetServer.port}`,
                    proxyOpts: {
                        host: 'localhost',
                        port: proxyServer.port,
                        protocol: 'http',
                    },
                });
                yield requestBuilder({
                    method: 'GET',
                    url: 'test-from-proxy',
                });
                expect(targetServer.spy.mock.calls.length).toBe(1);
                expect(proxyServer.spy.mock.calls.length).toBe(1);
            }
            finally {
                yield targetServer.close();
                yield proxyServer.close();
            }
        }));
        test('Proxy configured through env var', () => __awaiter(void 0, void 0, void 0, function* () {
            const { proxyServer, targetServer } = yield setupServer();
            try {
                process.env.HTTP_PROXY = `http://localhost:${proxyServer.port}`;
                const requestBuilder = ciUtils.getRequestBuilder({
                    apiKey: 'abc',
                    baseUrl: `http://localhost:${targetServer.port}`,
                });
                yield requestBuilder({
                    method: 'GET',
                    url: 'test-from-proxy',
                });
                expect(targetServer.spy.mock.calls.length).toBe(1);
                expect(proxyServer.spy.mock.calls.length).toBe(1);
            }
            finally {
                yield targetServer.close();
                yield proxyServer.close();
            }
        }));
        test('Proxy configured explicitly takes precedence over env var', () => __awaiter(void 0, void 0, void 0, function* () {
            const { proxyServer, targetServer } = yield setupServer();
            try {
                process.env.HTTP_PROXY = `http://incorrecthost:${proxyServer.port}`;
                const requestBuilder = ciUtils.getRequestBuilder({
                    apiKey: 'abc',
                    baseUrl: `http://localhost:${targetServer.port}`,
                    proxyOpts: {
                        host: 'localhost',
                        port: proxyServer.port,
                        protocol: 'http',
                    },
                });
                yield requestBuilder({
                    method: 'GET',
                    url: 'test-from-proxy',
                });
                expect(targetServer.spy.mock.calls.length).toBe(1);
                expect(proxyServer.spy.mock.calls.length).toBe(1);
            }
            finally {
                yield targetServer.close();
                yield proxyServer.close();
            }
        }));
    });
});
test('removeUndefinedValues', () => {
    // tslint:disable-next-line: no-null-keyword
    expect(ciUtils.removeUndefinedValues({ a: 'b', c: 'd', e: undefined, g: null })).toEqual({ a: 'b', c: 'd', g: null });
});
//# sourceMappingURL=utils.test.js.map