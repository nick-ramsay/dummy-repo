"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCIEnv = exports.getCIMetadata = exports.getCISpanTags = exports.CI_ENGINES = void 0;
const url_1 = require("url");
const tags_1 = require("./tags");
const user_provided_git_1 = require("./user-provided-git");
const utils_1 = require("./utils");
exports.CI_ENGINES = {
    APPVEYOR: 'appveyor',
    AZURE: 'azurepipelines',
    BITBUCKET: 'bitbucket',
    BITRISE: 'bitrise',
    BUILDKITE: 'buildkite',
    CIRCLECI: 'circleci',
    GITHUB: 'github',
    GITLAB: 'gitlab',
    JENKINS: 'jenkins',
    TRAVIS: 'travisci',
};
// Receives a string with the form 'John Doe <john.doe@gmail.com>'
// and returns { name: 'John Doe', email: 'john.doe@gmail.com' }
const parseEmailAndName = (emailAndName) => {
    if (!emailAndName) {
        return { name: '', email: '' };
    }
    let name = '';
    let email = '';
    const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/);
    if (matchNameAndEmail) {
        name = matchNameAndEmail[1];
        email = matchNameAndEmail[2];
    }
    return { name, email };
};
const resolveTilde = (filePath) => {
    var _a;
    if (!filePath || typeof filePath !== 'string') {
        return '';
    }
    // '~/folder/path' or '~'
    if (filePath[0] === '~' && (filePath[1] === '/' || filePath.length === 1)) {
        return filePath.replace('~', (_a = process.env.HOME) !== null && _a !== void 0 ? _a : '');
    }
    return filePath;
};
const filterSensitiveInfoFromRepository = (repositoryUrl) => {
    if (repositoryUrl.startsWith('git@')) {
        return repositoryUrl;
    }
    try {
        const { protocol, hostname, pathname } = new url_1.URL(repositoryUrl);
        if (!protocol || !hostname) {
            return repositoryUrl;
        }
        return `${protocol}//${hostname}${pathname}`;
    }
    catch (e) {
        return repositoryUrl;
    }
};
const getCISpanTags = () => {
    const env = process.env;
    let tags = {};
    if (env.CIRCLECI) {
        const { CIRCLE_WORKFLOW_ID, CIRCLE_PROJECT_REPONAME, CIRCLE_BUILD_URL, CIRCLE_WORKING_DIRECTORY, CIRCLE_BRANCH, CIRCLE_TAG, CIRCLE_SHA1, CIRCLE_REPOSITORY_URL, CIRCLE_JOB, } = env;
        const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`;
        tags = {
            [tags_1.CI_JOB_URL]: CIRCLE_BUILD_URL,
            [tags_1.CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
            [tags_1.CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
            [tags_1.CI_PIPELINE_URL]: pipelineUrl,
            [tags_1.CI_JOB_NAME]: CIRCLE_JOB,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.CIRCLECI,
            [tags_1.CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
            [tags_1.GIT_SHA]: CIRCLE_SHA1,
            [tags_1.GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
            [CIRCLE_TAG ? tags_1.GIT_TAG : tags_1.GIT_BRANCH]: CIRCLE_TAG || CIRCLE_BRANCH,
        };
    }
    if (env.TRAVIS) {
        const { TRAVIS_PULL_REQUEST_BRANCH, TRAVIS_BRANCH, TRAVIS_COMMIT, TRAVIS_REPO_SLUG, TRAVIS_TAG, TRAVIS_JOB_WEB_URL, TRAVIS_BUILD_ID, TRAVIS_BUILD_NUMBER, TRAVIS_BUILD_WEB_URL, TRAVIS_BUILD_DIR, TRAVIS_COMMIT_MESSAGE, } = env;
        tags = {
            [tags_1.CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
            [tags_1.CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
            [tags_1.CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.TRAVIS,
            [tags_1.CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
            [tags_1.GIT_SHA]: TRAVIS_COMMIT,
            [tags_1.GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
            [tags_1.GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE,
        };
        const isTag = !!TRAVIS_TAG;
        const ref = TRAVIS_TAG || TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH;
        const refKey = isTag ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        tags[refKey] = ref;
    }
    if (env.GITLAB_CI) {
        const { CI_PIPELINE_ID: GITLAB_CI_PIPELINE_ID, CI_PROJECT_PATH, CI_PIPELINE_IID, CI_PIPELINE_URL: GITLAB_CI_PIPELINE_URL, CI_PROJECT_DIR, CI_COMMIT_REF_NAME, CI_COMMIT_TAG, CI_COMMIT_SHA, CI_REPOSITORY_URL, CI_JOB_URL: GITLAB_CI_JOB_URL, CI_JOB_STAGE, CI_JOB_NAME: GITLAB_CI_JOB_NAME, CI_COMMIT_MESSAGE, CI_COMMIT_TIMESTAMP, CI_COMMIT_AUTHOR, } = env;
        const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR);
        tags = {
            [tags_1.CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
            [tags_1.CI_JOB_URL]: GITLAB_CI_JOB_URL,
            [tags_1.CI_PIPELINE_ID]: GITLAB_CI_PIPELINE_ID,
            [tags_1.CI_PIPELINE_NAME]: CI_PROJECT_PATH,
            [tags_1.CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
            [tags_1.CI_PIPELINE_URL]: GITLAB_CI_PIPELINE_URL && GITLAB_CI_PIPELINE_URL.replace('/-/pipelines/', '/pipelines/'),
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.GITLAB,
            [tags_1.CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
            [tags_1.CI_STAGE_NAME]: CI_JOB_STAGE,
            [tags_1.GIT_BRANCH]: CI_COMMIT_REF_NAME,
            [tags_1.GIT_SHA]: CI_COMMIT_SHA,
            [tags_1.GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
            [tags_1.GIT_TAG]: CI_COMMIT_TAG,
            [tags_1.GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: name,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: email,
            [tags_1.GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP,
        };
    }
    if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
        const { GITHUB_RUN_ID, GITHUB_WORKFLOW, GITHUB_RUN_NUMBER, GITHUB_WORKSPACE, GITHUB_HEAD_REF, GITHUB_REF, GITHUB_SHA, GITHUB_REPOSITORY, GITHUB_SERVER_URL, } = env;
        const repositoryUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`;
        let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
        // Some older versions of enterprise might not have this yet.
        if (env.GITHUB_RUN_ATTEMPT) {
            pipelineURL += `/attempts/${env.GITHUB_RUN_ATTEMPT}`;
        }
        const ref = GITHUB_HEAD_REF || GITHUB_REF || '';
        const refKey = ref.includes('tags') ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        tags = {
            [tags_1.CI_JOB_URL]: `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`,
            [tags_1.CI_PIPELINE_ID]: GITHUB_RUN_ID,
            [tags_1.CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
            [tags_1.CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
            [tags_1.CI_PIPELINE_URL]: pipelineURL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.GITHUB,
            [tags_1.CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
            [tags_1.GIT_SHA]: GITHUB_SHA,
            [tags_1.GIT_REPOSITORY_URL]: repositoryUrl,
            [refKey]: ref,
        };
    }
    if (env.JENKINS_URL) {
        const { WORKSPACE, BUILD_TAG, JOB_NAME, BUILD_NUMBER, BUILD_URL, GIT_BRANCH: JENKINS_GIT_BRANCH, GIT_COMMIT, GIT_URL, GIT_URL_1, } = env;
        tags = {
            [tags_1.CI_PIPELINE_ID]: BUILD_TAG,
            [tags_1.CI_PIPELINE_NUMBER]: BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BUILD_URL,
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.JENKINS,
            [tags_1.CI_WORKSPACE_PATH]: WORKSPACE,
            [tags_1.GIT_SHA]: GIT_COMMIT,
            [tags_1.GIT_REPOSITORY_URL]: GIT_URL || GIT_URL_1,
        };
        const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes('tags');
        const refKey = isTag ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        const ref = utils_1.normalizeRef(JENKINS_GIT_BRANCH);
        tags[refKey] = ref;
        let finalPipelineName = '';
        if (JOB_NAME) {
            // Job names can contain parameters, e.g. jobName/KEY1=VALUE1,KEY2=VALUE2/branchName
            const jobNameAndParams = JOB_NAME.split('/');
            if (jobNameAndParams.length > 1 && jobNameAndParams[1].includes('=')) {
                finalPipelineName = jobNameAndParams[0];
            }
            else {
                finalPipelineName = JOB_NAME.replace(`/${ref}`, '');
            }
            tags[tags_1.CI_PIPELINE_NAME] = finalPipelineName;
        }
    }
    if (env.BUILDKITE) {
        const { BUILDKITE_BRANCH, BUILDKITE_COMMIT, BUILDKITE_REPO, BUILDKITE_TAG, BUILDKITE_BUILD_ID, BUILDKITE_PIPELINE_SLUG, BUILDKITE_BUILD_NUMBER, BUILDKITE_BUILD_URL, BUILDKITE_JOB_ID, BUILDKITE_BUILD_CHECKOUT_PATH, BUILDKITE_BUILD_AUTHOR, BUILDKITE_BUILD_AUTHOR_EMAIL, BUILDKITE_MESSAGE, } = env;
        const ref = BUILDKITE_TAG || BUILDKITE_BRANCH;
        const refKey = BUILDKITE_TAG ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BUILDKITE,
            [tags_1.CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
            [tags_1.CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
            [tags_1.CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
            [tags_1.GIT_SHA]: BUILDKITE_COMMIT,
            [tags_1.CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
            [tags_1.GIT_REPOSITORY_URL]: BUILDKITE_REPO,
            [refKey]: ref,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE,
        };
    }
    if (env.BITRISE_BUILD_SLUG) {
        const { BITRISE_GIT_COMMIT, GIT_CLONE_COMMIT_HASH, BITRISEIO_GIT_BRANCH_DEST, BITRISE_GIT_BRANCH, BITRISE_BUILD_SLUG, BITRISE_TRIGGERED_WORKFLOW_ID, BITRISE_BUILD_NUMBER, BITRISE_BUILD_URL, BITRISE_SOURCE_DIR, GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL, BITRISE_GIT_TAG, BITRISE_GIT_MESSAGE, } = env;
        const isTag = !!BITRISE_GIT_TAG;
        const refKey = isTag ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        const ref = BITRISE_GIT_TAG || BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BITRISE,
            [tags_1.CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
            [tags_1.CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
            [tags_1.CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_URL]: BITRISE_BUILD_URL,
            [tags_1.GIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
            [tags_1.GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
            [tags_1.CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
            [refKey]: ref,
            [tags_1.GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE,
        };
    }
    if (env.BITBUCKET_COMMIT) {
        const { BITBUCKET_REPO_FULL_NAME, BITBUCKET_BUILD_NUMBER, BITBUCKET_BRANCH, BITBUCKET_COMMIT, BITBUCKET_GIT_SSH_ORIGIN, BITBUCKET_TAG, BITBUCKET_PIPELINE_UUID, BITBUCKET_CLONE_DIR, } = env;
        const url = `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.BITBUCKET,
            [tags_1.GIT_SHA]: BITBUCKET_COMMIT,
            [tags_1.CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
            [tags_1.CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
            [tags_1.CI_JOB_URL]: url,
            [tags_1.CI_PIPELINE_URL]: url,
            [tags_1.GIT_BRANCH]: BITBUCKET_BRANCH,
            [tags_1.GIT_TAG]: BITBUCKET_TAG,
            [tags_1.GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN,
            [tags_1.CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
            [tags_1.CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replace(/{|}/gm, ''),
        };
    }
    if (env.TF_BUILD) {
        const { BUILD_SOURCESDIRECTORY, BUILD_BUILDID, BUILD_DEFINITIONNAME, SYSTEM_TEAMFOUNDATIONSERVERURI, SYSTEM_TEAMPROJECTID, SYSTEM_JOBID, SYSTEM_TASKINSTANCEID, SYSTEM_PULLREQUEST_SOURCEBRANCH, BUILD_SOURCEBRANCH, BUILD_SOURCEBRANCHNAME, SYSTEM_PULLREQUEST_SOURCECOMMITID, SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI, BUILD_REPOSITORY_URI, BUILD_SOURCEVERSION, BUILD_REQUESTEDFORID, BUILD_REQUESTEDFOREMAIL, BUILD_SOURCEVERSIONMESSAGE, SYSTEM_STAGEDISPLAYNAME, SYSTEM_JOBDISPLAYNAME, } = env;
        const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME;
        const refKey = (ref || '').includes('tags') ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.AZURE,
            [tags_1.CI_PIPELINE_ID]: BUILD_BUILDID,
            [tags_1.CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
            [tags_1.CI_PIPELINE_NUMBER]: BUILD_BUILDID,
            [tags_1.GIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
            [tags_1.CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
            [tags_1.GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
            [refKey]: ref,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
            [tags_1.CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
            [tags_1.CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME,
        };
        if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
            const baseUrl = `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`;
            const pipelineUrl = baseUrl;
            const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`;
            tags = Object.assign(Object.assign({}, tags), { [tags_1.CI_PIPELINE_URL]: pipelineUrl, [tags_1.CI_JOB_URL]: jobUrl });
        }
    }
    if (env.APPVEYOR) {
        const { APPVEYOR_REPO_NAME, APPVEYOR_REPO_PROVIDER, APPVEYOR_BUILD_FOLDER, APPVEYOR_BUILD_ID, APPVEYOR_BUILD_NUMBER, APPVEYOR_REPO_COMMIT, APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH, APPVEYOR_REPO_BRANCH, APPVEYOR_REPO_TAG_NAME, APPVEYOR_REPO_COMMIT_AUTHOR, APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL, APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED, } = env;
        const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`;
        tags = {
            [tags_1.CI_PROVIDER_NAME]: exports.CI_ENGINES.APPVEYOR,
            [tags_1.CI_PIPELINE_URL]: pipelineUrl,
            [tags_1.CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
            [tags_1.CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
            [tags_1.CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
            [tags_1.CI_JOB_URL]: pipelineUrl,
            [tags_1.CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
            [tags_1.GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
            [tags_1.GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            [tags_1.GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED,
        };
        if (APPVEYOR_REPO_PROVIDER === 'github') {
            const refKey = APPVEYOR_REPO_TAG_NAME ? tags_1.GIT_TAG : tags_1.GIT_BRANCH;
            const ref = APPVEYOR_REPO_TAG_NAME || APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH;
            tags = Object.assign(Object.assign({}, tags), { [tags_1.GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`, [tags_1.GIT_SHA]: APPVEYOR_REPO_COMMIT, [refKey]: ref });
        }
    }
    if (tags[tags_1.CI_WORKSPACE_PATH]) {
        tags[tags_1.CI_WORKSPACE_PATH] = resolveTilde(tags[tags_1.CI_WORKSPACE_PATH]);
    }
    if (tags[tags_1.GIT_REPOSITORY_URL]) {
        tags[tags_1.GIT_REPOSITORY_URL] = filterSensitiveInfoFromRepository(tags[tags_1.GIT_REPOSITORY_URL]);
    }
    if (tags[tags_1.GIT_BRANCH]) {
        tags[tags_1.GIT_BRANCH] = utils_1.normalizeRef(tags[tags_1.GIT_BRANCH]);
    }
    if (tags[tags_1.GIT_TAG]) {
        tags[tags_1.GIT_TAG] = utils_1.normalizeRef(tags[tags_1.GIT_TAG]);
    }
    return utils_1.removeEmptyValues(tags);
};
exports.getCISpanTags = getCISpanTags;
const getCIMetadata = (tagSizeLimits) => {
    const tags = Object.assign(Object.assign(Object.assign({}, exports.getCISpanTags()), user_provided_git_1.getUserCISpanTags()), user_provided_git_1.getUserGitSpanTags());
    if (!tags || !Object.keys(tags).length) {
        return;
    }
    if (tagSizeLimits) {
        for (const key of Object.keys(tagSizeLimits)) {
            const tagToLimit = key;
            const originalTag = tags[tagToLimit];
            if (!!originalTag) {
                tags[tagToLimit] = originalTag.substring(0, tagSizeLimits[tagToLimit]);
            }
        }
    }
    const metadata = {
        ci: utils_1.removeUndefinedValues({
            job: utils_1.removeUndefinedValues({
                name: tags[tags_1.CI_JOB_NAME],
                url: tags[tags_1.CI_JOB_URL],
            }),
            pipeline: utils_1.removeUndefinedValues({
                id: tags[tags_1.CI_PIPELINE_ID],
                name: tags[tags_1.CI_PIPELINE_NAME],
                number: parsePipelineNumber(tags[tags_1.CI_PIPELINE_NUMBER]),
                url: tags[tags_1.CI_PIPELINE_URL],
            }),
            provider: utils_1.removeUndefinedValues({
                name: tags[tags_1.CI_PROVIDER_NAME],
            }),
            stage: utils_1.removeUndefinedValues({
                name: tags[tags_1.CI_STAGE_NAME],
            }),
            workspace_path: tags[tags_1.CI_WORKSPACE_PATH],
        }),
        git: utils_1.removeUndefinedValues({
            branch: tags[tags_1.GIT_BRANCH],
            commit: utils_1.removeUndefinedValues({
                author: utils_1.removeUndefinedValues({
                    date: tags[tags_1.GIT_COMMIT_AUTHOR_DATE],
                    email: tags[tags_1.GIT_COMMIT_AUTHOR_EMAIL],
                    name: tags[tags_1.GIT_COMMIT_AUTHOR_NAME],
                }),
                committer: utils_1.removeUndefinedValues({
                    date: tags[tags_1.GIT_COMMIT_COMMITTER_DATE],
                    email: tags[tags_1.GIT_COMMIT_COMMITTER_EMAIL],
                    name: tags[tags_1.GIT_COMMIT_COMMITTER_NAME],
                }),
                message: tags[tags_1.GIT_COMMIT_MESSAGE],
                sha: tags[tags_1.GIT_SHA],
            }),
            repository_url: tags[tags_1.GIT_REPOSITORY_URL],
            tag: tags[tags_1.GIT_TAG],
        }),
    };
    return metadata;
};
exports.getCIMetadata = getCIMetadata;
const parsePipelineNumber = (pipelineNumberStr) => {
    if (pipelineNumberStr) {
        const pipelineNumber = parseInt(pipelineNumberStr, 10);
        return isFinite(pipelineNumber) ? pipelineNumber : undefined;
    }
};
const getCIEnv = () => {
    if (process.env.CIRCLECI) {
        return {
            ciEnv: getEnvVars('CIRCLE_'),
            provider: 'circleci',
        };
    }
    if (process.env.GITLAB_CI) {
        return {
            ciEnv: getEnvVars('CI_'),
            provider: 'gitlab',
        };
    }
    if (process.env.GITHUB_ACTIONS || process.env.GITHUB_ACTION) {
        return {
            ciEnv: getEnvVars('GITHUB_'),
            provider: 'github',
        };
    }
    if (process.env.BUILDKITE) {
        return {
            ciEnv: getEnvVars('BUILDKITE_'),
            provider: 'buildkite',
        };
    }
    throw new Error('Only providers [GitHub, GitLab, CircleCI, Buildkite] are supported');
};
exports.getCIEnv = getCIEnv;
const getEnvVars = (prefix) => Object.entries(process.env)
    .filter(([key, value]) => key.startsWith(prefix) && !/(PASS)|(TOKEN)|(SECRET)|(KEY)/i.test(key))
    .reduce((accum, [key, value]) => (Object.assign(Object.assign({}, accum), { [key]: value })), {});
//# sourceMappingURL=ci.js.map