import { CommandBuilder, RunState } from '../core';
import { BaseContext, CliContext, MiniCli } from './Cli';
export declare type Meta<Context extends BaseContext> = {
    definitions: ((command: CommandBuilder<CliContext<Context>>) => void)[];
    transformers: ((state: RunState, command: Command<Context>) => void)[];
};
export declare type Usage = {
    category?: string;
    description?: string;
    details?: string;
    examples?: [string, string][];
};
export declare type CommandClass<Context extends BaseContext = BaseContext> = {
    new (): Command<Context>;
    resolveMeta(prototype: Command<Context>): Meta<Context>;
    schema?: {
        validate: (object: any) => void;
    };
    usage?: Usage;
};
export declare abstract class Command<Context extends BaseContext = BaseContext> {
    private static meta?;
    static getMeta<Context extends BaseContext>(prototype: Command<Context>): Meta<Context>;
    static resolveMeta<Context extends BaseContext>(prototype: Command<Context>): Meta<Context>;
    private static registerDefinition;
    private static registerTransformer;
    static addPath(...path: string[]): void;
    static addOption<Context extends BaseContext>(name: string, builder: (prototype: Command<Context>, propertyName: string) => void): void;
    /**
     * Wrap the specified command to be attached to the given path on the command line.
     * The first path thus attached will be considered the "main" one, and all others will be aliases.
     * @param path The command path.
     */
    static Path(...path: string[]): <Context extends BaseContext>(prototype: Command<Context>, propertyName: string) => void;
    /**
     * Register a boolean listener for the given option names. When Clipanion detects that this argument is present, the value will be set to false. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.
     * @param descriptor the option names.
     */
    static Boolean(descriptor: string, { hidden }?: {
        hidden?: boolean;
    }): <Context extends BaseContext>(prototype: Command<Context>, propertyName: string) => void;
    /**
     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be set to whatever follows the option in the input. The value won't be set unless the option is found, so you must remember to set it to an appropriate default value.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     * @param descriptor The option names.
     */
    static String(descriptor: string, opts?: {
        hidden?: boolean;
    }): PropertyDecorator;
    /**
     * Register a listener that looks for positional arguments. When Clipanion detects that an argument isn't an option, it will put it in this property and continue processing the rest of the command line.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     * @param descriptor Whether or not filling the positional argument is required for the command to be a valid selection.
     */
    static String(descriptor?: {
        required: boolean;
    }): PropertyDecorator;
    /**
     * Register a listener that looks for an option and its followup argument. When Clipanion detects that this argument is present, the value will be pushed into the array represented in the property.
     */
    static Array(descriptor: string, { hidden }?: {
        hidden?: boolean;
    }): <Context extends BaseContext>(prototype: Command<Context>, propertyName: string) => void;
    /**
     * Register a listener that takes all the positional arguments remaining and store them into the selected property.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     */
    static Rest(): PropertyDecorator;
    /**
     * Register a listener that takes all the positional arguments remaining and store them into the selected property.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     * @param opts.required The minimal number of arguments required for the command to be successful.
     */
    static Rest(opts: {
        required: number;
    }): PropertyDecorator;
    /**
     * Register a listener that takes all the arguments remaining (including options and such) and store them into the selected property.
     * Note that all methods affecting positional arguments are evaluated in the definition order; don't mess with it (for example sorting your properties in ascendent order might have adverse results).
     */
    static Proxy(): <Context extends BaseContext>(prototype: Command<Context>, propertyName: string) => void;
    /**
     * Defines the usage information for the given command.
     * @param usage
     */
    static Usage(usage: Usage): Usage;
    /**
     * Contains the usage information for the command. If undefined, the command will be hidden from the general listing.
     */
    static usage?: Usage;
    /**
     * Standard command that'll get executed by `Cli#run` and `Cli#runExit`. Expected to return an exit code or nothing (which Clipanion will treat as if 0 had been returned).
     */
    abstract execute(): Promise<number | void>;
    validateAndExecute(): Promise<number>;
    /**
     * Predefined that will be set to true if `-h,--help` has been used, in which case `Command#execute` shouldn't be called.
     */
    help: boolean;
    /**
     * Predefined variable that will be populated with a miniature API that can be used to query Clipanion and forward commands.
     */
    cli: MiniCli<Context>;
    /**
     * Predefined variable that will be populated with the context of the application.
     */
    context: Context;
    /**
     * The path that got used to access the command being executed.
     */
    path: string[];
}
