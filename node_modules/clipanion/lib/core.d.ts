export declare const NODE_INITIAL = 0;
export declare const NODE_SUCCESS = 1;
export declare const NODE_ERRORED = 2;
export declare const START_OF_INPUT = "\u0001";
export declare const END_OF_INPUT = "\0";
export declare const HELP_COMMAND_INDEX = -1;
export declare const HELP_REGEX: RegExp;
export declare const OPTION_REGEX: RegExp;
export declare const BATCH_REGEX: RegExp;
export declare const BINDING_REGEX: RegExp;
export declare const DEBUG: boolean;
export declare function debug(str: string): void;
export declare type StateMachine = {
    nodes: Node[];
};
export declare type RunState = {
    candidateUsage: string | null;
    errorMessage: string | null;
    ignoreOptions: boolean;
    options: {
        name: string;
        value: any;
    }[];
    path: string[];
    positionals: {
        value: string;
        extra: boolean;
    }[];
    remainder: string | null;
    selectedIndex: number | null;
};
export declare function makeStateMachine(): StateMachine;
export declare function makeAnyOfMachine(inputs: StateMachine[]): StateMachine;
export declare function injectNode(machine: StateMachine, node: Node): number;
export declare function simplifyMachine(input: StateMachine): void;
export declare function debugMachine(machine: StateMachine, { prefix }?: {
    prefix?: string;
}): void;
export declare function runMachineInternal(machine: StateMachine, input: string[], partial?: boolean): {
    node: number;
    state: RunState;
}[];
export declare function trimSmallerBranches(branches: {
    node: number;
    state: RunState;
}[]): {
    node: number;
    state: RunState;
}[];
export declare function selectBestState(input: string[], states: RunState[]): RunState;
export declare function aggregateHelpStates(states: RunState[]): RunState[];
declare type Transition = {
    to: number;
    reducer?: Callback<keyof typeof reducers>;
};
declare type Node = {
    dynamics: [Callback<keyof typeof tests>, Transition][];
    shortcuts: Transition[];
    statics: {
        [segment: string]: Transition[];
    };
};
export declare function makeNode(): Node;
export declare function isTerminalNode(node: number): boolean;
export declare function cloneTransition(input: Transition, offset?: number): {
    to: number;
    reducer: "setCandidateUsage" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushTrue" | "pushFalse" | "pushUndefined" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | ["setCandidateUsage" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushTrue" | "pushFalse" | "pushUndefined" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError", ...any[]] | undefined;
};
export declare function cloneNode(input: Node, offset?: number): Node;
export declare function registerDynamic(machine: StateMachine, from: number, test: Callback<keyof typeof tests>, to: number, reducer?: Callback<keyof typeof reducers>): void;
export declare function registerShortcut(machine: StateMachine, from: number, to: number, reducer?: Callback<keyof typeof reducers>): void;
export declare function registerStatic(machine: StateMachine, from: number, test: string, to: number, reducer?: Callback<keyof typeof reducers>): void;
export declare type CallbackStore<T extends string> = {
    [key: string]: (state: RunState, segment: string, ...args: any[]) => {};
};
export declare type Callback<T extends string> = T | [T, ...any[]];
export declare function execute<T extends string>(store: CallbackStore<T>, callback: Callback<T>, state: RunState, segment: string): any;
export declare function suggest(callback: Callback<keyof typeof tests>, state: RunState): string[] | null;
export declare const tests: {
    always: () => boolean;
    isNotOptionLike: (state: RunState, segment: string) => boolean;
    isOption: (state: RunState, segment: string, name: string, hidden: boolean) => boolean;
    isBatchOption: (state: RunState, segment: string, names: string[]) => boolean;
    isBoundOption: (state: RunState, segment: string, names: string[]) => boolean;
    isNegatedOption: (state: RunState, segment: string, name: string) => boolean;
    isHelp: (state: RunState, segment: string) => boolean;
    isUnsupportedOption: (state: RunState, segment: string, names: string[]) => boolean;
    isInvalidOption: (state: RunState, segment: string) => boolean;
};
export declare const reducers: {
    setCandidateUsage: (state: RunState, segment: string, usage: string) => {
        candidateUsage: string;
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    setSelectedIndex: (state: RunState, segment: string, index: number) => {
        selectedIndex: number;
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
    };
    pushBatch: (state: RunState, segment: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushBound: (state: RunState, segment: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushPath: (state: RunState, segment: string) => {
        path: string[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushPositional: (state: RunState, segment: string) => {
        positionals: {
            value: string;
            extra: boolean;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushExtra: (state: RunState, segment: string) => {
        positionals: {
            value: string;
            extra: boolean;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushTrue: (state: RunState, segment: string, name?: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushFalse: (state: RunState, segment: string, name?: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushUndefined: (state: RunState, segment: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    setStringValue: (state: RunState, segment: string) => {
        options: {
            name: string;
            value: any;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    inhibateOptions: (state: RunState) => {
        ignoreOptions: boolean;
        candidateUsage: string | null;
        errorMessage: string | null;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    useHelp: (state: RunState, segment: string, command: number) => {
        options: {
            name: string;
            value: string;
        }[];
        candidateUsage: string | null;
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    setError: (state: RunState, segment: string, errorMessage: string) => {
        errorMessage: string;
        candidateUsage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
};
export declare const NoLimits: unique symbol;
export declare type ArityDefinition = {
    leading: string[];
    extra: string[] | typeof NoLimits;
    trailing: string[];
    proxy: boolean;
};
export declare type OptDefinition = {
    names: string[];
    arity: 1 | 0;
    hidden: boolean;
};
export declare class CommandBuilder<Context> {
    readonly cliIndex: number;
    readonly cliOpts: Readonly<CliOptions>;
    private readonly allOptionNames;
    private readonly arity;
    private readonly options;
    private readonly paths;
    private context?;
    constructor(cliIndex: number, cliOpts: CliOptions);
    addPath(path: string[]): void;
    setArity({ leading, trailing, extra, proxy }: Partial<ArityDefinition>): void;
    addPositional({ name, required }?: {
        name?: string;
        required?: boolean;
    }): void;
    addRest({ name, required }?: {
        name?: string;
        required?: number;
    }): void;
    addProxy(): void;
    addOption({ names, arity, hidden }: Partial<OptDefinition> & {
        names: string[];
    }): void;
    setContext(context: Context): void;
    usage({ detailed }?: {
        detailed?: boolean;
    }): string;
    compile(): {
        machine: StateMachine;
        context: Context;
    };
    private registerOptions;
}
export declare type CliOptions = {
    binaryName: string;
};
export declare type CliBuilderCallback<Context> = (command: CommandBuilder<Context>) => CommandBuilder<Context> | void;
export declare class CliBuilder<Context> {
    private readonly opts;
    private readonly builders;
    static build<Context>(cbs: CliBuilderCallback<Context>[], opts?: Partial<CliOptions>): {
        machine: StateMachine;
        contexts: Context[];
        process: (input: string[]) => RunState;
        suggest: (input: string[], partial: boolean) => string[][];
    };
    constructor({ binaryName }?: Partial<CliOptions>);
    getBuilderByIndex(n: number): CommandBuilder<Context>;
    commands(cbs: CliBuilderCallback<Context>[]): this;
    command(): CommandBuilder<Context>;
    compile(): {
        machine: StateMachine;
        contexts: Context[];
        process: (input: string[]) => RunState;
        suggest: (input: string[], partial: boolean) => string[][];
    };
}
export {};
